Searching 937 files for "(/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+/)|(//.*)" (regex)

/Users/anthonybudd/Development/darknet/data/dog.jpg:
    ERROR: Regex exhausted stack searching file

/Users/anthonybudd/Development/darknet/data/eagle.jpg:
    ERROR: Regex exhausted stack searching file

/Users/anthonybudd/Development/darknet/data/giraffe.jpg:
    ERROR: Regex exhausted stack searching file

/Users/anthonybudd/Development/darknet/data/horses.jpg:
    ERROR: Regex exhausted stack searching file

/Users/anthonybudd/Development/darknet/data/labels/34_0.png:
    <binary>

/Users/anthonybudd/Development/darknet/data/labels/38_3.png:
    <binary>

/Users/anthonybudd/Development/darknet/data/labels/41_2.png:
    <binary>

/Users/anthonybudd/Development/darknet/data/labels/68_5.png:
    <binary>

/Users/anthonybudd/Development/darknet/data/person.jpg:
    <binary>

/Users/anthonybudd/Development/darknet/data/scream.jpg:
    ERROR: Regex exhausted stack searching file

/Users/anthonybudd/Development/darknet/Makefile:
    ERROR: Regex exhausted stack searching file

/Users/anthonybudd/Development/darknet/README.md:
    1: ![Darknet Logo](http://pjreddie.com/media/files/darknet-black-small.png)
    2  
    3  #Darknet#
    4  Darknet is an open source neural network framework written in C and CUDA. It is fast, easy to install, and supports CPU and GPU computation.
    5  
    6: For more information see the [Darknet project website](http://pjreddie.com/darknet).
    7  
    8: For questions or issues please use the [Google Group](https://groups.google.com/forum/#!forum/darknet).
    9  

/Users/anthonybudd/Development/darknet/scripts/gen_tactic.sh:
    1  #!/bin/bash
    2  # Usage:
    3: # wget http://pjreddie.com/media/files/peek.weights
    4  # scripts/gen_tactic.sh < data/goal.txt
    5  ./darknet rnn generatetactic cfg/gru.cfg peek.weights 2>/dev/null

/Users/anthonybudd/Development/darknet/src/blas_kernels.cu:
   92  }
   93  
   94: /*
   95: __global__ void dot_kernel(float *output, float scale, int batch, int n, int size, float *delta)
   96: {
   97:     int index = (blockIdx.x + blockIdx.y*gridDim.x) * blockDim.x + threadIdx.x;
   98:     int f1 = index / n;
   99:     int f2 = index % n;
  100:     if (f2 <= f1) return;
  101:     
  102:     float sum = 0;
  103:     float norm1 = 0;
  104:     float norm2 = 0;
  105:     int b, i;
  106:     for(b = 0; b <  batch; ++b){
  107:         for(i = 0; i < size; ++i){
  108:             int i1 = b * size * n + f1 * size + i;
  109:             int i2 = b * size * n + f2 * size + i;
  110:             sum += output[i1] * output[i2];
  111:             norm1 += output[i1] * output[i1];
  112:             norm2 += output[i2] * output[i2];
  113:         }
  114:     }
  115:     norm1 = sqrt(norm1);
  116:     norm2 = sqrt(norm2);
  117:     float norm = norm1 * norm2;
  118:     sum = sum / norm;
  119:     for(b = 0; b <  batch; ++b){
  120:         for(i = 0; i < size; ++i){
  121:             int i1 = b * size * n + f1 * size + i;
  122:             int i2 = b * size * n + f2 * size + i;
  123:             delta[i1] += - scale * sum * output[i2] / norm;
  124:             delta[i2] += - scale * sum * output[i1] / norm;
  125:         }
  126:     }
  127: }
  128: 
  129: void dot_error_gpu(layer l)
  130: {
  131:     dot_kernel<<<cuda_gridsize(l.n*l.n), BLOCK>>>(l.output_gpu, l.dot, l.batch, l.n, l.out_w * l.out_h, l.delta_gpu);
  132:     check_error(cudaPeekAtLastError());
  133: }
  134: */
  135  
  136  void backward_bias_gpu(float *bias_updates, float *delta, int batch, int n, int size)
  ...
  147      
  148      x[index] = x[index] - (rate * sqrt(1.-pow(B2, t)) / (1.-pow(B1, t)) * m[index] / (sqrt(v[index]) + eps));
  149:     //if(index == 0) printf("%f %f %f %f\n", m[index], v[index], (rate * sqrt(1.-pow(B2, t)) / (1.-pow(B1, t)) * m[index] / (sqrt(v[index]) + eps)));
  150  }
  151  
  ...
  347      int w2 = in_w*stride + offset % stride;
  348      int h2 = in_h*stride + offset / stride;
  349:     //printf("%d\n", offset);
  350      int out_index = w2 + w*stride*(h2 + h*stride*(c2 + out_c*b));
  351  
  352:    // printf("%d %d %d\n", w2, h2, c2);
  353:     //printf("%d %d\n", in_index, out_index);
  354:     //if(out_index >= N || out_index < 0) printf("bad bad bad \n");
  355  
  356      if(forward) out[out_index] = x[in_index];
  357      else out[in_index] = x[out_index];
  358:     //if(forward) out[1] = x[1];
  359:     //else out[0] = x[0];
  360  }
  361  
  ...
  675      if(i < n){
  676          float diff = truth[i] - pred[i];
  677:         error[i] = diff * diff; //I know this is technically wrong, deal with it.
  678          delta[i] = diff;
  679      }

/Users/anthonybudd/Development/darknet/src/captcha.c:
   74          fix_data_captcha(train, solved);
   75  
   76:         /*
   77:            image im = float_to_image(256, 256, 3, train.X.vals[114]);
   78:            show_image(im, "training");
   79:            cvWaitKey(0);
   80:          */
   81  
   82          load_thread = load_data_in_thread(args);
   ..
  113              strncpy(input, filename, 256);
  114          }else{
  115:             //printf("Enter Image Path: ");
  116:             //fflush(stdout);
  117              input = fgets(input, 256, stdin);
  118              if(!input) return;
  ...
  123          float *predictions = network_predict(net, X);
  124          top_predictions(net, 26, indexes);
  125:         //printf("%s: Predicted in %f seconds.\n", input, sec(clock()-time));
  126          for(i = 0; i < 26; ++i){
  127              int index = indexes[i];
  ...
  156          float *X = im.data;
  157          float *predictions = network_predict(net, X);
  158:         //printf("%s: Predicted in %f seconds.\n", input, sec(clock()-time));
  159          int truth = -1;
  160          for(j = 0; j < 13; ++j){
  ...
  177  }
  178  
  179: /*
  180:    void train_captcha(char *cfgfile, char *weightfile)
  181:    {
  182:    float avg_loss = -1;
  183:    srand(time(0));
  184:    char *base = basecfg(cfgfile);
  185:    printf("%s\n", base);
  186:    network net = parse_network_cfg(cfgfile);
  187:    if(weightfile){
  188:    load_weights(&net, weightfile);
  189:    }
  190:    printf("Learning Rate: %g, Momentum: %g, Decay: %g\n", net.learning_rate, net.momentum, net.decay);
  191:    int imgs = 1024;
  192:    int i = net.seen/imgs;
  193:    list *plist = get_paths("/data/captcha/train.auto5");
  194:    char **paths = (char **)list_to_array(plist);
  195:    printf("%d\n", plist->size);
  196:    clock_t time;
  197:    while(1){
  198:    ++i;
  199:    time=clock();
  200:    data train = load_data_captcha(paths, imgs, plist->size, 10, 200, 60);
  201:    translate_data_rows(train, -128);
  202:    scale_data_rows(train, 1./128);
  203:    printf("Loaded: %lf seconds\n", sec(clock()-time));
  204:    time=clock();
  205:    float loss = train_network(net, train);
  206:    net.seen += imgs;
  207:    if(avg_loss == -1) avg_loss = loss;
  208:    avg_loss = avg_loss*.9 + loss*.1;
  209:    printf("%d: %f, %f avg, %lf seconds, %d images\n", i, loss, avg_loss, sec(clock()-time), net.seen);
  210:    free_data(train);
  211:    if(i%10==0){
  212:    char buff[256];
  213:    sprintf(buff, "/home/pjreddie/imagenet_backup/%s_%d.weights",base, i);
  214:    save_weights(net, buff);
  215:    }
  216:    }
  217:    }
  218: 
  219:    void decode_captcha(char *cfgfile, char *weightfile)
  220:    {
  221:    setbuf(stdout, NULL);
  222:    srand(time(0));
  223:    network net = parse_network_cfg(cfgfile);
  224:    set_batch_network(&net, 1);
  225:    if(weightfile){
  226:    load_weights(&net, weightfile);
  227:    }
  228:    char filename[256];
  229:    while(1){
  230:    printf("Enter filename: ");
  231:    fgets(filename, 256, stdin);
  232:    strtok(filename, "\n");
  233:    image im = load_image_color(filename, 300, 57);
  234:    scale_image(im, 1./255.);
  235:    float *X = im.data;
  236:    float *predictions = network_predict(net, X);
  237:    image out  = float_to_image(300, 57, 1, predictions);
  238:    show_image(out, "decoded");
  239: #ifdef OPENCV
  240: cvWaitKey(0);
  241: #endif
  242: free_image(im);
  243: }
  244: }
  245: 
  246: void encode_captcha(char *cfgfile, char *weightfile)
  247: {
  248: float avg_loss = -1;
  249: srand(time(0));
  250: char *base = basecfg(cfgfile);
  251: printf("%s\n", base);
  252: network net = parse_network_cfg(cfgfile);
  253: if(weightfile){
  254:     load_weights(&net, weightfile);
  255: }
  256: printf("Learning Rate: %g, Momentum: %g, Decay: %g\n", net.learning_rate, net.momentum, net.decay);
  257: int imgs = 1024;
  258: int i = net.seen/imgs;
  259: list *plist = get_paths("/data/captcha/encode.list");
  260: char **paths = (char **)list_to_array(plist);
  261: printf("%d\n", plist->size);
  262: clock_t time;
  263: while(1){
  264:     ++i;
  265:     time=clock();
  266:     data train = load_data_captcha_encode(paths, imgs, plist->size, 300, 57);
  267:     scale_data_rows(train, 1./255);
  268:     printf("Loaded: %lf seconds\n", sec(clock()-time));
  269:     time=clock();
  270:     float loss = train_network(net, train);
  271:     net.seen += imgs;
  272:     if(avg_loss == -1) avg_loss = loss;
  273:     avg_loss = avg_loss*.9 + loss*.1;
  274:     printf("%d: %f, %f avg, %lf seconds, %d images\n", i, loss, avg_loss, sec(clock()-time), net.seen);
  275:     free_matrix(train.X);
  276:     if(i%100==0){
  277:         char buff[256];
  278:         sprintf(buff, "/home/pjreddie/imagenet_backup/%s_%d.weights",base, i);
  279:         save_weights(net, buff);
  280:     }
  281: }
  282: }
  283: 
  284: void validate_captcha(char *cfgfile, char *weightfile)
  285: {
  286:     srand(time(0));
  287:     char *base = basecfg(cfgfile);
  288:     printf("%s\n", base);
  289:     network net = parse_network_cfg(cfgfile);
  290:     if(weightfile){
  291:         load_weights(&net, weightfile);
  292:     }
  293:     int numchars = 37;
  294:     list *plist = get_paths("/data/captcha/solved.hard");
  295:     char **paths = (char **)list_to_array(plist);
  296:     int imgs = plist->size;
  297:     data valid = load_data_captcha(paths, imgs, 0, 10, 200, 60);
  298:     translate_data_rows(valid, -128);
  299:     scale_data_rows(valid, 1./128);
  300:     matrix pred = network_predict_data(net, valid);
  301:     int i, k;
  302:     int correct = 0;
  303:     int total = 0;
  304:     int accuracy = 0;
  305:     for(i = 0; i < imgs; ++i){
  306:         int allcorrect = 1;
  307:         for(k = 0; k < 10; ++k){
  308:             char truth = int_to_alphanum(max_index(valid.y.vals[i]+k*numchars, numchars));
  309:             char prediction = int_to_alphanum(max_index(pred.vals[i]+k*numchars, numchars));
  310:             if (truth != prediction) allcorrect=0;
  311:             if (truth != '.' && truth == prediction) ++correct;
  312:             if (truth != '.' || truth != prediction) ++total;
  313:         }
  314:         accuracy += allcorrect;
  315:     }
  316:     printf("Word Accuracy: %f, Char Accuracy %f\n", (float)accuracy/imgs, (float)correct/total);
  317:     free_data(valid);
  318: }
  319: 
  320: void test_captcha(char *cfgfile, char *weightfile)
  321: {
  322:     setbuf(stdout, NULL);
  323:     srand(time(0));
  324:     //char *base = basecfg(cfgfile);
  325:     //printf("%s\n", base);
  326:     network net = parse_network_cfg(cfgfile);
  327:     set_batch_network(&net, 1);
  328:     if(weightfile){
  329:         load_weights(&net, weightfile);
  330:     }
  331:     char filename[256];
  332:     while(1){
  333:         //printf("Enter filename: ");
  334:         fgets(filename, 256, stdin);
  335:         strtok(filename, "\n");
  336:         image im = load_image_color(filename, 200, 60);
  337:         translate_image(im, -128);
  338:         scale_image(im, 1/128.);
  339:         float *X = im.data;
  340:         float *predictions = network_predict(net, X);
  341:         print_letters(predictions, 10);
  342:         free_image(im);
  343:     }
  344: }
  345:     */
  346  void run_captcha(int argc, char **argv)
  347  {
  ...
  357      else if(0==strcmp(argv[2], "test")) test_captcha(cfg, weights, filename);
  358      else if(0==strcmp(argv[2], "valid")) valid_captcha(cfg, weights, filename);
  359:     //if(0==strcmp(argv[2], "test")) test_captcha(cfg, weights);
  360:     //else if(0==strcmp(argv[2], "encode")) encode_captcha(cfg, weights);
  361:     //else if(0==strcmp(argv[2], "decode")) decode_captcha(cfg, weights);
  362:     //else if(0==strcmp(argv[2], "valid")) validate_captcha(cfg, weights);
  363  }
  364  

/Users/anthonybudd/Development/darknet/src/classifier.c:
  147  
  148  
  149: /*
  150:    void train_classifier(char *datacfg, char *cfgfile, char *weightfile, int clear)
  151:    {
  152:    srand(time(0));
  153:    float avg_loss = -1;
  154:    char *base = basecfg(cfgfile);
  155:    printf("%s\n", base);
  156:    network net = parse_network_cfg(cfgfile);
  157:    if(weightfile){
  158:    load_weights(&net, weightfile);
  159:    }
  160:    if(clear) *net.seen = 0;
  161: 
  162:    int imgs = net.batch * net.subdivisions;
  163: 
  164:    printf("Learning Rate: %g, Momentum: %g, Decay: %g\n", net.learning_rate, net.momentum, net.decay);
  165:    list *options = read_data_cfg(datacfg);
  166: 
  167:    char *backup_directory = option_find_str(options, "backup", "/backup/");
  168:    char *label_list = option_find_str(options, "labels", "data/labels.list");
  169:    char *train_list = option_find_str(options, "train", "data/train.list");
  170:    int classes = option_find_int(options, "classes", 2);
  171: 
  172:    char **labels = get_labels(label_list);
  173:    list *plist = get_paths(train_list);
  174:    char **paths = (char **)list_to_array(plist);
  175:    printf("%d\n", plist->size);
  176:    int N = plist->size;
  177:    clock_t time;
  178: 
  179:    load_args args = {0};
  180:    args.w = net.w;
  181:    args.h = net.h;
  182:    args.threads = 8;
  183: 
  184:    args.min = net.min_crop;
  185:    args.max = net.max_crop;
  186:    args.angle = net.angle;
  187:    args.aspect = net.aspect;
  188:    args.exposure = net.exposure;
  189:    args.saturation = net.saturation;
  190:    args.hue = net.hue;
  191:    args.size = net.w;
  192:    args.hierarchy = net.hierarchy;
  193: 
  194:    args.paths = paths;
  195:    args.classes = classes;
  196:    args.n = imgs;
  197:    args.m = N;
  198:    args.labels = labels;
  199:    args.type = CLASSIFICATION_DATA;
  200: 
  201:    data train;
  202:    data buffer;
  203:    pthread_t load_thread;
  204:    args.d = &buffer;
  205:    load_thread = load_data(args);
  206: 
  207:    int epoch = (*net.seen)/N;
  208:    while(get_current_batch(net) < net.max_batches || net.max_batches == 0){
  209:    time=clock();
  210: 
  211:    pthread_join(load_thread, 0);
  212:    train = buffer;
  213:    load_thread = load_data(args);
  214: 
  215:    printf("Loaded: %lf seconds\n", sec(clock()-time));
  216:    time=clock();
  217: 
  218: #ifdef OPENCV
  219: if(0){
  220: int u;
  221: for(u = 0; u < imgs; ++u){
  222:     image im = float_to_image(net.w, net.h, 3, train.X.vals[u]);
  223:     show_image(im, "loaded");
  224:     cvWaitKey(0);
  225: }
  226: }
  227: #endif
  228: 
  229: float loss = train_network(net, train);
  230: free_data(train);
  231: 
  232: if(avg_loss == -1) avg_loss = loss;
  233: avg_loss = avg_loss*.9 + loss*.1;
  234: printf("%d, %.3f: %f, %f avg, %f rate, %lf seconds, %d images\n", get_current_batch(net), (float)(*net.seen)/N, loss, avg_loss, get_current_rate(net), sec(clock()-time), *net.seen);
  235: if(*net.seen/N > epoch){
  236:     epoch = *net.seen/N;
  237:     char buff[256];
  238:     sprintf(buff, "%s/%s_%d.weights",backup_directory,base, epoch);
  239:     save_weights(net, buff);
  240: }
  241: if(get_current_batch(net)%100 == 0){
  242:     char buff[256];
  243:     sprintf(buff, "%s/%s.backup",backup_directory,base);
  244:     save_weights(net, buff);
  245: }
  246: }
  247: char buff[256];
  248: sprintf(buff, "%s/%s.weights", backup_directory, base);
  249: save_weights(net, buff);
  250: 
  251: free_network(net);
  252: free_ptrs((void**)labels, classes);
  253: free_ptrs((void**)paths, plist->size);
  254: free_list(plist);
  255: free(base);
  256: }
  257: */
  258  
  259  void validate_classifier_crop(char *datacfg, char *filename, char *weightfile)
  ...
  437          image resized = resize_min(im, size);
  438          resize_network(&net, resized.w, resized.h);
  439:         //show_image(im, "orig");
  440:         //show_image(crop, "cropped");
  441:         //cvWaitKey(0);
  442          float *pred = network_predict(net, resized.data);
  443          if(net.hierarchy) hierarchy_predictions(pred, net.outputs, net.hierarchy, 1);
  ...
  499          image resized = resize_min(im, net.w);
  500          image crop = crop_image(resized, (resized.w - net.w)/2, (resized.h - net.h)/2, net.w, net.h);
  501:         //show_image(im, "orig");
  502:         //show_image(crop, "cropped");
  503:         //cvWaitKey(0);
  504          float *pred = network_predict(net, crop.data);
  505          if(net.hierarchy) hierarchy_predictions(pred, net.outputs, net.hierarchy, 1);
  ...
  640              printf("%f\n", l.output[i]);
  641          }
  642:         /*
  643: 
  644:            printf("\n\nWeights\n");
  645:            for(i = 0; i < l.n*l.size*l.size*l.c; ++i){
  646:            printf("%f\n", l.filters[i]);
  647:            }
  648: 
  649:            printf("\n\nBiases\n");
  650:            for(i = 0; i < l.n; ++i){
  651:            printf("%f\n", l.biases[i]);
  652:            }
  653:          */
  654  
  655          top_predictions(net, top, indexes);
  ...
  812          int i, j;
  813          if (target_layer >= 0){
  814:             //layer l = net.layers[target_layer];
  815          }
  816  
  ...
  862  
  863      if(!cap) error("Couldn't connect to webcam.\n");
  864:     //cvNamedWindow("Threat", CV_WINDOW_NORMAL); 
  865:     //cvResizeWindow("Threat", 512, 512);
  866      float fps = 0;
  867      int i;
  ...
  937          char buff[256];
  938          sprintf(buff, "/home/pjreddie/tmp/threat_%06d", count);
  939:         //save_image(out, buff);
  940  
  941          printf("\033[2J");

/Users/anthonybudd/Development/darknet/src/coco.c:
   19  void train_coco(char *cfgfile, char *weightfile)
   20  {
   21:     //char *train_images = "/home/pjreddie/data/voc/test/train.txt";
   22:     //char *train_images = "/home/pjreddie/data/coco/train.txt";
   23      char *train_images = "data/coco.trainval.txt";
   24:     //char *train_images = "data/bags.train.list";
   25      char *backup_directory = "/home/pjreddie/backup/";
   26      srand(time(0));
   ..
   45  
   46      list *plist = get_paths(train_images);
   47:     //int N = plist->size;
   48      char **paths = (char **)list_to_array(plist);
   49  
   ..
   67      pthread_t load_thread = load_data_in_thread(args);
   68      clock_t time;
   69:     //while(i*imgs < N*120){
   70      while(get_current_batch(net) < net.max_batches){
   71          i += 1;
   ..
   77          printf("Loaded: %lf seconds\n", sec(clock()-time));
   78  
   79:         /*
   80:            image im = float_to_image(net.w, net.h, 3, train.X.vals[113]);
   81:            image copy = copy_image(im);
   82:            draw_coco(copy, train.y.vals[113], 7, "truth");
   83:            cvWaitKey(0);
   84:            free_image(copy);
   85:          */
   86  
   87          time=clock();
   ..
  151      char *base = "results/";
  152      list *plist = get_paths("data/coco_val_5k.list");
  153:     //list *plist = get_paths("/home/pjreddie/data/people-art/test.txt");
  154:     //list *plist = get_paths("/home/pjreddie/data/voc/test/2007_test.txt");
  155      char **paths = (char **)list_to_array(plist);
  156  

/Users/anthonybudd/Development/darknet/src/col2im.c:
   11      im[col + width*(row + height*channel)] += val;
   12  }
   13: //This one might be too, can't remember.
   14  void col2im_cpu(float* data_col,
   15           int channels,  int height,  int width,

/Users/anthonybudd/Development/darknet/src/col2im_kernels.cu:
    8  }
    9  
   10: // src: https://github.com/BVLC/caffe/blob/master/src/caffe/util/im2col.cu
   11: // You may also want to read: https://github.com/BVLC/caffe/blob/master/LICENSE
   12  
   13  __global__ void col2im_gpu_kernel(const int n, const float* data_col,
   ..
   23          int h = (index / width) % height + pad;
   24          int c = index / (width * height);
   25:         // compute the start and end of the output
   26          int w_col_start = (w < ksize) ? 0 : (w - ksize) / stride + 1;
   27          int w_col_end = min(w / stride + 1, width_col);
   28          int h_col_start = (h < ksize) ? 0 : (h - ksize) / stride + 1;
   29          int h_col_end = min(h / stride + 1, height_col);
   30:         // equivalent implementation
   31          int offset =
   32              (c * ksize * ksize + h * ksize + w) * height_col * width_col;
   ..
   45          int channels, int height, int width,
   46          int ksize, int stride, int pad, float *data_im){
   47:     // We are going to launch channels * height_col * width_col kernels, each
   48:     // kernel responsible for copying a single-channel grid.
   49      int height_col = (height + 2 * pad - ksize) / stride + 1;
   50      int width_col = (width + 2 * pad - ksize) / stride + 1;

/Users/anthonybudd/Development/darknet/src/compare.c:
   89  
   90      list *plist = get_paths("data/compare.val.list");
   91:     //list *plist = get_paths("data/compare.val.old");
   92      char **paths = (char **)list_to_array(plist);
   93      int N = plist->size/2;
   ..
  236  
  237      list *plist = get_paths("data/compare.sort.list");
  238:     //list *plist = get_paths("data/compare.val.old");
  239      char **paths = (char **)list_to_array(plist);
  240      int N = plist->size;
  ...
  268  
  269      list *plist = get_paths("data/compare.sort.list");
  270:     //list *plist = get_paths("data/compare.small.list");
  271:     //list *plist = get_paths("data/compare.cat.list");
  272:     //list *plist = get_paths("data/compare.val.old");
  273      char **paths = (char **)list_to_array(plist);
  274      int N = plist->size;
  ...
  340      char *cfg = argv[3];
  341      char *weights = (argc > 4) ? argv[4] : 0;
  342:     //char *filename = (argc > 5) ? argv[5]: 0;
  343      if(0==strcmp(argv[2], "train")) train_compare(cfg, weights);
  344      else if(0==strcmp(argv[2], "valid")) validate_compare(cfg, weights);
  345      else if(0==strcmp(argv[2], "sort")) SortMaster3000(cfg, weights);
  346      else if(0==strcmp(argv[2], "battle")) BattleRoyaleWithCheese(cfg, weights);
  347:     /*
  348:        else if(0==strcmp(argv[2], "train")) train_coco(cfg, weights);
  349:        else if(0==strcmp(argv[2], "extract")) extract_boxes(cfg, weights);
  350:        else if(0==strcmp(argv[2], "valid")) validate_recall(cfg, weights);
  351:      */
  352  }
  353  

/Users/anthonybudd/Development/darknet/src/connected_layer.c:
   41      l.update = update_connected_layer;
   42  
   43:     //float scale = 1./sqrt(inputs);
   44      float scale = sqrt(2./inputs);
   45      for(i = 0; i < outputs*inputs; ++i){
   ..
  213          printf("Scales ");
  214          print_statistics(l.scales, l.outputs);
  215:         /*
  216:         printf("Rolling Mean ");
  217:         print_statistics(l.rolling_mean, l.outputs);
  218:         printf("Rolling Variance ");
  219:         print_statistics(l.rolling_variance, l.outputs);
  220:         */
  221      }
  222      printf("Biases ");

/Users/anthonybudd/Development/darknet/src/convolutional_kernels.cu:
   61      for(i = 0; i < size; ++i){
   62          binary[f*size + i] = (weights[f*size + i] > 0) ? mean : -mean;
   63:         //binary[f*size + i] = weights[f*size + i];
   64      }
   65  }
   ..
  122  
  123      activate_array_ongpu(l.output_gpu, l.outputs*l.batch, l.activation);
  124:     //if(l.dot > 0) dot_error_gpu(l);
  125      if(l.binary || l.xnor) swap_binary(&l);
  126  }
  ...
  128  void backward_convolutional_layer_gpu(convolutional_layer l, network_state state)
  129  {
  130:     //constrain_ongpu(l.outputs*l.batch, 1, l.delta_gpu, 1);
  131      gradient_array_ongpu(l.output_gpu, l.outputs*l.batch, l.activation, l.delta_gpu);
  132  
  ...
  135      if(l.batch_normalize){
  136          backward_batchnorm_layer_gpu(l, state);
  137:         //axpy_ongpu(l.outputs*l.batch, -state.net.decay, l.x_gpu, 1, l.delta_gpu, 1);
  138      } else {
  139:         //axpy_ongpu(l.outputs*l.batch, -state.net.decay, l.output_gpu, 1, l.delta_gpu, 1);
  140      }
  141      float *original_input = state.input;

/Users/anthonybudd/Development/darknet/src/convolutional_layer.c:
  196      l.bias_updates = calloc(n, sizeof(float));
  197  
  198:     // float scale = 1./sqrt(size*size*c);
  199      float scale = sqrt(2./(size*size*c));
  200      for(i = 0; i < c*n*size*size; ++i) l.weights[i] = scale*rand_uniform(-1, 1);
  ...
  559      for(i = 0; i < l.n; ++i){
  560          weights[i] = copy_image(get_convolutional_weight(l, i));
  561:         //normalize_image(weights[i]);
  562      }
  563      return weights;
  ...
  573      char buff[256];
  574      sprintf(buff, "%s: Output", window);
  575:     //show_image(dc, buff);
  576:     //save_image(dc, buff);
  577      free_image(dc);
  578      return single_weights;

/Users/anthonybudd/Development/darknet/src/crnn_layer.c:
  153  
  154          l.state -= l.hidden*l.batch;
  155:         /*
  156:            if(i > 0){
  157:            copy_cpu(l.hidden * l.batch, input_layer.output - l.hidden*l.batch, 1, l.state, 1);
  158:            axpy_cpu(l.hidden * l.batch, 1, self_layer.output - l.hidden*l.batch, 1, l.state, 1);
  159:            }else{
  160:            fill_cpu(l.hidden * l.batch, 0, l.state, 1);
  161:            }
  162:          */
  163  
  164          s.input = l.state;

/Users/anthonybudd/Development/darknet/src/crop_layer_kernels.cu:
  204      check_error(cudaPeekAtLastError());
  205  
  206: /*
  207:        cuda_pull_array(layer.output_gpu, layer.output, size);
  208:        image im = float_to_image(layer.crop_width, layer.crop_height, layer.c, layer.output + 0*(size/layer.batch));
  209:        image im2 = float_to_image(layer.crop_width, layer.crop_height, layer.c, layer.output + 1*(size/layer.batch));
  210:        image im3 = float_to_image(layer.crop_width, layer.crop_height, layer.c, layer.output + 2*(size/layer.batch));
  211: 
  212:        translate_image(im, -translate);
  213:        scale_image(im, 1/scale);
  214:        translate_image(im2, -translate);
  215:        scale_image(im2, 1/scale);
  216:        translate_image(im3, -translate);
  217:        scale_image(im3, 1/scale);
  218:        
  219:        show_image(im, "cropped");
  220:        show_image(im2, "cropped2");
  221:        show_image(im3, "cropped3");
  222:        cvWaitKey(0);
  223:        */
  224  }
  225  

/Users/anthonybudd/Development/darknet/src/cuda.c:
   27  void check_error(cudaError_t status)
   28  {
   29:     //cudaDeviceSynchronize();
   30      cudaError_t status2 = cudaGetLastError();
   31      if (status != cudaSuccess)
   ..
   58      }
   59      dim3 d = {x, y, 1};
   60:     //printf("%ld %ld %ld %ld\n", n, x, y, x*y*BLOCK);
   61      return d;
   62  }
   ..
  120      float *tmp = calloc(n, sizeof(float));
  121      cuda_pull_array(x_gpu, tmp, n);
  122:     //int i;
  123:     //for(i = 0; i < n; ++i) printf("%f %f\n", tmp[i], x[i]);
  124      axpy_cpu(n, -1, x, 1, tmp, 1);
  125      float err = dot_cpu(n, tmp, 1, tmp, 1);

/Users/anthonybudd/Development/darknet/src/darknet.c:
  353  int main(int argc, char **argv)
  354  {
  355:     //test_resize("data/bad.jpg");
  356:     //test_box();
  357:     //test_convolutional_layer();
  358      if(argc < 2){
  359          fprintf(stderr, "usage: %s <function>\n", argv[0]);

/Users/anthonybudd/Development/darknet/src/data.c:
   23  }
   24  
   25: /*
   26: char **get_random_paths_indexes(char **paths, int n, int m, int *indexes)
   27: {
   28:     char **random_paths = calloc(n, sizeof(char*));
   29:     int i;
   30:     pthread_mutex_lock(&mutex);
   31:     for(i = 0; i < n; ++i){
   32:         int index = rand()%m;
   33:         indexes[i] = index;
   34:         random_paths[i] = paths[index];
   35:         if(i == 0) printf("%s\n", paths[index]);
   36:     }
   37:     pthread_mutex_unlock(&mutex);
   38:     return random_paths;
   39: }
   40: */
   41  
   42  char **get_random_paths(char **paths, int n, int m)
   ..
   48          int index = rand()%m;
   49          random_paths[i] = paths[index];
   50:         //if(i == 0) printf("%s\n", paths[index]);
   51      }
   52      pthread_mutex_unlock(&mutex);
   ..
  118          random_distort_image(crop, hue, saturation, exposure);
  119  
  120:         /*
  121:         show_image(im, "orig");
  122:         show_image(crop, "crop");
  123:         cvWaitKey(0);
  124:         */
  125          free_image(im);
  126          X.vals[i] = crop.data;
  ...
  412      int count = 0;
  413      for(j = 0; j < hierarchy->groups; ++j){
  414:         //printf("%d\n", count);
  415          int mask = 1;
  416          for(i = 0; i < hierarchy->group_size[j]; ++i){
  ...
  715  void *load_thread(void *ptr)
  716  {
  717:     //printf("Loading data: %d\n", rand());
  718      load_args a = *(struct load_args*)ptr;
  719      if(a.exposure == 0) a.exposure = 1;
  ...
  820  }
  821  
  822: /*
  823:    data load_data_study(char **paths, int n, int m, char **labels, int k, int min, int max, int size, float angle, float aspect, float hue, float saturation, float exposure)
  824:    {
  825:    data d = {0};
  826:    d.indexes = calloc(n, sizeof(int));
  827:    if(m) paths = get_random_paths_indexes(paths, n, m, d.indexes);
  828:    d.shallow = 0;
  829:    d.X = load_image_augment_paths(paths, n, min, max, size, angle, aspect, hue, saturation, exposure);
  830:    d.y = load_labels_paths(paths, n, labels, k);
  831:    if(m) free(paths);
  832:    return d;
  833:    }
  834:  */
  835  
  836  data load_data_super(char **paths, int n, int m, int w, int h, int scale)
  ...
  963          }
  964      }
  965:     //translate_data_rows(d, -128);
  966      scale_data_rows(d, 1./255);
  967:     //normalize_data_rows(d);
  968      fclose(fp);
  969      return d;
  ...
 1029          fclose(fp);
 1030      }
 1031:     //normalize_data_rows(d);
 1032:     //translate_data_rows(d, -128);
 1033      scale_data_rows(d, 1./255);
 1034      smooth_data(d);

/Users/anthonybudd/Development/darknet/src/demo.c:
   95  void demo(char *cfgfile, char *weightfile, float thresh, int cam_index, const char *filename, char **names, int classes, int frame_skip, char *prefix, float hier_thresh)
   96  {
   97:     //skip = frame_skip;
   98      image **alphabet = load_alphabet();
   99      int delay = frame_skip;

/Users/anthonybudd/Development/darknet/src/detection_layer.c:
   52      int i,j;
   53      memcpy(l.output, state.input, l.outputs*l.batch*sizeof(float));
   54:     //if(l.reorg) reorg(l.output, l.w*l.h, size*l.n, l.batch, 1);
   55      int b;
   56      if (l.softmax){
   ..
  118  
  119                      float iou  = box_iou(out, truth);
  120:                     //iou = 0;
  121                      float rmse = box_rmse(out, truth);
  122                      if(best_iou > 0 || iou > 0){
  ...
  156                  float iou  = box_iou(out, truth);
  157  
  158:                 //printf("%d,", best_index);
  159                  int p_index = index + locations*l.classes + i*l.n + best_index;
  160                  *(l.cost) -= l.noobject_scale * pow(l.output[p_index], 2);
  ...
  213  
  214          printf("Detection Avg IOU: %f, Pos Cat: %f, All Cat: %f, Pos Obj: %f, Any Obj: %f, count: %d\n", avg_iou/count, avg_cat/count, avg_allcat/(count*l.classes), avg_obj/count, avg_anyobj/(l.batch*locations*l.n), count);
  215:         //if(l.reorg) reorg(l.delta, l.w*l.h, size*l.n, l.batch, 0);
  216      }
  217  }
  ...
  226      int i,j,n;
  227      float *predictions = l.output;
  228:     //int per_cell = 5*num+classes;
  229      for (i = 0; i < l.side*l.side; ++i){
  230          int row = i / l.side;
  ...
  282  {
  283      axpy_ongpu(l.batch*l.inputs, 1, l.delta_gpu, 1, state.delta, 1);
  284:     //copy_ongpu(l.batch*l.inputs, l.delta_gpu, 1, state.delta, 1);
  285  }
  286  #endif

/Users/anthonybudd/Development/darknet/src/detector.c:
   53  
   54      list *plist = get_paths(train_images);
   55:     //int N = plist->size;
   56      char **paths = (char **)list_to_array(plist);
   57  
   ..
   77      clock_t time;
   78      int count = 0;
   79:     //while(i*imgs < N*120){
   80      while(get_current_batch(net) < net.max_batches){
   81          if(l.random && count++%10 == 0){
   ..
   83              int dim = (rand() % 10 + 10) * 32;
   84              if (get_current_batch(net)+200 > net.max_batches) dim = 608;
   85:             //int dim = (rand() % 4 + 16) * 32;
   86              printf("%d\n", dim);
   87              args.w = dim;
   ..
  103          load_thread = load_data(args);
  104  
  105:         /*
  106:            int k;
  107:            for(k = 0; k < l.max_boxes; ++k){
  108:            box b = float_to_box(train.y.vals[10] + 1 + k*5);
  109:            if(!b.x) break;
  110:            printf("loaded: %f %f %f %f\n", b.x, b.y, b.w, b.h);
  111:            }
  112:            image im = float_to_image(448, 448, 3, train.X.vals[10]);
  113:            int k;
  114:            for(k = 0; k < l.max_boxes; ++k){
  115:            box b = float_to_box(train.y.vals[10] + 1 + k*5);
  116:            printf("%d %d %d %d\n", truth.x, truth.y, truth.w, truth.h);
  117:            draw_bbox(im, b, 8, 1,0,0);
  118:            }
  119:            save_image(im, "truth11");
  120:          */
  121  
  122          printf("Loaded: %lf seconds\n", sec(clock()-time));

/Users/anthonybudd/Development/darknet/src/dropout_layer_kernels.cu:
   20      int size = layer.inputs*layer.batch;
   21      cuda_random(layer.rand_gpu, size);
   22:     /*
   23:     int i;
   24:     for(i = 0; i < size; ++i){
   25:         layer.rand[i] = rand_uniform();
   26:     }
   27:     cuda_push_array(layer.rand_gpu, layer.rand, size);
   28:     */
   29  
   30      yoloswag420blazeit360noscope<<<cuda_gridsize(size), BLOCK>>>(state.input, size, layer.rand_gpu, layer.probability, layer.scale);

/Users/anthonybudd/Development/darknet/src/gemm.c:
  145          float *C, int ldc)
  146  {
  147:     //printf("cpu: %d %d %d %d %d %f %d %d %f %d\n",TA, TB, M, N, K, ALPHA, lda, ldb, BETA, ldc);
  148      int i, j;
  149      for(i = 0; i < M; ++i){
  ...
  277      memset(c_gpu, 0, m*n*sizeof(float));
  278      int i;
  279:     //pm(m,k,b);
  280      gemm_gpu(TA,TB,m,n,k,1,a,lda,b,ldb,1,c_gpu,n);
  281:     //printf("GPU\n");
  282:     //pm(m, n, c_gpu);
  283  
  284      gemm_cpu(TA,TB,m,n,k,1,a,lda,b,ldb,1,c,n);
  285:     //printf("\n\nCPU\n");
  286:     //pm(m, n, c);
  287      double sse = 0;
  288      for(i = 0; i < m*n; ++i) {
  289:         //printf("%f %f\n", c[i], c_gpu[i]);
  290          sse += pow(c[i]-c_gpu[i], 2);
  291      }
  ...
  299  int test_gpu_blas()
  300  {
  301:     /*
  302:        test_gpu_accuracy(0,0,10,576,75); 
  303: 
  304:        test_gpu_accuracy(0,0,17,10,10); 
  305:        test_gpu_accuracy(1,0,17,10,10); 
  306:        test_gpu_accuracy(0,1,17,10,10); 
  307:        test_gpu_accuracy(1,1,17,10,10); 
  308: 
  309:        test_gpu_accuracy(0,0,1000,10,100); 
  310:        test_gpu_accuracy(1,0,1000,10,100); 
  311:        test_gpu_accuracy(0,1,1000,10,100); 
  312:        test_gpu_accuracy(1,1,1000,10,100); 
  313: 
  314:        test_gpu_accuracy(0,0,10,10,10); 
  315: 
  316:        time_ongpu(0,0,64,2916,363); 
  317:        time_ongpu(0,0,64,2916,363); 
  318:        time_ongpu(0,0,64,2916,363); 
  319:        time_ongpu(0,0,192,729,1600); 
  320:        time_ongpu(0,0,384,196,1728); 
  321:        time_ongpu(0,0,256,196,3456); 
  322:        time_ongpu(0,0,256,196,2304); 
  323:        time_ongpu(0,0,128,4096,12544); 
  324:        time_ongpu(0,0,128,4096,4096); 
  325:      */
  326      time_ongpu(0,0,64,75,12544); 
  327      time_ongpu(0,0,64,75,12544); 

/Users/anthonybudd/Development/darknet/src/go.c:
   56  {
   57      int i, j;
   58:     //memset(board, 0, 1*19*19*sizeof(float));
   59      int count = 0;
   60      for(i = 0; i < 91; ++i){
   ..
  133      float *move = calloc(19*19*net.batch, sizeof(float));
  134      moves m = load_go_moves("/home/pjreddie/backup/go.train");
  135:     //moves m = load_go_moves("games.txt");
  136  
  137      int N = m.n;
  ...
  207  void print_board(float *board, int swap, int *indexes)
  208  {
  209:     //FILE *stream = stdout;
  210      FILE *stream = stderr;
  211      int i,j,n;
  ...
  225                      if(index == indexes[n]){
  226                          found = 1;
  227:                         /*
  228:                         if(n == 0) fprintf(stream, "\uff11");
  229:                         else if(n == 1) fprintf(stream, "\uff12");
  230:                         else if(n == 2) fprintf(stream, "\uff13");
  231:                         else if(n == 3) fprintf(stream, "\uff14");
  232:                         else if(n == 4) fprintf(stream, "\uff15");
  233:                         */
  234                          if(n == 0) fprintf(stream, " 1");
  235                          else if(n == 1) fprintf(stream, " 2");
  ...
  241                  if(found) continue;
  242              }
  243:             //if(board[index]*-swap > 0) fprintf(stream, "\u25C9 ");
  244:             //else if(board[index]*-swap < 0) fprintf(stream, "\u25EF ");
  245              if(board[index]*-swap > 0) fprintf(stream, " O");
  246              else if(board[index]*-swap < 0) fprintf(stream, " X");
  ...
  451          char ids[256];
  452          sprintf(ids, "%d", id);
  453:         //fprintf(stderr, "%s\n", buff);
  454          if (!has_id) ids[0] = 0;
  455          if (!strcmp(buff, "protocol_version")){
  ...
  483              int boardsize = 0;
  484              scanf("%d", &boardsize);
  485:             //fprintf(stderr, "%d\n", boardsize);
  486              if(boardsize != 19){
  487                  printf("?%s unacceptable size\n\n", ids);
  ...
  555  
  556          } else if (!strcmp(buff, "p")){
  557:             //print_board(board, 1, 0);
  558          } else if (!strcmp(buff, "final_status_list")){
  559              char type[256];
  ...
  648              printf("%d: %c %d, %.2f%%\n", i+1, col + 'A' + 1*(col > 7 && noi), (inverted)?19 - row : row+1, move[index]*100);
  649          }
  650:         //if(color == 1) printf("\u25EF Enter move: ");
  651:         //else printf("\u25C9 Enter move: ");
  652          if(color == 1) printf("X Enter move: ");
  653          else printf("O Enter move: ");
  ...
  674                  if (num == 2) board[row*19 + col] = 1;
  675              } else if (c == 'p') {
  676:                 // Pass
  677              } else if(c=='b' || c == 'w'){
  678                  char g;
  ...
  782              fflush(stderr);
  783          }
  784:         //print_board(board, 1, 0);
  785:         //sleep(1);
  786          network use = ((total%2==0) == (player==1)) ? net : net2;
  787          int index = generate_move(use, player, board, multi, .1, .7, two, 0);
  ...
  813  void run_go(int argc, char **argv)
  814  {
  815:     //boards_go();
  816      if(argc < 4){
  817          fprintf(stderr, "usage: %s %s [train/test/valid] [cfg] [weights (optional)]\n", argv[0], argv[1]);

/Users/anthonybudd/Development/darknet/src/im2col.c:
   12  }
   13  
   14: //From Berkeley Vision's Caffe!
   15: //https://github.com/BVLC/caffe/blob/master/LICENSE
   16  void im2col_cpu(float* data_im,
   17       int channels,  int height,  int width,

/Users/anthonybudd/Development/darknet/src/im2col_kernels.cu:
    8  }
    9  
   10: // src: https://github.com/BVLC/caffe/blob/master/src/caffe/util/im2col.cu
   11: // You may also want to read: https://github.com/BVLC/caffe/blob/master/LICENSE
   12  
   13  __global__ void im2col_gpu_kernel(const int n, const float* data_im,
   ..
   38                      data_im_ptr[i * width + j] : 0;
   39  
   40:                 //*data_col_ptr = data_im_ptr[ii * width + jj];
   41  
   42                  data_col_ptr += height_col * width_col;
   ..
   49           int channels, int height, int width,
   50           int ksize, int stride, int pad, float *data_col){
   51:     // We are going to launch channels * height_col * width_col kernels, each
   52:     // kernel responsible for copying a single-channel grid.
   53      int height_col = (height + 2 * pad - ksize) / stride + 1;
   54      int width_col = (width + 2 * pad - ksize) / stride + 1;

/Users/anthonybudd/Development/darknet/src/image.c:
   28      ratio -= i;
   29      float r = (1-ratio) * colors[i][c] + ratio*colors[j][c];
   30:     //printf("%f\n", r);
   31      return r;
   32  }
   ..
  107  void draw_box(image a, int x1, int y1, int x2, int y2, float r, float g, float b)
  108  {
  109:     //normalize_image(a);
  110      int i;
  111      if(x1 < 0) x1 = 0;
  ...
  201              float rgb[3];
  202  
  203:             //width = prob*20+2;
  204  
  205              rgb[0] = red;
  ...
  406      constrain_image(copy);
  407      if(p.c == 3) rgbgr_image(copy);
  408:     //normalize_image(copy);
  409  
  410      char buff[256];
  411:     //sprintf(buff, "%s (%d)", name, windows);
  412      sprintf(buff, "%s", name);
  413  
  ...
  415      int step = disp->widthStep;
  416      cvNamedWindow(buff, CV_WINDOW_NORMAL); 
  417:     //cvMoveWindow(buff, 100*(windows%10) + 200*(windows/10), 100*(windows%10));
  418      ++windows;
  419      for(y = 0; y < p.h; ++y){
  ...
  492          system(buff);
  493          return make_image(10,10,3);
  494:         //exit(0);
  495      }
  496      image out = ipl_to_image(src);
  ...
  536  {
  537      char buff[256];
  538:     //sprintf(buff, "%s (%d)", name, windows);
  539      sprintf(buff, "%s.png", name);
  540      unsigned char *data = calloc(im.w*im.h*im.c, sizeof(char));
  ...
  825  }
  826  
  827: // http://www.cs.rit.edu/~ncs/color/t_convert.html
  828  void rgb_to_hsv(image im)
  829  {
  ...
 1269          int h_offset = i*(ims[0].h+border);
 1270          image copy = copy_image(ims[i]);
 1271:         //normalize_image(copy);
 1272          if(c == 3 && color){
 1273              embed_image(copy, filters, 0, h_offset);
 ....
 1305          int w_offset = i*(size+border);
 1306          image copy = copy_image(ims[i]);
 1307:         //normalize_image(copy);
 1308          if(c == 3 && color){
 1309              embed_image(copy, filters, w_offset, 0);
 ....
 1333  {
 1334      image m = collapse_images_vert(ims, n);
 1335:     /*
 1336:        int w = 448;
 1337:        int h = ((float)m.h/m.w) * 448;
 1338:        if(h > 896){
 1339:        h = 896;
 1340:        w = ((float)m.w/m.h) * 896;
 1341:        }
 1342:        image sized = resize_image(m, w, h);
 1343:      */
 1344      normalize_image(m);
 1345      save_image(m, window);

/Users/anthonybudd/Development/darknet/src/list.c:
   12  }
   13  
   14: /*
   15: void transfer_node(list *s, list *d, node *n)
   16: {
   17:     node *prev, *next;
   18:     prev = n->prev;
   19:     next = n->next;
   20:     if(prev) prev->next = next;
   21:     if(next) next->prev = prev;
   22:     --s->size;
   23:     if(s->front == n) s->front = next;
   24:     if(s->back == n) s->back = prev;
   25: }
   26: */
   27  
   28  void *list_pop(list *l){

/Users/anthonybudd/Development/darknet/src/local_layer.c:
   54      l.bias_updates = calloc(l.outputs, sizeof(float));
   55  
   56:     // float scale = 1./sqrt(size*size*c);
   57      float scale = sqrt(2./(size*size*c));
   58      for(i = 0; i < c*n*size*size; ++i) l.weights[i] = scale*rand_uniform(-1,1);

/Users/anthonybudd/Development/darknet/src/network.c:
   42      net.decay = 0;
   43      #ifdef GPU
   44:         //if(net.gpu_index >= 0) update_network_gpu(net);
   45      #endif
   46  }
   ..
   61                  if(net.steps[i] > batch_num) return rate;
   62                  rate *= net.scales[i];
   63:                 //if(net.steps[i] > batch_num - 1 && net.scales[i] > 1) reset_momentum(net);
   64              }
   65              return rate;
   ..
  329  #endif
  330      int i;
  331:     //if(w == net->w && h == net->h) return 0;
  332      net->w = w;
  333      net->h = h;
  334      int inputs = 0;
  335      size_t workspace_size = 0;
  336:     //fprintf(stderr, "Resizing to %d x %d...\n", w, h);
  337:     //fflush(stderr);
  338      for (i = 0; i < net->n; ++i){
  339          layer l = net->layers[i];
  ...
  383      net->workspace = calloc(1, workspace_size);
  384  #endif
  385:     //fprintf(stderr, " Done!\n");
  386      return 0;
  387  }

/Users/anthonybudd/Development/darknet/src/network.h:
    1: // Oh boy, why am I about to do this....
    2  #ifndef NETWORK_H
    3  #define NETWORK_H

/Users/anthonybudd/Development/darknet/src/network_kernels.cu:
  279  void sync_layer(network *nets, int n, int j)
  280  {
  281:     //printf("Syncing layer %d\n", j);
  282      int i;
  283      network net = nets[0];
  ...
  297          distribute_weights(l, base);
  298      }
  299:     //printf("Done syncing layer %d\n", j);
  300  }
  301  
  ...
  360      for(i = 0; i < n; ++i){
  361          pthread_join(threads[i], 0);
  362:         //printf("%f\n", errors[i]);
  363          sum += errors[i];
  364      }
  365:     //cudaDeviceSynchronize();
  366      if (get_current_batch(nets[0]) % interval == 0) {
  367          printf("Syncing... ");
  ...
  370          printf("Done!\n");
  371      }
  372:     //cudaDeviceSynchronize();
  373      free(threads);
  374      free(errors);

/Users/anthonybudd/Development/darknet/src/nightmare.c:
    9  #endif
   10  
   11: // ./darknet nightmare cfg/extractor.recon.cfg ~/trained/yolo-coco.conv frame6.png -reconstruct -iters 500 -i 3 -lambda .1 -rate .01 -smooth 2
   12  
   13  float abs_mean(float *x, int n)
   ..
   34  void optimize_picture(network *net, image orig, int max_layer, float scale, float rate, float thresh, int norm)
   35  {
   36:     //scale_image(orig, 2);
   37:     //translate_image(orig, -1);
   38      net->n = max_layer + 1;
   39  
   ..
   48      resize_network(net, im.w, im.h);
   49      layer last = net->layers[net->n-1];
   50:     //net->layers[net->n - 1].activation = LINEAR;
   51  
   52      image delta = make_image(im.w, im.h, im.c);
   ..
   80  
   81      if(flip) flip_image(delta);
   82:     //normalize_array(delta.data, delta.w*delta.h*delta.c);
   83      image resized = resize_image(delta, orig.w, orig.h);
   84      image out = crop_image(resized, -dx, -dy, orig.w, orig.h);
   85  
   86:     /*
   87:        image g = grayscale_image(out);
   88:        free_image(out);
   89:        out = g;
   90:      */
   91  
   92:     //rate = rate / abs_mean(out.data, out.w*out.h*out.c);
   93  
   94      if(norm) normalize_array(out.data, out.w*out.h*out.c);
   95      axpy_cpu(orig.w*orig.h*orig.c, rate, out.data, 1, orig.data, 1);
   96  
   97:     /*
   98:        normalize_array(orig.data, orig.w*orig.h*orig.c);
   99:        scale_image(orig, sqrt(var));
  100:        translate_image(orig, mean);
  101:      */
  102  
  103:     //translate_image(orig, 1);
  104:     //scale_image(orig, .5);
  105:     //normalize_image(orig);
  106  
  107      constrain_image(orig);
  ...
  171          scal_cpu(recon.w*recon.h*recon.c, momentum, update.data, 1);
  172  
  173:         //float mag = mag_array(recon.data, recon.w*recon.h*recon.c);
  174:         //scal_cpu(recon.w*recon.h*recon.c, 600/mag, recon.data, 1);
  175  
  176          constrain_image(recon);
  ...
  235          image out_im = get_network_image(net);
  236          image crop = crop_image(out_im, zz, zz, out_im.w-2*zz, out_im.h-2*zz);
  237:         //flip_image(crop);
  238          image f_im = resize_image(crop, out_im.w, out_im.h);
  239          free_image(crop);
  ...
  266              if(reconstruct){
  267                  reconstruct_picture(net, features, im, update, rate, momentum, lambda, smooth_size, 1);
  268:                 //if ((n+1)%30 == 0) rate *= .5;
  269                  show_image(im, "reconstruction");
  270  #ifdef OPENCV
  ...
  291          printf("%d %s\n", e, buff);
  292          save_image(im, buff);
  293:         //show_image(im, buff);
  294:         //cvWaitKey(0);
  295  
  296          if(rotate){

/Users/anthonybudd/Development/darknet/src/normalization_layer.c:
   96  void backward_normalization_layer(const layer layer, network_state state)
   97  {
   98:     // TODO This is approximate ;-)
   99:     // Also this should add in to delta instead of overwritting.
  100  
  101      int w = layer.w;
  ...
  140  void backward_normalization_layer_gpu(const layer layer, network_state state)
  141  {
  142:     // TODO This is approximate ;-)
  143  
  144      int w = layer.w;

/Users/anthonybudd/Development/darknet/src/parser.c:
  685      net.output = get_network_output(net);
  686      if(workspace_size){
  687:         //printf("%ld\n", workspace_size);
  688  #ifdef GPU
  689          if(gpu_index >= 0){
  ...
  769  {
  770      if(l.binary){
  771:         //save_convolutional_weights_binary(l, fp);
  772:         //return;
  773      }
  774  #ifdef GPU
  ...
  901          transpose_matrix(l.weights, l.inputs, l.outputs);
  902      }
  903:     //printf("Biases: %f mean %f variance\n", mean_array(l.biases, l.outputs), variance_array(l.biases, l.outputs));
  904:     //printf("Weights: %f mean %f variance\n", mean_array(l.weights, l.outputs*l.inputs), variance_array(l.weights, l.outputs*l.inputs));
  905      if (l.batch_normalize && (!l.dontloadscales)){
  906          fread(l.scales, sizeof(float), l.outputs, fp);
  907          fread(l.rolling_mean, sizeof(float), l.outputs, fp);
  908          fread(l.rolling_variance, sizeof(float), l.outputs, fp);
  909:         //printf("Scales: %f mean %f variance\n", mean_array(l.scales, l.outputs), variance_array(l.scales, l.outputs));
  910:         //printf("rolling_mean: %f mean %f variance\n", mean_array(l.rolling_mean, l.outputs), variance_array(l.rolling_mean, l.outputs));
  911:         //printf("rolling_variance: %f mean %f variance\n", mean_array(l.rolling_variance, l.outputs), variance_array(l.rolling_variance, l.outputs));
  912      }
  913  #ifdef GPU
  ...
  963  {
  964      if(l.binary){
  965:         //load_convolutional_weights_binary(l, fp);
  966:         //return;
  967      }
  968      int num = l.n*l.c*l.size*l.size;
  ...
  993          fread(l.v, sizeof(float), num, fp);
  994      }
  995:     //if(l.c == 3) scal_cpu(num, 1./256, l.weights, 1);
  996      if (l.flipped) {
  997          transpose_matrix(l.weights, l.c*l.size*l.size, l.n);
  998      }
  999:     //if (l.binary) binarize_weights(l.weights, l.n, l.c*l.size*l.size, l.weights);
 1000  #ifdef GPU
 1001      if(gpu_index >= 0){

/Users/anthonybudd/Development/darknet/src/region_layer.c:
  246              i = (truth.x * l.w);
  247              j = (truth.y * l.h);
  248:             //printf("%d %f %d %f\n", i, truth.x*l.w, j, truth.y*l.h);
  249              box truth_shift = truth;
  250              truth_shift.x = 0;
  251              truth_shift.y = 0;
  252:             //printf("index %d %d\n",i, j);
  253              for(n = 0; n < l.n; ++n){
  254                  int index = size*(j*l.w*l.n + i*l.n + n) + b*l.outputs;
  ...
  258                      pred.h = l.biases[2*n+1]/l.h;
  259                  }
  260:                 //printf("pred: (%f, %f) %f x %f\n", pred.x, pred.y, pred.w, pred.h);
  261                  pred.x = 0;
  262                  pred.y = 0;
  ...
  268                  }
  269              }
  270:             //printf("%d %f (%f, %f) %f x %f\n", best_n, best_iou, truth.x, truth.y, truth.w, truth.h);
  271  
  272              float iou = delta_region_box(truth, l.output, l.biases, best_n, best_index, i, j, l.w, l.h, l.delta, l.coord_scale);
  ...
  274              avg_iou += iou;
  275  
  276:             //l.delta[best_index + 4] = iou - l.output[best_index + 4];
  277              avg_obj += l.output[best_index + 4];
  278              l.delta[best_index + 4] = l.object_scale * (1 - l.output[best_index + 4]) * logistic_gradient(l.output[best_index + 4]);
  ...
  289          }
  290      }
  291:     //printf("\n");
  292  #ifndef GPU
  293      flatten(l.delta, l.w*l.h, size*l.n, l.batch, 0);
  ...
  351  void forward_region_layer_gpu(const layer l, network_state state)
  352  {
  353:     /*
  354:        if(!state.train){
  355:        copy_ongpu(l.batch*l.inputs, state.input, 1, l.output_gpu, 1);
  356:        return;
  357:        }
  358:      */
  359      flatten_ongpu(state.input, l.h*l.w, l.n*(l.coords + l.classes + 1), l.batch, 1, l.output_gpu);
  360      if(l.softmax_tree){
  ...
  383      cpu_state.input = in_cpu;
  384      forward_region_layer(l, cpu_state);
  385:     //cuda_push_array(l.output_gpu, l.output, l.batch*l.outputs);
  386      free(cpu_state.input);
  387      if(!state.train) return;

/Users/anthonybudd/Development/darknet/src/rnn.c:
  100  
  101              if(curr > 255 || curr <= 0 || next > 255 || next <= 0){
  102:                 /*text[(index+j+2)%len] = 0;
  103:                 printf("%ld %d %d %d %d\n", index, j, len, (int)text[index+j], (int)text[index+j+1]);
  104:                 printf("%s", text+index);
  105:                 */
  106                  error("Bad char");
  107              }
  ...
  191  
  192          for(j = 0; j < streams; ++j){
  193:             //printf("%d\n", j);
  194              if(rand()%10 == 0){
  195:                 //fprintf(stderr, "Reset\n");
  196                  offsets[j] = rand_size_t()%size;
  197                  reset_rnn_state(net, j);
  ...
  247      float *input = calloc(inputs, sizeof(float));
  248  
  249:     /*
  250:        fill_cpu(inputs, 0, input, 1);
  251:        for(i = 0; i < 10; ++i){
  252:        network_predict(net, input);
  253:        }
  254:        fill_cpu(inputs, 0, input, 1);
  255:      */
  256  
  257      for(i = 0; i < len-1; ++i){
  ...
  269          input[c] = 0;
  270          for(j = 32; j < 127; ++j){
  271:             //printf("%d %c %f\n",j, j, out[j]);
  272          }
  273          for(j = 0; j < inputs; ++j){

/Users/anthonybudd/Development/darknet/src/rnn_layer.c:
  145  
  146          l.state -= l.hidden*l.batch;
  147:         /*
  148:            if(i > 0){
  149:            copy_cpu(l.hidden * l.batch, input_layer.output - l.hidden*l.batch, 1, l.state, 1);
  150:            axpy_cpu(l.hidden * l.batch, 1, self_layer.output - l.hidden*l.batch, 1, l.state, 1);
  151:            }else{
  152:            fill_cpu(l.hidden * l.batch, 0, l.state, 1);
  153:            }
  154:          */
  155  
  156          s.input = l.state;
  ...
  263          backward_connected_layer_gpu(self_layer, s);
  264  
  265:         //copy_ongpu(l.hidden*l.batch, self_layer.delta_gpu, 1, input_layer.delta_gpu, 1);
  266          if (i > 0 && l.shortcut) axpy_ongpu(l.hidden*l.batch, 1, self_layer.delta_gpu, 1, self_layer.delta_gpu - l.hidden*l.batch, 1);
  267          s.input = state.input + i*l.inputs*l.batch;

/Users/anthonybudd/Development/darknet/src/rnn_vid.c:
   48              rgbgr_image(im);
   49              image re = resize_image(im, net.w, net.h);
   50:             //show_image(re, "loaded");
   51:             //cvWaitKey(10);
   52              memcpy(input + i*input_size, re.data, input_size*sizeof(float));
   53              free_image(im);
   ..
   65      }
   66  
   67:     //printf("%d %d %d\n", out_im.w, out_im.h, out_im.c);
   68      float_pair p = {0};
   69      p.x = feats;
   70:     p.y = feats + output_size*batch; //+ out_im.w*out_im.h*out_im.c;
   71  
   72      return p;
   ..
  202      char *cfg = argv[3];
  203      char *weights = (argc > 4) ? argv[4] : 0;
  204:     //char *filename = (argc > 5) ? argv[5]: 0;
  205      if(0==strcmp(argv[2], "train")) train_vid_rnn(cfg, weights);
  206      else if(0==strcmp(argv[2], "generate")) generate_vid_rnn(cfg, weights);

/Users/anthonybudd/Development/darknet/src/stb_image.h:
    1: /* stb_image - v2.06 - public domain image loader - http://nothings.org/stb_image.h
    2:                                      no warranty implied; use at your own risk
    3: 
    4:    Do this:
    5:       #define STB_IMAGE_IMPLEMENTATION
    6:    before you include this file in *one* C or C++ file to create the implementation.
    7: 
    8:    // i.e. it should look like this:
    9:    #include ...
   10:    #include ...
   11:    #include ...
   12:    #define STB_IMAGE_IMPLEMENTATION
   13:    #include "stb_image.h"
   14: 
   15:    You can #define STBI_ASSERT(x) before the #include to avoid using assert.h.
   16:    And #define STBI_MALLOC, STBI_REALLOC, and STBI_FREE to avoid using malloc,realloc,free
   17: 
   18: 
   19:    QUICK NOTES:
   20:       Primarily of interest to game developers and other people who can
   21:           avoid problematic images and only need the trivial interface
   22: 
   23:       JPEG baseline & progressive (12 bpc/arithmetic not supported, same as stock IJG lib)
   24:       PNG 1/2/4/8-bit-per-channel (16 bpc not supported)
   25: 
   26:       TGA (not sure what subset, if a subset)
   27:       BMP non-1bpp, non-RLE
   28:       PSD (composited view only, no extra channels)
   29: 
   30:       GIF (*comp always reports as 4-channel)
   31:       HDR (radiance rgbE format)
   32:       PIC (Softimage PIC)
   33:       PNM (PPM and PGM binary only)
   34: 
   35:       - decode from memory or through FILE (define STBI_NO_STDIO to remove code)
   36:       - decode from arbitrary I/O callbacks
   37:       - SIMD acceleration on x86/x64 (SSE2) and ARM (NEON)
   38: 
   39:    Full documentation under "DOCUMENTATION" below.
   40: 
   41: 
   42:    Revision 2.00 release notes:
   43: 
   44:       - Progressive JPEG is now supported.
   45: 
   46:       - PPM and PGM binary formats are now supported, thanks to Ken Miller.
   47: 
   48:       - x86 platforms now make use of SSE2 SIMD instructions for
   49:         JPEG decoding, and ARM platforms can use NEON SIMD if requested.
   50:         This work was done by Fabian "ryg" Giesen. SSE2 is used by
   51:         default, but NEON must be enabled explicitly; see docs.
   52: 
   53:         With other JPEG optimizations included in this version, we see
   54:         2x speedup on a JPEG on an x86 machine, and a 1.5x speedup
   55:         on a JPEG on an ARM machine, relative to previous versions of this
   56:         library. The same results will not obtain for all JPGs and for all
   57:         x86/ARM machines. (Note that progressive JPEGs are significantly
   58:         slower to decode than regular JPEGs.) This doesn't mean that this
   59:         is the fastest JPEG decoder in the land; rather, it brings it
   60:         closer to parity with standard libraries. If you want the fastest
   61:         decode, look elsewhere. (See "Philosophy" section of docs below.)
   62: 
   63:         See final bullet items below for more info on SIMD.
   64: 
   65:       - Added STBI_MALLOC, STBI_REALLOC, and STBI_FREE macros for replacing
   66:         the memory allocator. Unlike other STBI libraries, these macros don't
   67:         support a context parameter, so if you need to pass a context in to
   68:         the allocator, you'll have to store it in a global or a thread-local
   69:         variable.
   70: 
   71:       - Split existing STBI_NO_HDR flag into two flags, STBI_NO_HDR and
   72:         STBI_NO_LINEAR.
   73:             STBI_NO_HDR:     suppress implementation of .hdr reader format
   74:             STBI_NO_LINEAR:  suppress high-dynamic-range light-linear float API
   75: 
   76:       - You can suppress implementation of any of the decoders to reduce
   77:         your code footprint by #defining one or more of the following
   78:         symbols before creating the implementation.
   79: 
   80:             STBI_NO_JPEG
   81:             STBI_NO_PNG
   82:             STBI_NO_BMP
   83:             STBI_NO_PSD
   84:             STBI_NO_TGA
   85:             STBI_NO_GIF
   86:             STBI_NO_HDR
   87:             STBI_NO_PIC
   88:             STBI_NO_PNM   (.ppm and .pgm)
   89: 
   90:       - You can request *only* certain decoders and suppress all other ones
   91:         (this will be more forward-compatible, as addition of new decoders
   92:         doesn't require you to disable them explicitly):
   93: 
   94:             STBI_ONLY_JPEG
   95:             STBI_ONLY_PNG
   96:             STBI_ONLY_BMP
   97:             STBI_ONLY_PSD
   98:             STBI_ONLY_TGA
   99:             STBI_ONLY_GIF
  100:             STBI_ONLY_HDR
  101:             STBI_ONLY_PIC
  102:             STBI_ONLY_PNM   (.ppm and .pgm)
  103: 
  104:          Note that you can define multiples of these, and you will get all
  105:          of them ("only x" and "only y" is interpreted to mean "only x&y").
  106: 
  107:        - If you use STBI_NO_PNG (or _ONLY_ without PNG), and you still
  108:          want the zlib decoder to be available, #define STBI_SUPPORT_ZLIB
  109: 
  110:       - Compilation of all SIMD code can be suppressed with
  111:             #define STBI_NO_SIMD
  112:         It should not be necessary to disable SIMD unless you have issues
  113:         compiling (e.g. using an x86 compiler which doesn't support SSE
  114:         intrinsics or that doesn't support the method used to detect
  115:         SSE2 support at run-time), and even those can be reported as
  116:         bugs so I can refine the built-in compile-time checking to be
  117:         smarter.
  118: 
  119:       - The old STBI_SIMD system which allowed installing a user-defined
  120:         IDCT etc. has been removed. If you need this, don't upgrade. My
  121:         assumption is that almost nobody was doing this, and those who
  122:         were will find the built-in SIMD more satisfactory anyway.
  123: 
  124:       - RGB values computed for JPEG images are slightly different from
  125:         previous versions of stb_image. (This is due to using less
  126:         integer precision in SIMD.) The C code has been adjusted so
  127:         that the same RGB values will be computed regardless of whether
  128:         SIMD support is available, so your app should always produce
  129:         consistent results. But these results are slightly different from
  130:         previous versions. (Specifically, about 3% of available YCbCr values
  131:         will compute different RGB results from pre-1.49 versions by +-1;
  132:         most of the deviating values are one smaller in the G channel.)
  133: 
  134:       - If you must produce consistent results with previous versions of
  135:         stb_image, #define STBI_JPEG_OLD and you will get the same results
  136:         you used to; however, you will not get the SIMD speedups for
  137:         the YCbCr-to-RGB conversion step (although you should still see
  138:         significant JPEG speedup from the other changes).
  139: 
  140:         Please note that STBI_JPEG_OLD is a temporary feature; it will be
  141:         removed in future versions of the library. It is only intended for
  142:         near-term back-compatibility use.
  143: 
  144: 
  145:    Latest revision history:
  146:       2.06  (2015-04-19) fix bug where PSD returns wrong '*comp' value
  147:       2.05  (2015-04-19) fix bug in progressive JPEG handling, fix warning
  148:       2.04  (2015-04-15) try to re-enable SIMD on MinGW 64-bit
  149:       2.03  (2015-04-12) additional corruption checking
  150:                          stbi_set_flip_vertically_on_load
  151:                          fix NEON support; fix mingw support
  152:       2.02  (2015-01-19) fix incorrect assert, fix warning
  153:       2.01  (2015-01-17) fix various warnings
  154:       2.00b (2014-12-25) fix STBI_MALLOC in progressive JPEG
  155:       2.00  (2014-12-25) optimize JPEG, including x86 SSE2 & ARM NEON SIMD
  156:                          progressive JPEG
  157:                          PGM/PPM support
  158:                          STBI_MALLOC,STBI_REALLOC,STBI_FREE
  159:                          STBI_NO_*, STBI_ONLY_*
  160:                          GIF bugfix
  161:       1.48  (2014-12-14) fix incorrectly-named assert()
  162:       1.47  (2014-12-14) 1/2/4-bit PNG support (both grayscale and paletted)
  163:                          optimize PNG
  164:                          fix bug in interlaced PNG with user-specified channel count
  165: 
  166:    See end of file for full revision history.
  167: 
  168: 
  169:  ============================    Contributors    =========================
  170: 
  171:  Image formats                                Bug fixes & warning fixes
  172:     Sean Barrett (jpeg, png, bmp)                Marc LeBlanc
  173:     Nicolas Schulz (hdr, psd)                    Christpher Lloyd
  174:     Jonathan Dummer (tga)                        Dave Moore
  175:     Jean-Marc Lienher (gif)                      Won Chun
  176:     Tom Seddon (pic)                             the Horde3D community
  177:     Thatcher Ulrich (psd)                        Janez Zemva
  178:     Ken Miller (pgm, ppm)                        Jonathan Blow
  179:                                                  Laurent Gomila
  180:                                                  Aruelien Pocheville
  181:  Extensions, features                            Ryamond Barbiero
  182:     Jetro Lauha (stbi_info)                      David Woo
  183:     Martin "SpartanJ" Golini (stbi_info)         Martin Golini
  184:     James "moose2000" Brown (iPhone PNG)         Roy Eltham
  185:     Ben "Disch" Wenger (io callbacks)            Luke Graham
  186:     Omar Cornut (1/2/4-bit PNG)                  Thomas Ruf
  187:     Nicolas Guillemot (vertical flip)            John Bartholomew
  188:                                                  Ken Hamada
  189:  Optimizations & bugfixes                        Cort Stratton
  190:     Fabian "ryg" Giesen                          Blazej Dariusz Roszkowski
  191:     Arseny Kapoulkine                            Thibault Reuille
  192:                                                  Paul Du Bois
  193:                                                  Guillaume George
  194:   If your name should be here but                Jerry Jansson
  195:   isn't, let Sean know.                          Hayaki Saito
  196:                                                  Johan Duparc
  197:                                                  Ronny Chevalier
  198:                                                  Michal Cichon
  199:                                                  Tero Hanninen
  200:                                                  Sergio Gonzalez
  201:                                                  Cass Everitt
  202:                                                  Engin Manap
  203:                                                  Martins Mozeiko
  204:                                                  Joseph Thomson
  205:                                                  Phil Jordan
  206: 
  207: License:
  208:    This software is in the public domain. Where that dedication is not
  209:    recognized, you are granted a perpetual, irrevocable license to copy
  210:    and modify this file however you want.
  211: 
  212: */
  213  
  214  #ifndef STBI_INCLUDE_STB_IMAGE_H
  215  #define STBI_INCLUDE_STB_IMAGE_H
  216  
  217: // DOCUMENTATION
  218: //
  219: // Limitations:
  220: //    - no 16-bit-per-channel PNG
  221: //    - no 12-bit-per-channel JPEG
  222: //    - no JPEGs with arithmetic coding
  223: //    - no 1-bit BMP
  224: //    - GIF always returns *comp=4
  225: //
  226: // Basic usage (see HDR discussion below for HDR usage):
  227: //    int x,y,n;
  228: //    unsigned char *data = stbi_load(filename, &x, &y, &n, 0);
  229: //    // ... process data if not NULL ...
  230: //    // ... x = width, y = height, n = # 8-bit components per pixel ...
  231: //    // ... replace '0' with '1'..'4' to force that many components per pixel
  232: //    // ... but 'n' will always be the number that it would have been if you said 0
  233: //    stbi_image_free(data)
  234: //
  235: // Standard parameters:
  236: //    int *x       -- outputs image width in pixels
  237: //    int *y       -- outputs image height in pixels
  238: //    int *comp    -- outputs # of image components in image file
  239: //    int req_comp -- if non-zero, # of image components requested in result
  240: //
  241: // The return value from an image loader is an 'unsigned char *' which points
  242: // to the pixel data, or NULL on an allocation failure or if the image is
  243: // corrupt or invalid. The pixel data consists of *y scanlines of *x pixels,
  244: // with each pixel consisting of N interleaved 8-bit components; the first
  245: // pixel pointed to is top-left-most in the image. There is no padding between
  246: // image scanlines or between pixels, regardless of format. The number of
  247: // components N is 'req_comp' if req_comp is non-zero, or *comp otherwise.
  248: // If req_comp is non-zero, *comp has the number of components that _would_
  249: // have been output otherwise. E.g. if you set req_comp to 4, you will always
  250: // get RGBA output, but you can check *comp to see if it's trivially opaque
  251: // because e.g. there were only 3 channels in the source image.
  252: //
  253: // An output image with N components has the following components interleaved
  254: // in this order in each pixel:
  255: //
  256: //     N=#comp     components
  257: //       1           grey
  258: //       2           grey, alpha
  259: //       3           red, green, blue
  260: //       4           red, green, blue, alpha
  261: //
  262: // If image loading fails for any reason, the return value will be NULL,
  263: // and *x, *y, *comp will be unchanged. The function stbi_failure_reason()
  264: // can be queried for an extremely brief, end-user unfriendly explanation
  265: // of why the load failed. Define STBI_NO_FAILURE_STRINGS to avoid
  266: // compiling these strings at all, and STBI_FAILURE_USERMSG to get slightly
  267: // more user-friendly ones.
  268: //
  269: // Paletted PNG, BMP, GIF, and PIC images are automatically depalettized.
  270: //
  271: // ===========================================================================
  272: //
  273: // Philosophy
  274: //
  275: // stb libraries are designed with the following priorities:
  276: //
  277: //    1. easy to use
  278: //    2. easy to maintain
  279: //    3. good performance
  280: //
  281: // Sometimes I let "good performance" creep up in priority over "easy to maintain",
  282: // and for best performance I may provide less-easy-to-use APIs that give higher
  283: // performance, in addition to the easy to use ones. Nevertheless, it's important
  284: // to keep in mind that from the standpoint of you, a client of this library,
  285: // all you care about is #1 and #3, and stb libraries do not emphasize #3 above all.
  286: //
  287: // Some secondary priorities arise directly from the first two, some of which
  288: // make more explicit reasons why performance can't be emphasized.
  289: //
  290: //    - Portable ("ease of use")
  291: //    - Small footprint ("easy to maintain")
  292: //    - No dependencies ("ease of use")
  293: //
  294: // ===========================================================================
  295: //
  296: // I/O callbacks
  297: //
  298: // I/O callbacks allow you to read from arbitrary sources, like packaged
  299: // files or some other source. Data read from callbacks are processed
  300: // through a small internal buffer (currently 128 bytes) to try to reduce
  301: // overhead.
  302: //
  303: // The three functions you must define are "read" (reads some bytes of data),
  304: // "skip" (skips some bytes of data), "eof" (reports if the stream is at the end).
  305: //
  306: // ===========================================================================
  307: //
  308: // SIMD support
  309: //
  310: // The JPEG decoder will try to automatically use SIMD kernels on x86 when
  311: // supported by the compiler. For ARM Neon support, you must explicitly
  312: // request it.
  313: //
  314: // (The old do-it-yourself SIMD API is no longer supported in the current
  315: // code.)
  316: //
  317: // On x86, SSE2 will automatically be used when available based on a run-time
  318: // test; if not, the generic C versions are used as a fall-back. On ARM targets,
  319: // the typical path is to have separate builds for NEON and non-NEON devices
  320: // (at least this is true for iOS and Android). Therefore, the NEON support is
  321: // toggled by a build flag: define STBI_NEON to get NEON loops.
  322: //
  323: // The output of the JPEG decoder is slightly different from versions where
  324: // SIMD support was introduced (that is, for versions before 1.49). The
  325: // difference is only +-1 in the 8-bit RGB channels, and only on a small
  326: // fraction of pixels. You can force the pre-1.49 behavior by defining
  327: // STBI_JPEG_OLD, but this will disable some of the SIMD decoding path
  328: // and hence cost some performance.
  329: //
  330: // If for some reason you do not want to use any of SIMD code, or if
  331: // you have issues compiling it, you can disable it entirely by
  332: // defining STBI_NO_SIMD.
  333: //
  334: // ===========================================================================
  335: //
  336: // HDR image support   (disable by defining STBI_NO_HDR)
  337: //
  338: // stb_image now supports loading HDR images in general, and currently
  339: // the Radiance .HDR file format, although the support is provided
  340: // generically. You can still load any file through the existing interface;
  341: // if you attempt to load an HDR file, it will be automatically remapped to
  342: // LDR, assuming gamma 2.2 and an arbitrary scale factor defaulting to 1;
  343: // both of these constants can be reconfigured through this interface:
  344: //
  345: //     stbi_hdr_to_ldr_gamma(2.2f);
  346: //     stbi_hdr_to_ldr_scale(1.0f);
  347: //
  348: // (note, do not use _inverse_ constants; stbi_image will invert them
  349: // appropriately).
  350: //
  351: // Additionally, there is a new, parallel interface for loading files as
  352: // (linear) floats to preserve the full dynamic range:
  353: //
  354: //    float *data = stbi_loadf(filename, &x, &y, &n, 0);
  355: //
  356: // If you load LDR images through this interface, those images will
  357: // be promoted to floating point values, run through the inverse of
  358: // constants corresponding to the above:
  359: //
  360: //     stbi_ldr_to_hdr_scale(1.0f);
  361: //     stbi_ldr_to_hdr_gamma(2.2f);
  362: //
  363: // Finally, given a filename (or an open file or memory block--see header
  364: // file for details) containing image data, you can query for the "most
  365: // appropriate" interface to use (that is, whether the image is HDR or
  366: // not), using:
  367: //
  368: //     stbi_is_hdr(char *filename);
  369: //
  370: // ===========================================================================
  371: //
  372: // iPhone PNG support:
  373: //
  374: // By default we convert iphone-formatted PNGs back to RGB, even though
  375: // they are internally encoded differently. You can disable this conversion
  376: // by by calling stbi_convert_iphone_png_to_rgb(0), in which case
  377: // you will always just get the native iphone "format" through (which
  378: // is BGR stored in RGB).
  379: //
  380: // Call stbi_set_unpremultiply_on_load(1) as well to force a divide per
  381: // pixel to remove any premultiplied alpha *only* if the image file explicitly
  382: // says there's premultiplied data (currently only happens in iPhone images,
  383: // and only if iPhone convert-to-rgb processing is on).
  384: //
  385  
  386  
  387  #ifndef STBI_NO_STDIO
  388  #include <stdio.h>
  389: #endif // STBI_NO_STDIO
  390  
  391  #define STBI_VERSION 1
  ...
  393  enum
  394  {
  395:    STBI_default = 0, // only used for req_comp
  396  
  397     STBI_grey       = 1,
  ...
  413  #endif
  414  
  415: //////////////////////////////////////////////////////////////////////////////
  416: //
  417: // PRIMARY API - works on images of any type
  418: //
  419  
  420: //
  421: // load image by filename, open file, or memory buffer
  422: //
  423  
  424  typedef struct
  425  {
  426:    int      (*read)  (void *user,char *data,int size);   // fill 'data' with 'size' bytes.  return number of bytes actually read
  427:    void     (*skip)  (void *user,int n);                 // skip the next 'n' bytes, or 'unget' the last -n bytes if negative
  428:    int      (*eof)   (void *user);                       // returns nonzero if we are at end of file/data
  429  } stbi_io_callbacks;
  430  
  ...
  435  #ifndef STBI_NO_STDIO
  436  STBIDEF stbi_uc *stbi_load_from_file  (FILE *f,                  int *x, int *y, int *comp, int req_comp);
  437: // for stbi_load_from_file, file pointer is left pointing immediately after image
  438  #endif
  439  
  ...
  456     STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma);
  457     STBIDEF void   stbi_ldr_to_hdr_scale(float scale);
  458: #endif // STBI_NO_HDR
  459  
  460: // stbi_is_hdr is always defined, but always returns false if STBI_NO_HDR
  461  STBIDEF int    stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user);
  462  STBIDEF int    stbi_is_hdr_from_memory(stbi_uc const *buffer, int len);
  ...
  464  STBIDEF int      stbi_is_hdr          (char const *filename);
  465  STBIDEF int      stbi_is_hdr_from_file(FILE *f);
  466: #endif // STBI_NO_STDIO
  467  
  468  
  469: // get a VERY brief reason for failure
  470: // NOT THREADSAFE
  471  STBIDEF const char *stbi_failure_reason  (void);
  472  
  473: // free the loaded image -- this is just free()
  474  STBIDEF void     stbi_image_free      (void *retval_from_stbi_load);
  475  
  476: // get image dimensions & components without fully decoding
  477  STBIDEF int      stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp);
  478  STBIDEF int      stbi_info_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp);
  ...
  486  
  487  
  488: // for image formats that explicitly notate that they have premultiplied alpha,
  489: // we just return the colors as stored in the file. set this flag to force
  490: // unpremultiplication. results are undefined if the unpremultiply overflow.
  491  STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply);
  492  
  493: // indicate whether we should process iphone images back to canonical format,
  494: // or just pass them through "as-is"
  495  STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert);
  496  
  497: // flip the image vertically, so the first pixel in the output array is the bottom left
  498  STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip);
  499  
  500: // ZLIB client - used by PNG, available for other purposes
  501  
  502  STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen);
  ...
  513  #endif
  514  
  515: //
  516: //
  517: ////   end header file   /////////////////////////////////////////////////////
  518: #endif // STBI_INCLUDE_STB_IMAGE_H
  519  
  520  #ifdef STB_IMAGE_IMPLEMENTATION
  ...
  559  
  560  #include <stdarg.h>
  561: #include <stddef.h> // ptrdiff_t on osx
  562  #include <stdlib.h>
  563  #include <string.h>
  564  
  565  #if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR)
  566: #include <math.h>  // ldexp
  567  #endif
  568  
  ...
  601  #endif
  602  
  603: // should produce compiler error if size is wrong
  604  typedef unsigned char validate_uint32[sizeof(stbi__uint32)==4 ? 1 : -1];
  605  
  ...
  621  
  622  #if defined(STBI_MALLOC) && defined(STBI_FREE) && defined(STBI_REALLOC)
  623: // ok
  624  #elif !defined(STBI_MALLOC) && !defined(STBI_FREE) && !defined(STBI_REALLOC)
  625: // ok
  626  #else
  627  #error "Must define all or none of STBI_MALLOC, STBI_FREE, and STBI_REALLOC."
  ...
  634  #endif
  635  
  636: // x86/x64 detection
  637  #if defined(__x86_64__) || defined(_M_X64)
  638  #define STBI__X64_TARGET
  ...
  642  
  643  #if defined(__GNUC__) && (defined(STBI__X86_TARGET) || defined(STBI__X64_TARGET)) && !defined(__SSE2__) && !defined(STBI_NO_SIMD)
  644: // NOTE: not clear do we actually need this for the 64-bit path?
  645: // gcc doesn't support sse2 intrinsics unless you compile with -msse2,
  646: // (but compiling with -msse2 allows the compiler to use SSE2 everywhere;
  647: // this is just broken and gcc are jerks for not fixing it properly
  648: // http://www.virtualdub.org/blog/pivot/entry.php?id=363 )
  649  #define STBI_NO_SIMD
  650  #endif
  651  
  652  #if defined(__MINGW32__) && defined(STBI__X86_TARGET) && !defined(STBI_MINGW_ENABLE_SSE2) && !defined(STBI_NO_SIMD)
  653: // Note that __MINGW32__ doesn't actually mean 32-bit, so we have to avoid STBI__X64_TARGET
  654: //
  655: // 32-bit MinGW wants ESP to be 16-byte aligned, but this is not in the
  656: // Windows ABI and VC++ as well as Windows DLLs don't maintain that invariant.
  657: // As a result, enabling SSE2 on 32-bit MinGW is dangerous when not
  658: // simultaneously enabling "-mstackrealign".
  659: //
  660: // See https://github.com/nothings/stb/issues/81 for more information.
  661: //
  662: // So default to no SSE2 on 32-bit MinGW. If you've read this far and added
  663: // -mstackrealign to your build settings, feel free to #define STBI_MINGW_ENABLE_SSE2.
  664  #define STBI_NO_SIMD
  665  #endif
  ...
  671  #ifdef _MSC_VER
  672  
  673: #if _MSC_VER >= 1400  // not VC6
  674: #include <intrin.h> // __cpuid
  675  static int stbi__cpuid3(void)
  676  {
  ...
  699     return ((info3 >> 26) & 1) != 0;
  700  }
  701: #else // assume GCC-style if not VC++
  702  #define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))
  703  
  704  static int stbi__sse2_available()
  705  {
  706: #if defined(__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__) >= 408 // GCC 4.8 or later
  707:    // GCC 4.8+ has a nice way to do this
  708     return __builtin_cpu_supports("sse2");
  709  #else
  710:    // portable way to do this, preferably without using GCC inline ASM?
  711:    // just bail for now.
  712     return 0;
  713  #endif
  ...
  716  #endif
  717  
  718: // ARM NEON
  719  #if defined(STBI_NO_SIMD) && defined(STBI_NEON)
  720  #undef STBI_NEON
  ...
  723  #ifdef STBI_NEON
  724  #include <arm_neon.h>
  725: // assume GCC or Clang on ARM targets
  726  #define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))
  727  #endif
  ...
  731  #endif
  732  
  733: ///////////////////////////////////////////////
  734: //
  735: //  stbi__context struct and start_xxx functions
  736  
  737: // stbi__context structure is our basic context used by all images, so it
  738: // contains all the IO context, plus some basic image information
  739  typedef struct
  740  {
  ...
  756  static void stbi__refill_buffer(stbi__context *s);
  757  
  758: // initialize a memory-decode context
  759  static void stbi__start_mem(stbi__context *s, stbi_uc const *buffer, int len)
  760  {
  ...
  765  }
  766  
  767: // initialize a callback-based context
  768  static void stbi__start_callbacks(stbi__context *s, stbi_io_callbacks *c, void *user)
  769  {
  ...
  805  }
  806  
  807: //static void stop_file(stbi__context *s) { }
  808  
  809: #endif // !STBI_NO_STDIO
  810  
  811  static void stbi__rewind(stbi__context *s)
  812  {
  813:    // conceptually rewind SHOULD rewind to the beginning of the stream,
  814:    // but we just rewind to the beginning of the initial buffer, because
  815:    // we only use it after doing 'test', which only ever looks at at most 92 bytes
  816     s->img_buffer = s->img_buffer_original;
  817  }
  ...
  871  #endif
  872  
  873: // this is not threadsafe
  874  static const char *stbi__g_failure_reason;
  875  
  ...
  890  }
  891  
  892: // stbi__err - error
  893: // stbi__errpf - error returning pointer to float
  894: // stbi__errpuc - error returning pointer to unsigned char
  895  
  896  #ifdef STBI_NO_FAILURE_STRINGS
  ...
  957  
  958     #ifndef STBI_NO_TGA
  959:    // test tga last because it's a crappy test!
  960     if (stbi__tga_test(s))
  961        return stbi__tga_load(s,x,y,comp,req_comp);
  ...
  975        stbi_uc temp;
  976  
  977:       // @OPTIMIZE: use a bigger temp buffer and memcpy multiple pixels at once
  978        for (row = 0; row < (h>>1); row++) {
  979           for (col = 0; col < w; col++) {
  ...
  998        float temp;
  999  
 1000:       // @OPTIMIZE: use a bigger temp buffer and memcpy multiple pixels at once
 1001        for (row = 0; row < (h>>1); row++) {
 1002           for (col = 0; col < w; col++) {
 ....
 1044     result = stbi__load_flip(&s,x,y,comp,req_comp);
 1045     if (result) {
 1046:       // need to 'unget' all the characters in the IO buffer
 1047        fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
 1048     }
 1049     return result;
 1050  }
 1051: #endif //!STBI_NO_STDIO
 1052  
 1053  STBIDEF stbi_uc *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
 ....
 1114     return stbi__loadf_main(&s,x,y,comp,req_comp);
 1115  }
 1116: #endif // !STBI_NO_STDIO
 1117  
 1118: #endif // !STBI_NO_LINEAR
 1119  
 1120: // these is-hdr-or-not is defined independent of whether STBI_NO_LINEAR is
 1121: // defined, for API simplicity; if STBI_NO_LINEAR is defined, it always
 1122: // reports false!
 1123  
 1124  STBIDEF int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)
 ....
 1157     #endif
 1158  }
 1159: #endif // !STBI_NO_STDIO
 1160  
 1161  STBIDEF int      stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user)
 ....
 1182  
 1183  
 1184: //////////////////////////////////////////////////////////////////////////////
 1185: //
 1186: // Common code used by all image loaders
 1187: //
 1188  
 1189  enum
 ....
 1198     int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);
 1199     if (n == 0) {
 1200:       // at end of file, treat same as if from memory, but need to handle case
 1201:       // where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file
 1202        s->read_from_callbacks = 0;
 1203        s->img_buffer = s->buffer_start;
 ....
 1225     if (s->io.read) {
 1226        if (!(s->io.eof)(s->io_user_data)) return 0;
 1227:       // if feof() is true, check if buffer = end
 1228:       // special case: we've only got the special 0 character at the end
 1229        if (s->read_from_callbacks == 0) return 1;
 1230     }
 ....
 1298  }
 1299  
 1300: #define STBI__BYTECAST(x)  ((stbi_uc) ((x) & 255))  // truncate int to byte without warnings
 1301  
 1302  
 1303: //////////////////////////////////////////////////////////////////////////////
 1304: //
 1305: //  generic converter from built-in img_n to req_comp
 1306: //    individual types do this automatically as much as possible (e.g. jpeg
 1307: //    does all cases internally since it needs to colorspace convert anyway,
 1308: //    and it never has alpha, so very few cases ). png can automatically
 1309: //    interleave an alpha=255 channel, but falls back to this for other cases
 1310: //
 1311: //  assume data buffer is malloced, so malloc a new one and free that one
 1312: //  only failure mode is malloc failing
 1313  
 1314  static stbi_uc stbi__compute_y(int r, int g, int b)
 ....
 1337        #define COMBO(a,b)  ((a)*8+(b))
 1338        #define CASE(a,b)   case COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
 1339:       // convert source image with img_n components to one with req_comp components;
 1340:       // avoid switch per pixel, so use switch per scanline and massive macros
 1341        switch (COMBO(img_n, req_comp)) {
 1342           CASE(1,2) dest[0]=src[0], dest[1]=255; break;
 ....
 1367     float *output = (float *) stbi__malloc(x * y * comp * sizeof(float));
 1368     if (output == NULL) { STBI_FREE(data); return stbi__errpf("outofmem", "Out of memory"); }
 1369:    // compute number of non-alpha components
 1370     if (comp & 1) n = comp; else n = comp-1;
 1371     for (i=0; i < x*y; ++i) {
 ....
 1387     stbi_uc *output = (stbi_uc *) stbi__malloc(x * y * comp);
 1388     if (output == NULL) { STBI_FREE(data); return stbi__errpuc("outofmem", "Out of memory"); }
 1389:    // compute number of non-alpha components
 1390     if (comp & 1) n = comp; else n = comp-1;
 1391     for (i=0; i < x*y; ++i) {
 ....
 1408  #endif
 1409  
 1410: //////////////////////////////////////////////////////////////////////////////
 1411: //
 1412: //  "baseline" JPEG/JFIF decoder
 1413: //
 1414: //    simple implementation
 1415: //      - doesn't support delayed output of y-dimension
 1416: //      - simple interface (only one output format: 8-bit interleaved RGB)
 1417: //      - doesn't try to recover corrupt jpegs
 1418: //      - doesn't allow partial loading, loading multiple at once
 1419: //      - still fast on x86 (copying globals into locals doesn't help x86)
 1420: //      - allocates lots of intermediate memory (full size of all components)
 1421: //        - non-interleaved case requires this anyway
 1422: //        - allows good upsampling (see next)
 1423: //    high-quality
 1424: //      - upsampled channels are bilinearly interpolated, even across blocks
 1425: //      - quality integer IDCT derived from IJG's 'slow'
 1426: //    performance
 1427: //      - fast huffman; reasonable integer IDCT
 1428: //      - some SIMD kernels for common paths on targets with SSE2/NEON
 1429: //      - uses a lot of intermediate memory, could cache poorly
 1430  
 1431  #ifndef STBI_NO_JPEG
 1432  
 1433: // huffman decoding acceleration
 1434: #define FAST_BITS   9  // larger handles more cases; smaller stomps less cache
 1435  
 1436  typedef struct
 1437  {
 1438     stbi_uc  fast[1 << FAST_BITS];
 1439:    // weirdly, repacking this into AoS is a 10% speed loss, instead of a win
 1440     stbi__uint16 code[256];
 1441     stbi_uc  values[256];
 1442     stbi_uc  size[257];
 1443     unsigned int maxcode[18];
 1444:    int    delta[17];   // old 'firstsymbol' - old 'firstcode'
 1445  } stbi__huffman;
 1446  
 ....
 1453     stbi__int16 fast_ac[4][1 << FAST_BITS];
 1454  
 1455: // sizes for components, interleaved MCUs
 1456     int img_h_max, img_v_max;
 1457     int img_mcu_x, img_mcu_y;
 1458     int img_mcu_w, img_mcu_h;
 1459  
 1460: // definition of jpeg image component
 1461     struct
 1462     {
 ....
 1471        void *raw_data, *raw_coeff;
 1472        stbi_uc *linebuf;
 1473:       short   *coeff;   // progressive only
 1474:       int      coeff_w, coeff_h; // number of 8x8 coefficient blocks
 1475     } img_comp[4];
 1476  
 1477:    stbi__uint32   code_buffer; // jpeg entropy-coded buffer
 1478:    int            code_bits;   // number of valid bits
 1479:    unsigned char  marker;      // marker seen while filling entropy buffer
 1480:    int            nomore;      // flag if we saw a marker so must stop
 1481  
 1482     int            progressive;
 ....
 1490     int restart_interval, todo;
 1491  
 1492: // kernels
 1493     void (*idct_block_kernel)(stbi_uc *out, int out_stride, short data[64]);
 1494     void (*YCbCr_to_RGB_kernel)(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step);
 ....
 1499  {
 1500     int i,j,k=0,code;
 1501:    // build size list for each symbol (from JPEG spec)
 1502     for (i=0; i < 16; ++i)
 1503        for (j=0; j < count[i]; ++j)
 ....
 1505     h->size[k] = 0;
 1506  
 1507:    // compute actual symbols (from jpeg spec)
 1508     code = 0;
 1509     k = 0;
 1510     for(j=1; j <= 16; ++j) {
 1511:       // compute delta to add to code to compute symbol id
 1512        h->delta[j] = k - code;
 1513        if (h->size[k] == j) {
 ....
 1516           if (code-1 >= (1 << j)) return stbi__err("bad code lengths","Corrupt JPEG");
 1517        }
 1518:       // compute largest code + 1 for this size, preshifted as needed later
 1519        h->maxcode[j] = code << (16-j);
 1520        code <<= 1;
 ....
 1522     h->maxcode[j] = 0xffffffff;
 1523  
 1524:    // build non-spec acceleration table; 255 is flag for not-accelerated
 1525     memset(h->fast, 255, 1 << FAST_BITS);
 1526     for (i=0; i < k; ++i) {
 ....
 1537  }
 1538  
 1539: // build a table that decodes both magnitude and value of small ACs in
 1540: // one go.
 1541  static void stbi__build_fast_ac(stbi__int16 *fast_ac, stbi__huffman *h)
 1542  {
 ....
 1552  
 1553           if (magbits && len + magbits <= FAST_BITS) {
 1554:             // magnitude code followed by receive_extend code
 1555              int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);
 1556              int m = 1 << (magbits - 1);
 1557              if (k < m) k += (-1 << magbits) + 1;
 1558:             // if the result is small enough, we can fit it in fast_ac table
 1559              if (k >= -128 && k <= 127)
 1560                 fast_ac[i] = (stbi__int16) ((k << 8) + (run << 4) + (len + magbits));
 ....
 1581  }
 1582  
 1583: // (1 << n) - 1
 1584  static stbi__uint32 stbi__bmask[17]={0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535};
 1585  
 1586: // decode a jpeg huffman value from the bitstream
 1587  stbi_inline static int stbi__jpeg_huff_decode(stbi__jpeg *j, stbi__huffman *h)
 1588  {
 ....
 1592     if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
 1593  
 1594:    // look at the top FAST_BITS and determine what symbol ID it is,
 1595:    // if the code is <= FAST_BITS
 1596     c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
 1597     k = h->fast[c];
 ....
 1605     }
 1606  
 1607:    // naive test is to shift the code_buffer down so k bits are
 1608:    // valid, then test against maxcode. To speed this up, we've
 1609:    // preshifted maxcode left so that it has (16-k) 0s at the
 1610:    // end; in other words, regardless of the number of bits, it
 1611:    // wants to be compared against something shifted to have 16;
 1612:    // that way we don't need to shift inside the loop.
 1613     temp = j->code_buffer >> 16;
 1614     for (k=FAST_BITS+1 ; ; ++k)
 ....
 1616           break;
 1617     if (k == 17) {
 1618:       // error! code not found
 1619        j->code_bits -= 16;
 1620        return -1;
 ....
 1624        return -1;
 1625  
 1626:    // convert the huffman code to the symbol id
 1627     c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];
 1628     STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);
 1629  
 1630:    // convert the id to a symbol
 1631     j->code_bits -= k;
 1632     j->code_buffer <<= k;
 ....
 1634  }
 1635  
 1636: // bias[n] = (-1<<n) + 1
 1637  static int const stbi__jbias[16] = {0,-1,-3,-7,-15,-31,-63,-127,-255,-511,-1023,-2047,-4095,-8191,-16383,-32767};
 1638  
 1639: // combined JPEG 'receive' and JPEG 'extend', since baseline
 1640: // always extends everything it receives.
 1641  stbi_inline static int stbi__extend_receive(stbi__jpeg *j, int n)
 1642  {
 ....
 1645     if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
 1646  
 1647:    sgn = (stbi__int32)j->code_buffer >> 31; // sign bit is always in MSB
 1648     k = stbi_lrot(j->code_buffer, n);
 1649     STBI_ASSERT(n >= 0 && n < (int) (sizeof(stbi__bmask)/sizeof(*stbi__bmask)));
 ....
 1654  }
 1655  
 1656: // get some unsigned bits
 1657  stbi_inline static int stbi__jpeg_get_bits(stbi__jpeg *j, int n)
 1658  {
 ....
 1676  }
 1677  
 1678: // given a value that's at position X in the zigzag stream,
 1679: // where does it appear in the 8x8 matrix coded as row-major?
 1680  static stbi_uc stbi__jpeg_dezigzag[64+15] =
 1681  {
 ....
 1688     58, 59, 52, 45, 38, 31, 39, 46,
 1689     53, 60, 61, 54, 47, 55, 62, 63,
 1690:    // let corrupt input sample past end
 1691     63, 63, 63, 63, 63, 63, 63, 63,
 1692     63, 63, 63, 63, 63, 63, 63
 1693  };
 1694  
 1695: // decode one 64-entry block--
 1696  static int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi_uc *dequant)
 1697  {
 ....
 1703     if (t < 0) return stbi__err("bad huffman code","Corrupt JPEG");
 1704  
 1705:    // 0 all the ac values now so we can do it 32-bits at a time
 1706     memset(data,0,64*sizeof(data[0]));
 1707  
 ....
 1711     data[0] = (short) (dc * dequant[0]);
 1712  
 1713:    // decode AC components, see JPEG spec
 1714     k = 1;
 1715     do {
 ....
 1719        c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
 1720        r = fac[c];
 1721:       if (r) { // fast-AC path
 1722:          k += (r >> 4) & 15; // run
 1723:          s = r & 15; // combined length
 1724           j->code_buffer <<= s;
 1725           j->code_bits -= s;
 1726:          // decode into unzigzag'd location
 1727           zig = stbi__jpeg_dezigzag[k++];
 1728           data[zig] = (short) ((r >> 8) * dequant[zig]);
 ....
 1733           r = rs >> 4;
 1734           if (s == 0) {
 1735:             if (rs != 0xf0) break; // end block
 1736              k += 16;
 1737           } else {
 1738              k += r;
 1739:             // decode into unzigzag'd location
 1740              zig = stbi__jpeg_dezigzag[k++];
 1741              data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);
 ....
 1755  
 1756     if (j->succ_high == 0) {
 1757:       // first scan for DC coefficient, must be first
 1758:       memset(data,0,64*sizeof(data[0])); // 0 all the ac values now
 1759        t = stbi__jpeg_huff_decode(j, hdc);
 1760        diff = t ? stbi__extend_receive(j, t) : 0;
 ....
 1764        data[0] = (short) (dc << j->succ_low);
 1765     } else {
 1766:       // refinement scan for DC coefficient
 1767        if (stbi__jpeg_get_bit(j))
 1768           data[0] += (short) (1 << j->succ_low);
 ....
 1771  }
 1772  
 1773: // @OPTIMIZE: store non-zigzagged during the decode passes,
 1774: // and only de-zigzag when dequantizing
 1775  static int stbi__jpeg_decode_block_prog_ac(stbi__jpeg *j, short data[64], stbi__huffman *hac, stbi__int16 *fac)
 1776  {
 ....
 1793           c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
 1794           r = fac[c];
 1795:          if (r) { // fast-AC path
 1796:             k += (r >> 4) & 15; // run
 1797:             s = r & 15; // combined length
 1798              j->code_buffer <<= s;
 1799              j->code_bits -= s;
 ....
 1822        } while (k <= j->spec_end);
 1823     } else {
 1824:       // refinement scan for these AC coefficients
 1825  
 1826        short bit = (short) (1 << j->succ_low);
 ....
 1843           do {
 1844              int r,s;
 1845:             int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh
 1846              if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
 1847              s = rs & 15;
 ....
 1852                    if (r)
 1853                       j->eob_run += stbi__jpeg_get_bits(j, r);
 1854:                   r = 64; // force end of block
 1855                 } else {
 1856:                   // r=15 s=0 should write 16 0s, so we just do
 1857:                   // a run of 15 0s and then write s (which is 0),
 1858:                   // so we don't have to do anything special here
 1859                 }
 1860              } else {
 1861                 if (s != 1) return stbi__err("bad huffman code", "Corrupt JPEG");
 1862:                // sign bit
 1863                 if (stbi__jpeg_get_bit(j))
 1864                    s = bit;
 ....
 1867              }
 1868  
 1869:             // advance by r
 1870              while (k <= j->spec_end) {
 1871                 short *p = &data[stbi__jpeg_dezigzag[k++]];
 ....
 1892  }
 1893  
 1894: // take a -128..127 value and stbi__clamp it and convert to 0..255
 1895  stbi_inline static stbi_uc stbi__clamp(int x)
 1896  {
 1897:    // trick to use a single test to catch both cases
 1898     if ((unsigned int) x > 255) {
 1899        if (x < 0) return 0;
 ....
 1906  #define stbi__fsh(x)  ((x) << 12)
 1907  
 1908: // derived from jidctint -- DCT_ISLOW
 1909  #define STBI__IDCT_1D(s0,s1,s2,s3,s4,s5,s6,s7) \
 1910     int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; \
 ....
 1950     short *d = data;
 1951  
 1952:    // columns
 1953     for (i=0; i < 8; ++i,++d, ++v) {
 1954:       // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
 1955        if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
 1956             && d[40]==0 && d[48]==0 && d[56]==0) {
 1957:          //    no shortcut                 0     seconds
 1958:          //    (1|2|3|4|5|6|7)==0          0     seconds
 1959:          //    all separate               -0.047 seconds
 1960:          //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
 1961           int dcterm = d[0] << 2;
 1962           v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;
 1963        } else {
 1964           STBI__IDCT_1D(d[ 0],d[ 8],d[16],d[24],d[32],d[40],d[48],d[56])
 1965:          // constants scaled things up by 1<<12; let's bring them back
 1966:          // down, but keep 2 extra bits of precision
 1967           x0 += 512; x1 += 512; x2 += 512; x3 += 512;
 1968           v[ 0] = (x0+t3) >> 10;
 ....
 1978  
 1979     for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {
 1980:       // no fast case since the first 1D IDCT spread components out
 1981        STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])
 1982:       // constants scaled things up by 1<<12, plus we had 1<<2 from first
 1983:       // loop, plus horizontal and vertical each scale by sqrt(8) so together
 1984:       // we've got an extra 1<<3, so 1<<17 total we need to remove.
 1985:       // so we want to round that, which means adding 0.5 * 1<<17,
 1986:       // aka 65536. Also, we'll end up with -128 to 127 that we want
 1987:       // to encode as 0..255 by adding 128, so we'll add that before the shift
 1988        x0 += 65536 + (128<<17);
 1989        x1 += 65536 + (128<<17);
 1990        x2 += 65536 + (128<<17);
 1991        x3 += 65536 + (128<<17);
 1992:       // tried computing the shifts into temps, or'ing the temps to see
 1993:       // if any were out of range, but that was slower
 1994        o[0] = stbi__clamp((x0+t3) >> 17);
 1995        o[7] = stbi__clamp((x0-t3) >> 17);
 ....
 2004  
 2005  #ifdef STBI_SSE2
 2006: // sse2 integer IDCT. not the fastest possible implementation but it
 2007: // produces bit-identical results to the generic C version so it's
 2008: // fully "transparent".
 2009  static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
 2010  {
 2011:    // This is constructed to match our regular (generic) integer IDCT exactly.
 2012     __m128i row0, row1, row2, row3, row4, row5, row6, row7;
 2013     __m128i tmp;
 2014  
 2015:    // dot product constant: even elems=x, odd elems=y
 2016     #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))
 2017  
 2018:    // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)
 2019:    // out(1) = c1[even]*x + c1[odd]*y
 2020     #define dct_rot(out0,out1, x,y,c0,c1) \
 2021        __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \
 ....
 2026        __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)
 2027  
 2028:    // out = in << 12  (in 16-bit, out 32-bit)
 2029     #define dct_widen(out, in) \
 2030        __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \
 2031        __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)
 2032  
 2033:    // wide add
 2034     #define dct_wadd(out, a, b) \
 2035        __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \
 2036        __m128i out##_h = _mm_add_epi32(a##_h, b##_h)
 2037  
 2038:    // wide sub
 2039     #define dct_wsub(out, a, b) \
 2040        __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \
 2041        __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)
 2042  
 2043:    // butterfly a/b, add bias, then shift by "s" and pack
 2044     #define dct_bfly32o(out0, out1, a,b,bias,s) \
 2045        { \
 ....
 2052        }
 2053  
 2054:    // 8-bit interleave step (for transposes)
 2055     #define dct_interleave8(a, b) \
 2056        tmp = a; \
 ....
 2058        b = _mm_unpackhi_epi8(tmp, b)
 2059  
 2060:    // 16-bit interleave step (for transposes)
 2061     #define dct_interleave16(a, b) \
 2062        tmp = a; \
 ....
 2066     #define dct_pass(bias,shift) \
 2067        { \
 2068:          /* even part */ \
 2069           dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \
 2070           __m128i sum04 = _mm_add_epi16(row0, row4); \
 ....
 2076           dct_wadd(x1, t1e, t2e); \
 2077           dct_wsub(x2, t1e, t2e); \
 2078:          /* odd part */ \
 2079           dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \
 2080           dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \
 ....
 2101     __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f( 1.501321110f));
 2102  
 2103:    // rounding biases in column/row passes, see stbi__idct_block for explanation.
 2104     __m128i bias_0 = _mm_set1_epi32(512);
 2105     __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));
 2106  
 2107:    // load
 2108     row0 = _mm_load_si128((const __m128i *) (data + 0*8));
 2109     row1 = _mm_load_si128((const __m128i *) (data + 1*8));
 ....
 2115     row7 = _mm_load_si128((const __m128i *) (data + 7*8));
 2116  
 2117:    // column pass
 2118     dct_pass(bias_0, 10);
 2119  
 2120     {
 2121:       // 16bit 8x8 transpose pass 1
 2122        dct_interleave16(row0, row4);
 2123        dct_interleave16(row1, row5);
 ....
 2125        dct_interleave16(row3, row7);
 2126  
 2127:       // transpose pass 2
 2128        dct_interleave16(row0, row2);
 2129        dct_interleave16(row1, row3);
 ....
 2131        dct_interleave16(row5, row7);
 2132  
 2133:       // transpose pass 3
 2134        dct_interleave16(row0, row1);
 2135        dct_interleave16(row2, row3);
 ....
 2138     }
 2139  
 2140:    // row pass
 2141     dct_pass(bias_1, 17);
 2142  
 2143     {
 2144:       // pack
 2145:       __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7
 2146        __m128i p1 = _mm_packus_epi16(row2, row3);
 2147        __m128i p2 = _mm_packus_epi16(row4, row5);
 2148        __m128i p3 = _mm_packus_epi16(row6, row7);
 2149  
 2150:       // 8bit 8x8 transpose pass 1
 2151:       dct_interleave8(p0, p2); // a0e0a1e1...
 2152:       dct_interleave8(p1, p3); // c0g0c1g1...
 2153  
 2154:       // transpose pass 2
 2155:       dct_interleave8(p0, p1); // a0c0e0g0...
 2156:       dct_interleave8(p2, p3); // b0d0f0h0...
 2157  
 2158:       // transpose pass 3
 2159:       dct_interleave8(p0, p2); // a0b0c0d0...
 2160:       dct_interleave8(p1, p3); // a4b4c4d4...
 2161  
 2162:       // store
 2163        _mm_storel_epi64((__m128i *) out, p0); out += out_stride;
 2164        _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;
 ....
 2182  }
 2183  
 2184: #endif // STBI_SSE2
 2185  
 2186  #ifdef STBI_NEON
 2187  
 2188: // NEON integer IDCT. should produce bit-identical
 2189: // results to the generic C version.
 2190  static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
 2191  {
 ....
 2217     int32x4_t out##_h = vshll_n_s16(vget_high_s16(inq), 12)
 2218  
 2219: // wide add
 2220  #define dct_wadd(out, a, b) \
 2221     int32x4_t out##_l = vaddq_s32(a##_l, b##_l); \
 2222     int32x4_t out##_h = vaddq_s32(a##_h, b##_h)
 2223  
 2224: // wide sub
 2225  #define dct_wsub(out, a, b) \
 2226     int32x4_t out##_l = vsubq_s32(a##_l, b##_l); \
 2227     int32x4_t out##_h = vsubq_s32(a##_h, b##_h)
 2228  
 2229: // butterfly a/b, then shift using "shiftop" by "s" and pack
 2230  #define dct_bfly32o(out0,out1, a,b,shiftop,s) \
 2231     { \
 ....
 2238  #define dct_pass(shiftop, shift) \
 2239     { \
 2240:       /* even part */ \
 2241        int16x8_t sum26 = vaddq_s16(row2, row6); \
 2242        dct_long_mul(p1e, sum26, rot0_0); \
 ....
 2251        dct_wadd(x1, t1e, t2e); \
 2252        dct_wsub(x2, t1e, t2e); \
 2253:       /* odd part */ \
 2254        int16x8_t sum15 = vaddq_s16(row1, row5); \
 2255        int16x8_t sum17 = vaddq_s16(row1, row7); \
 ....
 2276     }
 2277  
 2278:    // load
 2279     row0 = vld1q_s16(data + 0*8);
 2280     row1 = vld1q_s16(data + 1*8);
 ....
 2286     row7 = vld1q_s16(data + 7*8);
 2287  
 2288:    // add DC bias
 2289     row0 = vaddq_s16(row0, vsetq_lane_s16(1024, vdupq_n_s16(0), 0));
 2290  
 2291:    // column pass
 2292     dct_pass(vrshrn_n_s32, 10);
 2293  
 2294:    // 16bit 8x8 transpose
 2295     {
 2296: // these three map to a single VTRN.16, VTRN.32, and VSWP, respectively.
 2297: // whether compilers actually get this is another story, sadly.
 2298  #define dct_trn16(x, y) { int16x8x2_t t = vtrnq_s16(x, y); x = t.val[0]; y = t.val[1]; }
 2299  #define dct_trn32(x, y) { int32x4x2_t t = vtrnq_s32(vreinterpretq_s32_s16(x), vreinterpretq_s32_s16(y)); x = vreinterpretq_s16_s32(t.val[0]); y = vreinterpretq_s16_s32(t.val[1]); }
 2300  #define dct_trn64(x, y) { int16x8_t x0 = x; int16x8_t y0 = y; x = vcombine_s16(vget_low_s16(x0), vget_low_s16(y0)); y = vcombine_s16(vget_high_s16(x0), vget_high_s16(y0)); }
 2301  
 2302:       // pass 1
 2303:       dct_trn16(row0, row1); // a0b0a2b2a4b4a6b6
 2304        dct_trn16(row2, row3);
 2305        dct_trn16(row4, row5);
 2306        dct_trn16(row6, row7);
 2307  
 2308:       // pass 2
 2309:       dct_trn32(row0, row2); // a0b0c0d0a4b4c4d4
 2310        dct_trn32(row1, row3);
 2311        dct_trn32(row4, row6);
 2312        dct_trn32(row5, row7);
 2313  
 2314:       // pass 3
 2315:       dct_trn64(row0, row4); // a0b0c0d0e0f0g0h0
 2316        dct_trn64(row1, row5);
 2317        dct_trn64(row2, row6);
 ....
 2323     }
 2324  
 2325:    // row pass
 2326:    // vrshrn_n_s32 only supports shifts up to 16, we need
 2327:    // 17. so do a non-rounding shift of 16 first then follow
 2328:    // up with a rounding shift by 1.
 2329     dct_pass(vshrn_n_s32, 16);
 2330  
 2331     {
 2332:       // pack and round
 2333        uint8x8_t p0 = vqrshrun_n_s16(row0, 1);
 2334        uint8x8_t p1 = vqrshrun_n_s16(row1, 1);
 ....
 2340        uint8x8_t p7 = vqrshrun_n_s16(row7, 1);
 2341  
 2342:       // again, these can translate into one instruction, but often don't.
 2343  #define dct_trn8_8(x, y) { uint8x8x2_t t = vtrn_u8(x, y); x = t.val[0]; y = t.val[1]; }
 2344  #define dct_trn8_16(x, y) { uint16x4x2_t t = vtrn_u16(vreinterpret_u16_u8(x), vreinterpret_u16_u8(y)); x = vreinterpret_u8_u16(t.val[0]); y = vreinterpret_u8_u16(t.val[1]); }
 2345  #define dct_trn8_32(x, y) { uint32x2x2_t t = vtrn_u32(vreinterpret_u32_u8(x), vreinterpret_u32_u8(y)); x = vreinterpret_u8_u32(t.val[0]); y = vreinterpret_u8_u32(t.val[1]); }
 2346  
 2347:       // sadly can't use interleaved stores here since we only write
 2348:       // 8 bytes to each scan line!
 2349  
 2350:       // 8x8 8-bit transpose pass 1
 2351        dct_trn8_8(p0, p1);
 2352        dct_trn8_8(p2, p3);
 ....
 2354        dct_trn8_8(p6, p7);
 2355  
 2356:       // pass 2
 2357        dct_trn8_16(p0, p2);
 2358        dct_trn8_16(p1, p3);
 ....
 2360        dct_trn8_16(p5, p7);
 2361  
 2362:       // pass 3
 2363        dct_trn8_32(p0, p4);
 2364        dct_trn8_32(p1, p5);
 ....
 2366        dct_trn8_32(p3, p7);
 2367  
 2368:       // store
 2369        vst1_u8(out, p0); out += out_stride;
 2370        vst1_u8(out, p1); out += out_stride;
 ....
 2390  }
 2391  
 2392: #endif // STBI_NEON
 2393  
 2394  #define STBI__MARKER_none  0xff
 2395: // if there's a pending marker from the entropy stream, return that
 2396: // otherwise, fetch from the stream and get a marker. if there's no
 2397: // marker, return 0xff, which is never a valid marker value
 2398  static stbi_uc stbi__get_marker(stbi__jpeg *j)
 2399  {
 ....
 2407  }
 2408  
 2409: // in each scan, we'll have scan_n components, and the order
 2410: // of the components is specified by order[]
 2411  #define STBI__RESTART(x)     ((x) >= 0xd0 && (x) <= 0xd7)
 2412  
 2413: // after a restart interval, stbi__jpeg_reset the entropy decoder and
 2414: // the dc prediction
 2415  static void stbi__jpeg_reset(stbi__jpeg *j)
 2416  {
 ....
 2422     j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;
 2423     j->eob_run = 0;
 2424:    // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
 2425:    // since we don't even allow 1<<30 pixels
 2426  }
 2427  
 ....
 2434           STBI_SIMD_ALIGN(short, data[64]);
 2435           int n = z->order[0];
 2436:          // non-interleaved data, we just need to process one block at a time,
 2437:          // in trivial scanline order
 2438:          // number of blocks to do just depends on how many actual "pixels" this
 2439:          // component has, independent of interleaved MCU blocking and such
 2440           int w = (z->img_comp[n].x+7) >> 3;
 2441           int h = (z->img_comp[n].y+7) >> 3;
 ....
 2445                 if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
 2446                 z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
 2447:                // every data block is an MCU, so countdown the restart interval
 2448                 if (--z->todo <= 0) {
 2449                    if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
 2450:                   // if it's NOT a restart, then just bail, so we get corrupt data
 2451:                   // rather than no data
 2452                    if (!STBI__RESTART(z->marker)) return 1;
 2453                    stbi__jpeg_reset(z);
 ....
 2456           }
 2457           return 1;
 2458:       } else { // interleaved
 2459           int i,j,k,x,y;
 2460           STBI_SIMD_ALIGN(short, data[64]);
 2461           for (j=0; j < z->img_mcu_y; ++j) {
 2462              for (i=0; i < z->img_mcu_x; ++i) {
 2463:                // scan an interleaved mcu... process scan_n components in order
 2464                 for (k=0; k < z->scan_n; ++k) {
 2465                    int n = z->order[k];
 2466:                   // scan out an mcu's worth of this component; that's just determined
 2467:                   // by the basic H and V specified for the component
 2468                    for (y=0; y < z->img_comp[n].v; ++y) {
 2469                       for (x=0; x < z->img_comp[n].h; ++x) {
 ....
 2476                    }
 2477                 }
 2478:                // after all interleaved components, that's an interleaved MCU,
 2479:                // so now count down the restart interval
 2480                 if (--z->todo <= 0) {
 2481                    if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
 ....
 2491           int i,j;
 2492           int n = z->order[0];
 2493:          // non-interleaved data, we just need to process one block at a time,
 2494:          // in trivial scanline order
 2495:          // number of blocks to do just depends on how many actual "pixels" this
 2496:          // component has, independent of interleaved MCU blocking and such
 2497           int w = (z->img_comp[n].x+7) >> 3;
 2498           int h = (z->img_comp[n].y+7) >> 3;
 ....
 2508                       return 0;
 2509                 }
 2510:                // every data block is an MCU, so countdown the restart interval
 2511                 if (--z->todo <= 0) {
 2512                    if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
 ....
 2517           }
 2518           return 1;
 2519:       } else { // interleaved
 2520           int i,j,k,x,y;
 2521           for (j=0; j < z->img_mcu_y; ++j) {
 2522              for (i=0; i < z->img_mcu_x; ++i) {
 2523:                // scan an interleaved mcu... process scan_n components in order
 2524                 for (k=0; k < z->scan_n; ++k) {
 2525                    int n = z->order[k];
 2526:                   // scan out an mcu's worth of this component; that's just determined
 2527:                   // by the basic H and V specified for the component
 2528                    for (y=0; y < z->img_comp[n].v; ++y) {
 2529                       for (x=0; x < z->img_comp[n].h; ++x) {
 ....
 2536                    }
 2537                 }
 2538:                // after all interleaved components, that's an interleaved MCU,
 2539:                // so now count down the restart interval
 2540                 if (--z->todo <= 0) {
 2541                    if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
 ....
 2560  {
 2561     if (z->progressive) {
 2562:       // dequantize and idct the data
 2563        int i,j,n;
 2564        for (n=0; n < z->s->img_n; ++n) {
 ....
 2580     int L;
 2581     switch (m) {
 2582:       case STBI__MARKER_none: // no marker found
 2583           return stbi__err("expected marker","Corrupt JPEG");
 2584  
 2585:       case 0xDD: // DRI - specify restart interval
 2586           if (stbi__get16be(z->s) != 4) return stbi__err("bad DRI len","Corrupt JPEG");
 2587           z->restart_interval = stbi__get16be(z->s);
 2588           return 1;
 2589  
 2590:       case 0xDB: // DQT - define quantization table
 2591           L = stbi__get16be(z->s)-2;
 2592           while (L > 0) {
 ....
 2602           return L==0;
 2603  
 2604:       case 0xC4: // DHT - define huffman table
 2605           L = stbi__get16be(z->s)-2;
 2606           while (L > 0) {
 ....
 2631           return L==0;
 2632     }
 2633:    // check for comment block or APP blocks
 2634     if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {
 2635        stbi__skip(z->s, stbi__get16be(z->s)-2);
 ....
 2639  }
 2640  
 2641: // after we see SOS
 2642  static int stbi__process_scan_header(stbi__jpeg *z)
 2643  {
 ....
 2653           if (z->img_comp[which].id == id)
 2654              break;
 2655:       if (which == z->s->img_n) return 0; // no match
 2656        z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err("bad DC huff","Corrupt JPEG");
 2657        z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err("bad AC huff","Corrupt JPEG");
 ....
 2662        int aa;
 2663        z->spec_start = stbi__get8(z->s);
 2664:       z->spec_end   = stbi__get8(z->s); // should be 63, but might be 0
 2665        aa = stbi__get8(z->s);
 2666        z->succ_high = (aa >> 4);
 ....
 2683     stbi__context *s = z->s;
 2684     int Lf,p,i,q, h_max=1,v_max=1,c;
 2685:    Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err("bad SOF len","Corrupt JPEG"); // JPEG
 2686:    p  = stbi__get8(s);            if (p != 8) return stbi__err("only 8-bit","JPEG format not supported: 8-bit only"); // JPEG baseline
 2687:    s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err("no header height", "JPEG format not supported: delayed height"); // Legal, but we don't handle it--but neither does IJG
 2688:    s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err("0 width","Corrupt JPEG"); // JPEG requires
 2689     c = stbi__get8(s);
 2690:    if (c != 3 && c != 1) return stbi__err("bad component count","Corrupt JPEG");    // JFIF requires
 2691     s->img_n = c;
 2692     for (i=0; i < c; ++i) {
 ....
 2699     for (i=0; i < s->img_n; ++i) {
 2700        z->img_comp[i].id = stbi__get8(s);
 2701:       if (z->img_comp[i].id != i+1)   // JFIF requires
 2702:          if (z->img_comp[i].id != i)  // some version of jpegtran outputs non-JFIF-compliant files!
 2703              return stbi__err("bad component ID","Corrupt JPEG");
 2704        q = stbi__get8(s);
 ....
 2717     }
 2718  
 2719:    // compute interleaved mcu info
 2720     z->img_h_max = h_max;
 2721     z->img_v_max = v_max;
 ....
 2726  
 2727     for (i=0; i < s->img_n; ++i) {
 2728:       // number of effective pixels (e.g. for non-interleaved MCU)
 2729        z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;
 2730        z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;
 2731:       // to simplify generation, we'll allocate enough memory to decode
 2732:       // the bogus oversized data from using interleaved MCUs and their
 2733:       // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't
 2734:       // discard the extra data until colorspace conversion
 2735        z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;
 2736        z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;
 ....
 2744           return stbi__err("outofmem", "Out of memory");
 2745        }
 2746:       // align blocks for idct using mmx/sse
 2747        z->img_comp[i].data = (stbi_uc*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);
 2748        z->img_comp[i].linebuf = NULL;
 ....
 2761  }
 2762  
 2763: // use comparisons since in some cases we handle more than one case (e.g. SOF)
 2764  #define stbi__DNL(x)         ((x) == 0xdc)
 2765  #define stbi__SOI(x)         ((x) == 0xd8)
 ....
 2773  {
 2774     int m;
 2775:    z->marker = STBI__MARKER_none; // initialize cached marker to empty
 2776     m = stbi__get_marker(z);
 2777     if (!stbi__SOI(m)) return stbi__err("no SOI","Corrupt JPEG");
 ....
 2782        m = stbi__get_marker(z);
 2783        while (m == STBI__MARKER_none) {
 2784:          // some files have extra padding after their blocks, so ok, we'll scan
 2785           if (stbi__at_eof(z->s)) return stbi__err("no SOF", "Corrupt JPEG");
 2786           m = stbi__get_marker(z);
 ....
 2792  }
 2793  
 2794: // decode image to YCbCr format
 2795  static int stbi__decode_jpeg_image(stbi__jpeg *j)
 2796  {
 ....
 2808           if (!stbi__parse_entropy_coded_data(j)) return 0;
 2809           if (j->marker == STBI__MARKER_none ) {
 2810:             // handle 0s at the end of image data from IP Kamera 9060
 2811              while (!stbi__at_eof(j->s)) {
 2812                 int x = stbi__get8(j->s);
 ....
 2818                 }
 2819              }
 2820:             // if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0
 2821           }
 2822        } else {
 ....
 2830  }
 2831  
 2832: // static jfif-centered resampling (across block boundaries)
 2833  
 2834  typedef stbi_uc *(*resample_row_func)(stbi_uc *out, stbi_uc *in0, stbi_uc *in1,
 ....
 2848  static stbi_uc* stbi__resample_row_v_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
 2849  {
 2850:    // need to generate two samples vertically for every one in input
 2851     int i;
 2852     STBI_NOTUSED(hs);
 ....
 2858  static stbi_uc*  stbi__resample_row_h_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
 2859  {
 2860:    // need to generate two samples horizontally for every one in input
 2861     int i;
 2862     stbi_uc *input = in_near;
 2863  
 2864     if (w == 1) {
 2865:       // if only one sample, can't do any interpolation
 2866        out[0] = out[1] = input[0];
 2867        return out;
 ....
 2888  static stbi_uc *stbi__resample_row_hv_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
 2889  {
 2890:    // need to generate 2x2 samples for every one in input
 2891     int i,t0,t1;
 2892     if (w == 1) {
 ....
 2913  static stbi_uc *stbi__resample_row_hv_2_simd(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
 2914  {
 2915:    // need to generate 2x2 samples for every one in input
 2916     int i=0,t0,t1;
 2917  
 ....
 2922  
 2923     t1 = 3*in_near[0] + in_far[0];
 2924:    // process groups of 8 pixels for as long as we can.
 2925:    // note we can't handle the last pixel in a row in this loop
 2926:    // because we need to handle the filter boundary conditions.
 2927     for (; i < ((w-1) & ~7); i += 8) {
 2928  #if defined(STBI_SSE2)
 2929:       // load and perform the vertical filtering pass
 2930:       // this uses 3*x + y = 4*x + (y - x)
 2931        __m128i zero  = _mm_setzero_si128();
 2932        __m128i farb  = _mm_loadl_epi64((__m128i *) (in_far + i));
 ....
 2936        __m128i diff  = _mm_sub_epi16(farw, nearw);
 2937        __m128i nears = _mm_slli_epi16(nearw, 2);
 2938:       __m128i curr  = _mm_add_epi16(nears, diff); // current row
 2939  
 2940:       // horizontal filter works the same based on shifted vers of current
 2941:       // row. "prev" is current row shifted right by 1 pixel; we need to
 2942:       // insert the previous pixel value (from t1).
 2943:       // "next" is current row shifted left by 1 pixel, with first pixel
 2944:       // of next block of 8 pixels added in.
 2945        __m128i prv0 = _mm_slli_si128(curr, 2);
 2946        __m128i nxt0 = _mm_srli_si128(curr, 2);
 ....
 2948        __m128i next = _mm_insert_epi16(nxt0, 3*in_near[i+8] + in_far[i+8], 7);
 2949  
 2950:       // horizontal filter, polyphase implementation since it's convenient:
 2951:       // even pixels = 3*cur + prev = cur*4 + (prev - cur)
 2952:       // odd  pixels = 3*cur + next = cur*4 + (next - cur)
 2953:       // note the shared term.
 2954        __m128i bias  = _mm_set1_epi16(8);
 2955        __m128i curs = _mm_slli_epi16(curr, 2);
 ....
 2960        __m128i odd  = _mm_add_epi16(nxtd, curb);
 2961  
 2962:       // interleave even and odd pixels, then undo scaling.
 2963        __m128i int0 = _mm_unpacklo_epi16(even, odd);
 2964        __m128i int1 = _mm_unpackhi_epi16(even, odd);
 ....
 2966        __m128i de1  = _mm_srli_epi16(int1, 4);
 2967  
 2968:       // pack and write output
 2969        __m128i outv = _mm_packus_epi16(de0, de1);
 2970        _mm_storeu_si128((__m128i *) (out + i*2), outv);
 2971  #elif defined(STBI_NEON)
 2972:       // load and perform the vertical filtering pass
 2973:       // this uses 3*x + y = 4*x + (y - x)
 2974        uint8x8_t farb  = vld1_u8(in_far + i);
 2975        uint8x8_t nearb = vld1_u8(in_near + i);
 2976        int16x8_t diff  = vreinterpretq_s16_u16(vsubl_u8(farb, nearb));
 2977        int16x8_t nears = vreinterpretq_s16_u16(vshll_n_u8(nearb, 2));
 2978:       int16x8_t curr  = vaddq_s16(nears, diff); // current row
 2979  
 2980:       // horizontal filter works the same based on shifted vers of current
 2981:       // row. "prev" is current row shifted right by 1 pixel; we need to
 2982:       // insert the previous pixel value (from t1).
 2983:       // "next" is current row shifted left by 1 pixel, with first pixel
 2984:       // of next block of 8 pixels added in.
 2985        int16x8_t prv0 = vextq_s16(curr, curr, 7);
 2986        int16x8_t nxt0 = vextq_s16(curr, curr, 1);
 ....
 2988        int16x8_t next = vsetq_lane_s16(3*in_near[i+8] + in_far[i+8], nxt0, 7);
 2989  
 2990:       // horizontal filter, polyphase implementation since it's convenient:
 2991:       // even pixels = 3*cur + prev = cur*4 + (prev - cur)
 2992:       // odd  pixels = 3*cur + next = cur*4 + (next - cur)
 2993:       // note the shared term.
 2994        int16x8_t curs = vshlq_n_s16(curr, 2);
 2995        int16x8_t prvd = vsubq_s16(prev, curr);
 ....
 2998        int16x8_t odd  = vaddq_s16(curs, nxtd);
 2999  
 3000:       // undo scaling and round, then store with even/odd phases interleaved
 3001        uint8x8x2_t o;
 3002        o.val[0] = vqrshrun_n_s16(even, 4);
 ....
 3005  #endif
 3006  
 3007:       // "previous" value for next iter
 3008        t1 = 3*in_near[i+7] + in_far[i+7];
 3009     }
 ....
 3029  static stbi_uc *stbi__resample_row_generic(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
 3030  {
 3031:    // resample with nearest-neighbor
 3032     int i,j;
 3033     STBI_NOTUSED(in_far);
 ....
 3039  
 3040  #ifdef STBI_JPEG_OLD
 3041: // this is the same YCbCr-to-RGB calculation that stb_image has used
 3042: // historically before the algorithm changes in 1.49
 3043  #define float2fixed(x)  ((int) ((x) * 65536 + 0.5))
 3044  static void stbi__YCbCr_to_RGB_row(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step)
 ....
 3046     int i;
 3047     for (i=0; i < count; ++i) {
 3048:       int y_fixed = (y[i] << 16) + 32768; // rounding
 3049        int r,g,b;
 3050        int cr = pcr[i] - 128;
 ....
 3067  }
 3068  #else
 3069: // this is a reduced-precision calculation of YCbCr-to-RGB introduced
 3070: // to make sure the code produces the same results in both SIMD and scalar
 3071  #define float2fixed(x)  (((int) ((x) * 4096.0f + 0.5f)) << 8)
 3072  static void stbi__YCbCr_to_RGB_row(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step)
 ....
 3074     int i;
 3075     for (i=0; i < count; ++i) {
 3076:       int y_fixed = (y[i] << 20) + (1<<19); // rounding
 3077        int r,g,b;
 3078        int cr = pcr[i] - 128;
 ....
 3102  
 3103  #ifdef STBI_SSE2
 3104:    // step == 3 is pretty ugly on the final interleave, and i'm not convinced
 3105:    // it's useful in practice (you wouldn't use it for textures, for example).
 3106:    // so just accelerate step == 4 case.
 3107     if (step == 4) {
 3108:       // this is a fairly straightforward implementation and not super-optimized.
 3109        __m128i signflip  = _mm_set1_epi8(-0x80);
 3110        __m128i cr_const0 = _mm_set1_epi16(   (short) ( 1.40200f*4096.0f+0.5f));
 ....
 3113        __m128i cb_const1 = _mm_set1_epi16(   (short) ( 1.77200f*4096.0f+0.5f));
 3114        __m128i y_bias = _mm_set1_epi8((char) (unsigned char) 128);
 3115:       __m128i xw = _mm_set1_epi16(255); // alpha channel
 3116  
 3117        for (; i+7 < count; i += 8) {
 3118:          // load
 3119           __m128i y_bytes = _mm_loadl_epi64((__m128i *) (y+i));
 3120           __m128i cr_bytes = _mm_loadl_epi64((__m128i *) (pcr+i));
 3121           __m128i cb_bytes = _mm_loadl_epi64((__m128i *) (pcb+i));
 3122:          __m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128
 3123:          __m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128
 3124  
 3125:          // unpack to short (and left-shift cr, cb by 8)
 3126           __m128i yw  = _mm_unpacklo_epi8(y_bias, y_bytes);
 3127           __m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);
 3128           __m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);
 3129  
 3130:          // color transform
 3131           __m128i yws = _mm_srli_epi16(yw, 4);
 3132           __m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);
 ....
 3139           __m128i gws = _mm_add_epi16(gwt, cr1);
 3140  
 3141:          // descale
 3142           __m128i rw = _mm_srai_epi16(rws, 4);
 3143           __m128i bw = _mm_srai_epi16(bws, 4);
 3144           __m128i gw = _mm_srai_epi16(gws, 4);
 3145  
 3146:          // back to byte, set up for transpose
 3147           __m128i brb = _mm_packus_epi16(rw, bw);
 3148           __m128i gxb = _mm_packus_epi16(gw, xw);
 3149  
 3150:          // transpose to interleave channels
 3151           __m128i t0 = _mm_unpacklo_epi8(brb, gxb);
 3152           __m128i t1 = _mm_unpackhi_epi8(brb, gxb);
 ....
 3154           __m128i o1 = _mm_unpackhi_epi16(t0, t1);
 3155  
 3156:          // store
 3157           _mm_storeu_si128((__m128i *) (out + 0), o0);
 3158           _mm_storeu_si128((__m128i *) (out + 16), o1);
 ....
 3163  
 3164  #ifdef STBI_NEON
 3165:    // in this version, step=3 support would be easy to add. but is there demand?
 3166     if (step == 4) {
 3167:       // this is a fairly straightforward implementation and not super-optimized.
 3168        uint8x8_t signflip = vdup_n_u8(0x80);
 3169        int16x8_t cr_const0 = vdupq_n_s16(   (short) ( 1.40200f*4096.0f+0.5f));
 ....
 3173  
 3174        for (; i+7 < count; i += 8) {
 3175:          // load
 3176           uint8x8_t y_bytes  = vld1_u8(y + i);
 3177           uint8x8_t cr_bytes = vld1_u8(pcr + i);
 ....
 3180           int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));
 3181  
 3182:          // expand to s16
 3183           int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));
 3184           int16x8_t crw = vshll_n_s8(cr_biased, 7);
 3185           int16x8_t cbw = vshll_n_s8(cb_biased, 7);
 3186  
 3187:          // color transform
 3188           int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);
 3189           int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);
 ....
 3194           int16x8_t bws = vaddq_s16(yws, cb1);
 3195  
 3196:          // undo scaling, round, convert to byte
 3197           uint8x8x4_t o;
 3198           o.val[0] = vqrshrun_n_s16(rws, 4);
 ....
 3201           o.val[3] = vdup_n_u8(255);
 3202  
 3203:          // store, interleaving r/g/b/a
 3204           vst4_u8(out, o);
 3205           out += 8*4;
 ....
 3209  
 3210     for (; i < count; ++i) {
 3211:       int y_fixed = (y[i] << 20) + (1<<19); // rounding
 3212        int r,g,b;
 3213        int cr = pcr[i] - 128;
 ....
 3231  #endif
 3232  
 3233: // set up the kernels
 3234  static void stbi__setup_jpeg(stbi__jpeg *j)
 3235  {
 ....
 3257  }
 3258  
 3259: // clean up the temporary component buffers
 3260  static void stbi__cleanup_jpeg(stbi__jpeg *j)
 3261  {
 ....
 3283     resample_row_func resample;
 3284     stbi_uc *line0,*line1;
 3285:    int hs,vs;   // expansion factor in each axis
 3286:    int w_lores; // horizontal pixels pre-expansion
 3287:    int ystep;   // how far through vertical expansion we are
 3288:    int ypos;    // which pre-expansion row we're on
 3289  } stbi__resample;
 3290  
 ....
 3292  {
 3293     int n, decode_n;
 3294:    z->s->img_n = 0; // make stbi__cleanup_jpeg safe
 3295  
 3296:    // validate req_comp
 3297     if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");
 3298  
 3299:    // load a jpeg image from whichever source, but leave in YCbCr format
 3300     if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }
 3301  
 3302:    // determine actual number of components to generate
 3303     n = req_comp ? req_comp : z->s->img_n;
 3304  
 ....
 3308        decode_n = z->s->img_n;
 3309  
 3310:    // resample and color-convert
 3311     {
 3312        int k;
 ....
 3320           stbi__resample *r = &res_comp[k];
 3321  
 3322:          // allocate line buffer big enough for upsampling off the edges
 3323:          // with upsample factor of 4
 3324           z->img_comp[k].linebuf = (stbi_uc *) stbi__malloc(z->s->img_x + 3);
 3325           if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }
 ....
 3339        }
 3340  
 3341:       // can't error after this so, this is safe
 3342        output = (stbi_uc *) stbi__malloc(n * z->s->img_x * z->s->img_y + 1);
 3343        if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }
 3344  
 3345:       // now go ahead and resample
 3346        for (j=0; j < z->s->img_y; ++j) {
 3347           stbi_uc *out = output + n * z->s->img_x * j;
 ....
 3367                 for (i=0; i < z->s->img_x; ++i) {
 3368                    out[0] = out[1] = out[2] = y[i];
 3369:                   out[3] = 255; // not used if n==3
 3370                    out += n;
 3371                 }
 ....
 3381        *out_x = z->s->img_x;
 3382        *out_y = z->s->img_y;
 3383:       if (comp) *comp  = z->s->img_n; // report original components, not output
 3384        return output;
 3385     }
 ....
 3425  #endif
 3426  
 3427: // public domain zlib decode    v0.2  Sean Barrett 2006-11-18
 3428: //    simple implementation
 3429: //      - all input must be provided in an upfront buffer
 3430: //      - all output is written to a single output buffer (can malloc/realloc)
 3431: //    performance
 3432: //      - fast huffman
 3433  
 3434  #ifndef STBI_NO_ZLIB
 3435  
 3436: // fast-way is faster to check than jpeg huffman, but slow way is slower
 3437: #define STBI__ZFAST_BITS  9 // accelerate all cases in default tables
 3438  #define STBI__ZFAST_MASK  ((1 << STBI__ZFAST_BITS) - 1)
 3439  
 3440: // zlib-style huffman encoding
 3441: // (jpegs packs from left, zlib from right, so can't share code)
 3442  typedef struct
 3443  {
 ....
 3462  {
 3463     STBI_ASSERT(bits <= 16);
 3464:    // to bit reverse n bits, reverse 16 and shift
 3465:    // e.g. 11 bits, bit reverse and shift away 5
 3466     return stbi__bitreverse16(v) >> (16-bits);
 3467  }
 ....
 3472     int code, next_code[16], sizes[17];
 3473  
 3474:    // DEFLATE spec for generating codes
 3475     memset(sizes, 0, sizeof(sizes));
 3476     memset(z->fast, 0, sizeof(z->fast));
 ....
 3489        if (sizes[i])
 3490           if (code-1 >= (1 << i)) return stbi__err("bad codelengths","Corrupt PNG");
 3491:       z->maxcode[i] = code << (16-i); // preshift for inner loop
 3492        code <<= 1;
 3493        k += sizes[i];
 3494     }
 3495:    z->maxcode[16] = 0x10000; // sentinel
 3496     for (i=0; i < num; ++i) {
 3497        int s = sizelist[i];
 ....
 3514  }
 3515  
 3516: // zlib-from-memory implementation for PNG reading
 3517: //    because PNG allows splitting the zlib stream arbitrarily,
 3518: //    and it's annoying structurally to have PNG call ZLIB call PNG,
 3519: //    we require PNG read all the IDATs and combine them into a single
 3520: //    memory buffer
 3521  
 3522  typedef struct
 ....
 3562  {
 3563     int b,s,k;
 3564:    // not resolved by fast table, so compute it the slow way
 3565:    // use jpeg approach, which requires MSbits at top
 3566     k = stbi__bit_reverse(a->code_buffer, 16);
 3567     for (s=STBI__ZFAST_BITS+1; ; ++s)
 3568        if (k < z->maxcode[s])
 3569           break;
 3570:    if (s == 16) return -1; // invalid code!
 3571:    // code size is s, so:
 3572     b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];
 3573     STBI_ASSERT(z->size[b] == s);
 ....
 3591  }
 3592  
 3593: static int stbi__zexpand(stbi__zbuf *z, char *zout, int n)  // need to make room for n bytes
 3594  {
 3595     char *q;
 ....
 3629        int z = stbi__zhuffman_decode(a, &a->z_length);
 3630        if (z < 256) {
 3631:          if (z < 0) return stbi__err("bad huffman code","Corrupt PNG"); // error in huffman codes
 3632           if (zout >= a->zout_end) {
 3633              if (!stbi__zexpand(a, zout, 1)) return 0;
 ....
 3655           }
 3656           p = (stbi_uc *) (zout - dist);
 3657:          if (dist == 1) { // run of one byte; common in images.
 3658              stbi_uc v = *p;
 3659              if (len) { do *zout++ = v; while (--len); }
 ....
 3669     static stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
 3670     stbi__zhuffman z_codelength;
 3671:    stbi_uc lencodes[286+32+137];//padding for maximum single op
 3672     stbi_uc codelength_sizes[19];
 3673     int i,n;
 ....
 3716     int len,nlen,k;
 3717     if (a->num_bits & 7)
 3718:       stbi__zreceive(a, a->num_bits & 7); // discard
 3719:    // drain the bit-packed data into header
 3720     k = 0;
 3721     while (a->num_bits > 0) {
 3722:       header[k++] = (stbi_uc) (a->code_buffer & 255); // suppress MSVC run-time check
 3723        a->code_buffer >>= 8;
 3724        a->num_bits -= 8;
 3725     }
 3726     STBI_ASSERT(a->num_bits == 0);
 3727:    // now fill header the normal way
 3728     while (k < 4)
 3729        header[k++] = stbi__zget8(a);
 ....
 3744     int cmf   = stbi__zget8(a);
 3745     int cm    = cmf & 15;
 3746:    /* int cinfo = cmf >> 4; */
 3747     int flg   = stbi__zget8(a);
 3748:    if ((cmf*256+flg) % 31 != 0) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec
 3749:    if (flg & 32) return stbi__err("no preset dict","Corrupt PNG"); // preset dictionary not allowed in png
 3750:    if (cm != 8) return stbi__err("bad compression","Corrupt PNG"); // DEFLATE required for png
 3751:    // window = 1 << (8 + cinfo)... but who cares, we fully buffer output
 3752     return 1;
 3753  }
 3754  
 3755: // @TODO: should statically initialize these for optimal thread safety
 3756  static stbi_uc stbi__zdefault_length[288], stbi__zdefault_distance[32];
 3757  static void stbi__init_zdefaults(void)
 3758  {
 3759:    int i;   // use <= to match clearly with spec
 3760     for (i=0; i <= 143; ++i)     stbi__zdefault_length[i]   = 8;
 3761     for (   ; i <= 255; ++i)     stbi__zdefault_length[i]   = 9;
 ....
 3782        } else {
 3783           if (type == 1) {
 3784:             // use fixed code lengths
 3785              if (!stbi__zdefault_distance[31]) stbi__init_zdefaults();
 3786              if (!stbi__zbuild_huffman(&a->z_length  , stbi__zdefault_length  , 288)) return 0;
 ....
 3881  #endif
 3882  
 3883: // public domain "baseline" PNG decoder   v0.10  Sean Barrett 2006-11-18
 3884: //    simple implementation
 3885: //      - only 8-bit samples
 3886: //      - no CRC checking
 3887: //      - allocates lots of intermediate memory
 3888: //        - avoids problem of streaming data between subsystems
 3889: //        - avoids explicit window management
 3890: //    performance
 3891: //      - uses stb_zlib, a PD zlib implementation with fast huffman decoding
 3892  
 3893  #ifndef STBI_NO_PNG
 ....
 3928     STBI__F_avg=3,
 3929     STBI__F_paeth=4,
 3930:    // synthetic filters used for first scanline to avoid needing a dummy row of 0s
 3931     STBI__F_avg_first,
 3932     STBI__F_paeth_first
 ....
 3955  static stbi_uc stbi__depth_scale_table[9] = { 0, 0xff, 0x55, 0, 0x11, 0,0,0, 0x01 };
 3956  
 3957: // create the png data from post-deflated data
 3958  static int stbi__create_png_image_raw(stbi__png *a, stbi_uc *raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)
 3959  {
 ....
 3962     stbi__uint32 img_len, img_width_bytes;
 3963     int k;
 3964:    int img_n = s->img_n; // copy it into a local for later
 3965  
 3966     STBI_ASSERT(out_n == s->img_n || out_n == s->img_n+1);
 3967:    a->out = (stbi_uc *) stbi__malloc(x * y * out_n); // extra bytes to write off the end into
 3968     if (!a->out) return stbi__err("outofmem", "Out of memory");
 3969  
 ....
 3972     if (s->img_x == x && s->img_y == y) {
 3973        if (raw_len != img_len) return stbi__err("not enough pixels","Corrupt PNG");
 3974:    } else { // interlaced:
 3975        if (raw_len < img_len) return stbi__err("not enough pixels","Corrupt PNG");
 3976     }
 ....
 3987        if (depth < 8) {
 3988           STBI_ASSERT(img_width_bytes <= x);
 3989:          cur += x*out_n - img_width_bytes; // store output to the rightmost img_len bytes, so we can decode in place
 3990           filter_bytes = 1;
 3991           width = img_width_bytes;
 3992        }
 3993  
 3994:       // if first row, use special filter that doesn't sample previous row
 3995        if (j == 0) filter = first_row_filter[filter];
 3996  
 3997:       // handle first byte explicitly
 3998        for (k=0; k < filter_bytes; ++k) {
 3999           switch (filter) {
 ....
 4010        if (depth == 8) {
 4011           if (img_n != out_n)
 4012:             cur[img_n] = 255; // first pixel
 4013           raw += img_n;
 4014           cur += out_n;
 ....
 4020        }
 4021  
 4022:       // this is a little gross, so that we don't switch per-pixel or per-component
 4023        if (depth < 8 || img_n == out_n) {
 4024           int nk = (width - 1)*img_n;
 ....
 4027                  for (k=0; k < nk; ++k)
 4028           switch (filter) {
 4029:             // "none" filter turns into a memcpy here; make that explicit.
 4030              case STBI__F_none:         memcpy(cur, raw, nk); break;
 4031              CASE(STBI__F_sub)          cur[k] = STBI__BYTECAST(raw[k] + cur[k-filter_bytes]); break;
 ....
 4057     }
 4058  
 4059:    // we make a separate pass to expand bits to pixels; for performance,
 4060:    // this could run two scanlines behind the above code, so it won't
 4061:    // intefere with filtering but will still be in the cache.
 4062     if (depth < 8) {
 4063        for (j=0; j < y; ++j) {
 4064           stbi_uc *cur = a->out + stride*j;
 4065           stbi_uc *in  = a->out + stride*j + x*out_n - img_width_bytes;
 4066:          // unpack 1/2/4-bit into a 8-bit buffer. allows us to keep the common 8-bit path optimal at minimal cost for 1/2/4-bit
 4067:          // png guarante byte alignment, if width is not multiple of 8/4/2 we'll decode dummy trailing data that will be skipped in the later loop
 4068:          stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range
 4069  
 4070:          // note that the final byte might overshoot and write more data than desired.
 4071:          // we can allocate enough data that this never writes out of memory, but it
 4072:          // could also overwrite the next scanline. can it overwrite non-empty data
 4073:          // on the next scanline? yes, consider 1-pixel-wide scanlines with 1-bit-per-pixel.
 4074:          // so we need to explicitly clamp the final ones
 4075  
 4076           if (depth == 4) {
 ....
 4110           }
 4111           if (img_n != out_n) {
 4112:             // insert alpha = 255
 4113              stbi_uc *cur = a->out + stride*j;
 4114              int i;
 ....
 4141        return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);
 4142  
 4143:    // de-interlacing
 4144     final = (stbi_uc *) stbi__malloc(a->s->img_x * a->s->img_y * out_n);
 4145     for (p=0; p < 7; ++p) {
 ....
 4149        int yspc[]  = { 8,8,8,4,4,2,2 };
 4150        int i,j,x,y;
 4151:       // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
 4152        x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];
 4153        y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];
 ....
 4182     stbi_uc *p = z->out;
 4183  
 4184:    // compute color-based transparency, assuming we've
 4185:    // already got 255 as the alpha value in the output
 4186     STBI_ASSERT(out_n == 2 || out_n == 4);
 4187  
 ....
 4209     if (p == NULL) return stbi__err("outofmem", "Out of memory");
 4210  
 4211:    // between here and free(out) below, exitting would leak
 4212     temp_out = p;
 4213  
 ....
 4257     stbi_uc *p = z->out;
 4258  
 4259:    if (s->img_out_n == 3) {  // convert bgr to rgb
 4260        for (i=0; i < pixel_count; ++i) {
 4261           stbi_uc t = p[0];
 ....
 4267        STBI_ASSERT(s->img_out_n == 4);
 4268        if (stbi__unpremultiply_on_load) {
 4269:          // convert bgr to rgb and unpremultiply
 4270           for (i=0; i < pixel_count; ++i) {
 4271              stbi_uc a = p[3];
 ....
 4282           }
 4283        } else {
 4284:          // convert bgr to rgb
 4285           for (i=0; i < pixel_count; ++i) {
 4286              stbi_uc t = p[0];
 ....
 4337                 if (scan == STBI__SCAN_header) return 1;
 4338              } else {
 4339:                // if paletted, then pal_n is our final components, and
 4340:                // img_n is # components to decompress/filter.
 4341                 s->img_n = 1;
 4342                 if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err("too large","Corrupt PNG");
 4343:                // if SCAN_header, have to scan to see if we have a tRNS
 4344              }
 4345              break;
 ....
 4375                 has_trans = 1;
 4376                 for (k=0; k < s->img_n; ++k)
 4377:                   tc[k] = (stbi_uc) (stbi__get16be(s) & 255) * stbi__depth_scale_table[depth]; // non 8-bit images will be larger
 4378              }
 4379              break;
 ....
 4403              if (scan != STBI__SCAN_load) return 1;
 4404              if (z->idata == NULL) return stbi__err("no IDAT","Corrupt PNG");
 4405:             // initial guess for decoded data size to avoid unnecessary reallocs
 4406:             bpl = (s->img_x * depth + 7) / 8; // bytes per line, per component
 4407:             raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;
 4408              z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);
 4409:             if (z->expanded == NULL) return 0; // zlib should set error
 4410              STBI_FREE(z->idata); z->idata = NULL;
 4411              if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)
 ....
 4419                 stbi__de_iphone(z);
 4420              if (pal_img_n) {
 4421:                // pal_img_n == 3 or 4
 4422:                s->img_n = pal_img_n; // record the actual colors we had
 4423                 s->img_out_n = pal_img_n;
 4424                 if (req_comp >= 3) s->img_out_n = req_comp;
 ....
 4431  
 4432           default:
 4433:             // if critical, fail
 4434              if (first) return stbi__err("first not IHDR", "Corrupt PNG");
 4435              if ((c.type & (1 << 29)) == 0) {
 4436                 #ifndef STBI_NO_FAILURE_STRINGS
 4437:                // not threadsafe
 4438                 static char invalid_chunk[] = "XXXX PNG chunk not known";
 4439                 invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);
 ....
 4447              break;
 4448        }
 4449:       // end of PNG chunk, read and skip CRC
 4450        stbi__get32be(s);
 4451     }
 ....
 4510  #endif
 4511  
 4512: // Microsoft/Windows BMP image
 4513  
 4514  #ifndef STBI_NO_BMP
 ....
 4519     if (stbi__get8(s) != 'B') return 0;
 4520     if (stbi__get8(s) != 'M') return 0;
 4521:    stbi__get32le(s); // discard filesize
 4522:    stbi__get16le(s); // discard reserved
 4523:    stbi__get16le(s); // discard reserved
 4524:    stbi__get32le(s); // discard data offset
 4525     sz = stbi__get32le(s);
 4526     r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);
 ....
 4536  
 4537  
 4538: // returns 0..31 for the highest set bit
 4539  static int stbi__high_bit(unsigned int z)
 4540  {
 ....
 4551  static int stbi__bitcount(unsigned int a)
 4552  {
 4553:    a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2
 4554:    a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4
 4555:    a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits
 4556:    a = (a + (a >> 8)); // max 16 per 8 bits
 4557:    a = (a + (a >> 16)); // max 32 per 8 bits
 4558     return a & 0xff;
 4559  }
 ....
 4584     int bpp, flip_vertically, pad, target, offset, hsz;
 4585     if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc("not BMP", "Corrupt BMP");
 4586:    stbi__get32le(s); // discard filesize
 4587:    stbi__get16le(s); // discard reserved
 4588:    stbi__get16le(s); // discard reserved
 4589     offset = stbi__get32le(s);
 4590     hsz = stbi__get32le(s);
 ....
 4608        compress = stbi__get32le(s);
 4609        if (compress == 1 || compress == 2) return stbi__errpuc("BMP RLE", "BMP type not supported: RLE");
 4610:       stbi__get32le(s); // discard sizeof
 4611:       stbi__get32le(s); // discard hres
 4612:       stbi__get32le(s); // discard vres
 4613:       stbi__get32le(s); // discard colorsused
 4614:       stbi__get32le(s); // discard max important
 4615        if (hsz == 40 || hsz == 56) {
 4616           if (hsz == 56) {
 ....
 4628                    mb = 0xffu <<  0;
 4629                    ma = 0xffu << 24;
 4630:                   fake_a = 1; // @TODO: check for cases like alpha value is all 0 and switch it to 255
 4631                    STBI_NOTUSED(fake_a);
 4632                 } else {
 ....
 4639                 mg = stbi__get32le(s);
 4640                 mb = stbi__get32le(s);
 4641:                // not documented, but generated by photoshop and handled by mspaint
 4642                 if (mr == mg && mg == mb) {
 4643:                   // ?!?!?
 4644                    return stbi__errpuc("bad BMP", "bad BMP");
 4645                 }
 ....
 4653           mb = stbi__get32le(s);
 4654           ma = stbi__get32le(s);
 4655:          stbi__get32le(s); // discard color space
 4656           for (i=0; i < 12; ++i)
 4657:             stbi__get32le(s); // discard color space parameters
 4658           if (hsz == 124) {
 4659:             stbi__get32le(s); // discard rendering intent
 4660:             stbi__get32le(s); // discard offset of profile data
 4661:             stbi__get32le(s); // discard size of profile data
 4662:             stbi__get32le(s); // discard reserved
 4663           }
 4664        }
 ....
 4667     }
 4668     s->img_n = ma ? 4 : 3;
 4669:    if (req_comp && req_comp >= 3) // we can directly decode 3 or 4
 4670        target = req_comp;
 4671     else
 4672:       target = s->img_n; // if they want monochrome, we'll post-convert
 4673     out = (stbi_uc *) stbi__malloc(target * s->img_x * s->img_y);
 4674     if (!out) return stbi__errpuc("outofmem", "Out of memory");
 ....
 4715        if (bpp == 24) width = 3 * s->img_x;
 4716        else if (bpp == 16) width = 2*s->img_x;
 4717:       else /* bpp = 32 and pad = 0 */ width=0;
 4718        pad = (-width) & 3;
 4719        if (bpp == 24) {
 ....
 4725        if (!easy) {
 4726           if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }
 4727:          // right shift amt to put high bit in position #7
 4728           rshift = stbi__high_bit(mr)-7; rcount = stbi__bitcount(mr);
 4729           gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);
 ....
 4769     if (req_comp && req_comp != target) {
 4770        out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);
 4771:       if (out == NULL) return out; // stbi__convert_format frees input on failure
 4772     }
 4773  
 ....
 4779  #endif
 4780  
 4781: // Targa Truevision - TGA
 4782: // by Jonathan Dummer
 4783  #ifndef STBI_NO_TGA
 4784  static int stbi__tga_info(stbi__context *s, int *x, int *y, int *comp)
 ....
 4786      int tga_w, tga_h, tga_comp;
 4787      int sz;
 4788:     stbi__get8(s);                   // discard Offset
 4789:     sz = stbi__get8(s);              // color type
 4790      if( sz > 1 ) {
 4791          stbi__rewind(s);
 4792:         return 0;      // only RGB or indexed allowed
 4793      }
 4794:     sz = stbi__get8(s);              // image type
 4795:     // only RGB or grey allowed, +/- RLE
 4796      if ((sz != 1) && (sz != 2) && (sz != 3) && (sz != 9) && (sz != 10) && (sz != 11)) return 0;
 4797      stbi__skip(s,9);
 ....
 4799      if( tga_w < 1 ) {
 4800          stbi__rewind(s);
 4801:         return 0;   // test width
 4802      }
 4803      tga_h = stbi__get16le(s);
 4804      if( tga_h < 1 ) {
 4805          stbi__rewind(s);
 4806:         return 0;   // test height
 4807      }
 4808:     sz = stbi__get8(s);               // bits per pixel
 4809:     // only RGB or RGBA or grey allowed
 4810      if ((sz != 8) && (sz != 16) && (sz != 24) && (sz != 32)) {
 4811          stbi__rewind(s);
 ....
 4816      if (y) *y = tga_h;
 4817      if (comp) *comp = tga_comp / 8;
 4818:     return 1;                   // seems to have passed everything
 4819  }
 4820  
 ....
 4823     int res;
 4824     int sz;
 4825:    stbi__get8(s);      //   discard Offset
 4826:    sz = stbi__get8(s);   //   color type
 4827:    if ( sz > 1 ) return 0;   //   only RGB or indexed allowed
 4828:    sz = stbi__get8(s);   //   image type
 4829:    if ( (sz != 1) && (sz != 2) && (sz != 3) && (sz != 9) && (sz != 10) && (sz != 11) ) return 0;   //   only RGB or grey allowed, +/- RLE
 4830:    stbi__get16be(s);      //   discard palette start
 4831:    stbi__get16be(s);      //   discard palette length
 4832:    stbi__get8(s);         //   discard bits per palette color entry
 4833:    stbi__get16be(s);      //   discard x origin
 4834:    stbi__get16be(s);      //   discard y origin
 4835:    if ( stbi__get16be(s) < 1 ) return 0;      //   test width
 4836:    if ( stbi__get16be(s) < 1 ) return 0;      //   test height
 4837:    sz = stbi__get8(s);   //   bits per pixel
 4838     if ( (sz != 8) && (sz != 16) && (sz != 24) && (sz != 32) )
 4839        res = 0;
 ....
 4846  static stbi_uc *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp)
 4847  {
 4848:    //   read in the TGA header stuff
 4849     int tga_offset = stbi__get8(s);
 4850     int tga_indexed = stbi__get8(s);
 ....
 4861     int tga_comp = tga_bits_per_pixel / 8;
 4862     int tga_inverted = stbi__get8(s);
 4863:    //   image data
 4864     unsigned char *tga_data;
 4865     unsigned char *tga_palette = NULL;
 ....
 4870     int read_next_pixel = 1;
 4871  
 4872:    //   do a tiny bit of precessing
 4873     if ( tga_image_type >= 8 )
 4874     {
 ....
 4876        tga_is_RLE = 1;
 4877     }
 4878:    /* int tga_alpha_bits = tga_inverted & 15; */
 4879     tga_inverted = 1 - ((tga_inverted >> 5) & 1);
 4880  
 4881:    //   error check
 4882:    if ( //(tga_indexed) ||
 4883        (tga_width < 1) || (tga_height < 1) ||
 4884        (tga_image_type < 1) || (tga_image_type > 3) ||
 ....
 4887        )
 4888     {
 4889:       return NULL; // we don't report this as a bad TGA because we don't even know if it's TGA
 4890     }
 4891  
 4892:    //   If I'm paletted, then I'll use the number of bits from the palette
 4893     if ( tga_indexed )
 4894     {
 ....
 4896     }
 4897  
 4898:    //   tga info
 4899     *x = tga_width;
 4900     *y = tga_height;
 ....
 4904     if (!tga_data) return stbi__errpuc("outofmem", "Out of memory");
 4905  
 4906:    // skip to the data's starting position (offset usually = 0)
 4907     stbi__skip(s, tga_offset );
 4908  
 ....
 4914        }
 4915     } else  {
 4916:       //   do I need to load a palette?
 4917        if ( tga_indexed)
 4918        {
 4919:          //   any data to skip? (offset usually = 0)
 4920           stbi__skip(s, tga_palette_start );
 4921:          //   load the palette
 4922           tga_palette = (unsigned char*)stbi__malloc( tga_palette_len * tga_palette_bits / 8 );
 4923           if (!tga_palette) {
 ....
 4931           }
 4932        }
 4933:       //   load the data
 4934        for (i=0; i < tga_width * tga_height; ++i)
 4935        {
 4936:          //   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?
 4937           if ( tga_is_RLE )
 4938           {
 4939              if ( RLE_count == 0 )
 4940              {
 4941:                //   yep, get the next byte as a RLE command
 4942                 int RLE_cmd = stbi__get8(s);
 4943                 RLE_count = 1 + (RLE_cmd & 127);
 ....
 4952              read_next_pixel = 1;
 4953           }
 4954:          //   OK, if I need to read a pixel, do it now
 4955           if ( read_next_pixel )
 4956           {
 4957:             //   load however much data we did have
 4958              if ( tga_indexed )
 4959              {
 4960:                //   read in 1 byte, then perform the lookup
 4961                 int pal_idx = stbi__get8(s);
 4962                 if ( pal_idx >= tga_palette_len )
 4963                 {
 4964:                   //   invalid index
 4965                    pal_idx = 0;
 4966                 }
 ....
 4972              } else
 4973              {
 4974:                //   read in the data raw
 4975                 for (j = 0; j*8 < tga_bits_per_pixel; ++j)
 4976                 {
 ....
 4978                 }
 4979              }
 4980:             //   clear the reading flag for the next pixel
 4981              read_next_pixel = 0;
 4982:          } // end of reading a pixel
 4983  
 4984:          // copy data
 4985           for (j = 0; j < tga_comp; ++j)
 4986             tga_data[i*tga_comp+j] = raw_data[j];
 4987  
 4988:          //   in case we're in RLE mode, keep counting down
 4989           --RLE_count;
 4990        }
 4991:       //   do I need to invert the image?
 4992        if ( tga_inverted )
 4993        {
 ....
 5006           }
 5007        }
 5008:       //   clear my palette, if I had one
 5009        if ( tga_palette != NULL )
 5010        {
 ....
 5013     }
 5014  
 5015:    // swap RGB
 5016     if (tga_comp >= 3)
 5017     {
 ....
 5026     }
 5027  
 5028:    // convert to target component count
 5029     if (req_comp && req_comp != tga_comp)
 5030        tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);
 5031  
 5032:    //   the things I do to get rid of an error message, and yet keep
 5033:    //   Microsoft's C compilers happy... [8^(
 5034     tga_palette_start = tga_palette_len = tga_palette_bits =
 5035           tga_x_origin = tga_y_origin = 0;
 5036:    //   OK, done
 5037     return tga_data;
 5038  }
 5039  #endif
 5040  
 5041: // *************************************************************************************************
 5042: // Photoshop PSD loader -- PD by Thatcher Ulrich, integration by Nicolas Schulz, tweaked by STB
 5043  
 5044  #ifndef STBI_NO_PSD
 ....
 5058     stbi_uc *out;
 5059  
 5060:    // Check identifier
 5061:    if (stbi__get32be(s) != 0x38425053)   // "8BPS"
 5062        return stbi__errpuc("not PSD", "Corrupt PSD image");
 5063  
 5064:    // Check file type version.
 5065     if (stbi__get16be(s) != 1)
 5066        return stbi__errpuc("wrong version", "Unsupported version of PSD image");
 5067  
 5068:    // Skip 6 reserved bytes.
 5069     stbi__skip(s, 6 );
 5070  
 5071:    // Read the number of channels (R, G, B, A, etc).
 5072     channelCount = stbi__get16be(s);
 5073     if (channelCount < 0 || channelCount > 16)
 5074        return stbi__errpuc("wrong channel count", "Unsupported number of channels in PSD image");
 5075  
 5076:    // Read the rows and columns of the image.
 5077     h = stbi__get32be(s);
 5078     w = stbi__get32be(s);
 5079  
 5080:    // Make sure the depth is 8 bits.
 5081     if (stbi__get16be(s) != 8)
 5082        return stbi__errpuc("unsupported bit depth", "PSD bit depth is not 8 bit");
 5083  
 5084:    // Make sure the color mode is RGB.
 5085:    // Valid options are:
 5086:    //   0: Bitmap
 5087:    //   1: Grayscale
 5088:    //   2: Indexed color
 5089:    //   3: RGB color
 5090:    //   4: CMYK color
 5091:    //   7: Multichannel
 5092:    //   8: Duotone
 5093:    //   9: Lab color
 5094     if (stbi__get16be(s) != 3)
 5095        return stbi__errpuc("wrong color format", "PSD is not in RGB color format");
 5096  
 5097:    // Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)
 5098     stbi__skip(s,stbi__get32be(s) );
 5099  
 5100:    // Skip the image resources.  (resolution, pen tool paths, etc)
 5101     stbi__skip(s, stbi__get32be(s) );
 5102  
 5103:    // Skip the reserved data.
 5104     stbi__skip(s, stbi__get32be(s) );
 5105  
 5106:    // Find out if the data is compressed.
 5107:    // Known values:
 5108:    //   0: no compression
 5109:    //   1: RLE compressed
 5110     compression = stbi__get16be(s);
 5111     if (compression > 1)
 5112        return stbi__errpuc("bad compression", "PSD has an unknown compression format");
 5113  
 5114:    // Create the destination image.
 5115     out = (stbi_uc *) stbi__malloc(4 * w*h);
 5116     if (!out) return stbi__errpuc("outofmem", "Out of memory");
 5117     pixelCount = w*h;
 5118  
 5119:    // Initialize the data to zero.
 5120:    //memset( out, 0, pixelCount * 4 );
 5121  
 5122:    // Finally, the image data.
 5123     if (compression) {
 5124:       // RLE as used by .PSD and .TIFF
 5125:       // Loop until you get the number of unpacked bytes you are expecting:
 5126:       //     Read the next source byte into n.
 5127:       //     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.
 5128:       //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.
 5129:       //     Else if n is 128, noop.
 5130:       // Endloop
 5131  
 5132:       // The RLE-compressed data is preceeded by a 2-byte data count for each row in the data,
 5133:       // which we're going to just skip.
 5134        stbi__skip(s, h * channelCount * 2 );
 5135  
 5136:       // Read the RLE data by channel.
 5137        for (channel = 0; channel < 4; channel++) {
 5138           stbi_uc *p;
 ....
 5140           p = out+channel;
 5141           if (channel >= channelCount) {
 5142:             // Fill this channel with default data.
 5143              for (i = 0; i < pixelCount; i++, p += 4)
 5144                 *p = (channel == 3 ? 255 : 0);
 5145           } else {
 5146:             // Read the RLE data.
 5147              count = 0;
 5148              while (count < pixelCount) {
 5149                 len = stbi__get8(s);
 5150                 if (len == 128) {
 5151:                   // No-op.
 5152                 } else if (len < 128) {
 5153:                   // Copy next len+1 bytes literally.
 5154                    len++;
 5155                    count += len;
 ....
 5161                 } else if (len > 128) {
 5162                    stbi_uc   val;
 5163:                   // Next -len+1 bytes in the dest are replicated from next source byte.
 5164:                   // (Interpret len as a negative 8-bit int.)
 5165                    len ^= 0x0FF;
 5166                    len += 2;
 ....
 5178  
 5179     } else {
 5180:       // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)
 5181:       // where each channel consists of an 8-bit value for each pixel in the image.
 5182  
 5183:       // Read the data by channel.
 5184        for (channel = 0; channel < 4; channel++) {
 5185           stbi_uc *p;
 ....
 5187           p = out + channel;
 5188           if (channel > channelCount) {
 5189:             // Fill this channel with default data.
 5190              for (i = 0; i < pixelCount; i++, p += 4)
 5191                 *p = channel == 3 ? 255 : 0;
 5192           } else {
 5193:             // Read the data.
 5194              for (i = 0; i < pixelCount; i++, p += 4)
 5195                 *p = stbi__get8(s);
 ....
 5200     if (req_comp && req_comp != 4) {
 5201        out = stbi__convert_format(out, 4, req_comp, w, h);
 5202:       if (out == NULL) return out; // stbi__convert_format frees input on failure
 5203     }
 5204  
 ....
 5211  #endif
 5212  
 5213: // *************************************************************************************************
 5214: // Softimage PIC loader
 5215: // by Tom Seddon
 5216: //
 5217: // See http://softimage.wiki.softimage.com/index.php/INFO:_PIC_file_format
 5218: // See http://ozviz.wasp.uwa.edu.au/~pbourke/dataformats/softimagepic/
 5219  
 5220  #ifndef STBI_NO_PIC
 ....
 5278     stbi__pic_packet packets[10];
 5279  
 5280:    // this will (should...) cater for even some bizarre stuff like having data
 5281:     // for the same channel in multiple packets.
 5282     do {
 5283        stbi__pic_packet *packet;
 ....
 5299     } while (chained);
 5300  
 5301:    *comp = (act_comp & 0x10 ? 4 : 3); // has alpha channel?
 5302  
 5303     for(y=0; y<height; ++y) {
 ....
 5312                 return stbi__errpuc("bad format","packet has bad compression type");
 5313  
 5314:             case 0: {//uncompressed
 5315                 int x;
 5316  
 ....
 5321              }
 5322  
 5323:             case 1://Pure RLE
 5324                 {
 5325                    int left=width, i;
 ....
 5343                 break;
 5344  
 5345:             case 2: {//Mixed RLE
 5346                 int left=width;
 5347                 while (left>0) {
 ....
 5349                    if (stbi__at_eof(s))  return stbi__errpuc("bad file","file too short (mixed read count)");
 5350  
 5351:                   if (count >= 128) { // Repeated
 5352                       stbi_uc value[4];
 5353                       int i;
 ....
 5365                       for(i=0;i<count;++i, dest += 4)
 5366                          stbi__copyval(packet->channel,dest,value);
 5367:                   } else { // Raw
 5368                       ++count;
 5369                       if (count>left) return stbi__errpuc("bad file","scanline overrun");
 ....
 5397     if ((1 << 28) / x < y) return stbi__errpuc("too large", "Image too large to decode");
 5398  
 5399:    stbi__get32be(s); //skip `ratio'
 5400:    stbi__get16be(s); //skip `fields'
 5401:    stbi__get16be(s); //skip `pad'
 5402  
 5403:    // intermediate buffer is RGBA
 5404     result = (stbi_uc *) stbi__malloc(x*y*4);
 5405     memset(result, 0xff, x*y*4);
 ....
 5425  #endif
 5426  
 5427: // *************************************************************************************************
 5428: // GIF loader -- public domain by Jean-Marc Lienher -- simplified/shrunk by stb
 5429  
 5430  #ifndef STBI_NO_GIF
 ....
 5439  {
 5440     int w,h;
 5441:    stbi_uc *out;                 // output buffer (always 4 components)
 5442     int flags, bgindex, ratio, transparent, eflags;
 5443     stbi_uc  pal[256][4];
 ....
 5499     g->transparent = -1;
 5500  
 5501:    if (comp != 0) *comp = 4;  // can't actually tell whether it's 3 or 4 until we parse the comments
 5502  
 5503     if (is_info) return 1;
 ....
 5525     stbi_uc *p, *c;
 5526  
 5527:    // recurse to decode the prefixes, since the linked-list is backwards,
 5528:    // and working backwards through an interleaved image would be nasty
 5529     if (g->codes[code].prefix >= 0)
 5530        stbi__out_gif_code(g, g->codes[code].prefix);
 ....
 5577     }
 5578  
 5579:    // support no starting clear code
 5580     avail = clear+2;
 5581     oldcode = -1;
 ....
 5585        if (valid_bits < codesize) {
 5586           if (len == 0) {
 5587:             len = stbi__get8(s); // start new block
 5588              if (len == 0)
 5589                 return g->out;
 ....
 5596           bits >>= codesize;
 5597           valid_bits -= codesize;
 5598:          // @OPTIMIZE: is there some way we can accelerate the non-clear path?
 5599:          if (code == clear) {  // clear code
 5600              codesize = lzw_cs + 1;
 5601              codemask = (1 << codesize) - 1;
 ....
 5603              oldcode = -1;
 5604              first = 0;
 5605:          } else if (code == clear + 1) { // end of stream code
 5606              stbi__skip(s, len);
 5607              while ((len = stbi__get8(s)) > 0)
 ....
 5639     int i;
 5640     stbi_uc *c = g->pal[g->bgindex];
 5641:    // @OPTIMIZE: write a dword at a time
 5642     for (i = 0; i < g->w * g->h * 4; i += 4) {
 5643        stbi_uc *p  = &g->out[i];
 ....
 5649  }
 5650  
 5651: // this function is designed to support animated gifs, although stb_image doesn't support it
 5652  static stbi_uc *stbi__gif_load_next(stbi__context *s, stbi__gif *g, int *comp, int req_comp)
 5653  {
 ....
 5656  
 5657     if (g->out == 0) {
 5658:       if (!stbi__gif_header(s, g, comp,0))     return 0; // stbi__g_failure_reason set by stbi__gif_header
 5659        g->out = (stbi_uc *) stbi__malloc(4 * g->w * g->h);
 5660        if (g->out == 0)                      return stbi__errpuc("outofmem", "Out of memory");
 5661        stbi__fill_gif_background(g);
 5662     } else {
 5663:       // animated-gif-only path
 5664        if (((g->eflags & 0x1C) >> 2) == 3) {
 5665           old_out = g->out;
 ....
 5672     for (;;) {
 5673        switch (stbi__get8(s)) {
 5674:          case 0x2C: /* Image Descriptor */
 5675           {
 5676              stbi__int32 x, y, w, h;
 ....
 5695  
 5696              if (g->lflags & 0x40) {
 5697:                g->step = 8 * g->line_size; // first interlaced spacing
 5698                 g->parse = 3;
 5699              } else {
 ....
 5706                 g->color_table = (stbi_uc *) g->lpal;
 5707              } else if (g->flags & 0x80) {
 5708:                for (i=0; i < 256; ++i)  // @OPTIMIZE: stbi__jpeg_reset only the previous transparent
 5709                    g->pal[i][3] = 255;
 5710                 if (g->transparent >= 0 && (g->eflags & 0x01))
 ....
 5722           }
 5723  
 5724:          case 0x21: // Comment Extension.
 5725           {
 5726              int len;
 5727:             if (stbi__get8(s) == 0xF9) { // Graphic Control Extension.
 5728                 len = stbi__get8(s);
 5729                 if (len == 4) {
 5730                    g->eflags = stbi__get8(s);
 5731:                   stbi__get16le(s); // delay
 5732                    g->transparent = stbi__get8(s);
 5733                 } else {
 ....
 5741           }
 5742  
 5743:          case 0x3B: // gif stream termination code
 5744:             return (stbi_uc *) s; // using '1' causes warning on some compilers
 5745  
 5746           default:
 ....
 5757  
 5758     u = stbi__gif_load_next(s, &g, comp, req_comp);
 5759:    if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker
 5760     if (u) {
 5761        *x = g.w;
 ....
 5772  #endif
 5773  
 5774: // *************************************************************************************************
 5775: // Radiance RGBE HDR loader
 5776: // originally by Nicolas Schulz
 5777  #ifndef STBI_NO_HDR
 5778  static int stbi__hdr_test_core(stbi__context *s)
 ....
 5804        buffer[len++] = c;
 5805        if (len == STBI__HDR_BUFLEN-1) {
 5806:          // flush to end of line
 5807           while (!stbi__at_eof(z) && stbi__get8(z) != '\n')
 5808              ;
 ....
 5820     if ( input[3] != 0 ) {
 5821        float f1;
 5822:       // Exponent
 5823        f1 = (float) ldexp(1.0f, input[3] - (int)(128 + 8));
 5824        if (req_comp <= 2)
 ....
 5833     } else {
 5834        switch (req_comp) {
 5835:          case 4: output[3] = 1; /* fallthrough */
 5836           case 3: output[0] = output[1] = output[2] = 0;
 5837                   break;
 5838:          case 2: output[1] = 1; /* fallthrough */
 5839           case 1: output[0] = 0;
 5840                   break;
 ....
 5856  
 5857  
 5858:    // Check identifier
 5859     if (strcmp(stbi__hdr_gettoken(s,buffer), "#?RADIANCE") != 0)
 5860        return stbi__errpf("not HDR", "Corrupt HDR image");
 5861  
 5862:    // Parse header
 5863     for(;;) {
 5864        token = stbi__hdr_gettoken(s,buffer);
 ....
 5869     if (!valid)    return stbi__errpf("unsupported format", "Unsupported HDR format");
 5870  
 5871:    // Parse width and height
 5872:    // can't use sscanf() if we're not using stdio!
 5873     token = stbi__hdr_gettoken(s,buffer);
 5874     if (strncmp(token, "-Y ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");
 ....
 5886     if (req_comp == 0) req_comp = 3;
 5887  
 5888:    // Read data
 5889     hdr_data = (float *) stbi__malloc(height * width * req_comp * sizeof(float));
 5890  
 5891:    // Load image data
 5892:    // image data is stored as some number of sca
 5893     if ( width < 8 || width >= 32768) {
 5894:       // Read flat data
 5895        for (j=0; j < height; ++j) {
 5896           for (i=0; i < width; ++i) {
 ....
 5902        }
 5903     } else {
 5904:       // Read RLE-encoded data
 5905        scanline = NULL;
 5906  
 ....
 5910           len = stbi__get8(s);
 5911           if (c1 != 2 || c2 != 2 || (len & 0x80)) {
 5912:             // not run-length encoded, so we have to actually use THIS data as a decoded
 5913:             // pixel (note this can't be a valid pixel--one of RGB must be >= 128)
 5914              stbi_uc rgbe[4];
 5915              rgbe[0] = (stbi_uc) c1;
 ....
 5921              j = 0;
 5922              STBI_FREE(scanline);
 5923:             goto main_decode_loop; // yes, this makes no sense
 5924           }
 5925           len <<= 8;
 ....
 5933                 count = stbi__get8(s);
 5934                 if (count > 128) {
 5935:                   // Run
 5936                    value = stbi__get8(s);
 5937                    count -= 128;
 ....
 5939                       scanline[i++ * 4 + k] = value;
 5940                 } else {
 5941:                   // Dump
 5942                    for (z = 0; z < count; ++z)
 5943                       scanline[i++ * 4 + k] = stbi__get8(s);
 ....
 5992     return 1;
 5993  }
 5994: #endif // STBI_NO_HDR
 5995  
 5996  #ifndef STBI_NO_BMP
 ....
 6104  #endif
 6105  
 6106: // *************************************************************************************************
 6107: // Portable Gray Map and Portable Pixel Map loader
 6108: // by Ken Miller
 6109: //
 6110: // PGM: http://netpbm.sourceforge.net/doc/pgm.html
 6111: // PPM: http://netpbm.sourceforge.net/doc/ppm.html
 6112: //
 6113: // Known limitations:
 6114: //    Does not support comments in the header section
 6115: //    Does not support ASCII image data (formats P2 and P3)
 6116: //    Does not support 16-bit-per-channel
 6117  
 6118  #ifndef STBI_NO_PNM
 ....
 6145     if (req_comp && req_comp != s->img_n) {
 6146        out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);
 6147:       if (out == NULL) return out; // stbi__convert_format frees input on failure
 6148     }
 6149     return out;
 ....
 6185     stbi__rewind( s );
 6186  
 6187:    // Get identifier
 6188     p = (char) stbi__get8(s);
 6189     t = (char) stbi__get8(s);
 ....
 6193     }
 6194  
 6195:    *comp = (t == '6') ? 3 : 1;  // '5' is 1-component .pgm; '6' is 3-component .ppm
 6196  
 6197     c = (char) stbi__get8(s);
 6198     stbi__pnm_skip_whitespace(s, &c);
 6199  
 6200:    *x = stbi__pnm_getinteger(s, &c); // read width
 6201     stbi__pnm_skip_whitespace(s, &c);
 6202  
 6203:    *y = stbi__pnm_getinteger(s, &c); // read height
 6204     stbi__pnm_skip_whitespace(s, &c);
 6205  
 6206:    maxv = stbi__pnm_getinteger(s, &c);  // read max value
 6207  
 6208     if (maxv > 255)
 ....
 6247     #endif
 6248  
 6249:    // test tga last because it's a crappy test!
 6250     #ifndef STBI_NO_TGA
 6251     if (stbi__tga_info(s, x, y, comp))
 ....
 6276     return r;
 6277  }
 6278: #endif // !STBI_NO_STDIO
 6279  
 6280  STBIDEF int stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp)
 ....
 6292  }
 6293  
 6294: #endif // STB_IMAGE_IMPLEMENTATION
 6295  
 6296: /*
 6297:    revision history:
 6298:       2.06  (2015-04-19) fix bug where PSD returns wrong '*comp' value
 6299:       2.05  (2015-04-19) fix bug in progressive JPEG handling, fix warning
 6300:       2.04  (2015-04-15) try to re-enable SIMD on MinGW 64-bit
 6301:       2.03  (2015-04-12) extra corruption checking (mmozeiko)
 6302:                          stbi_set_flip_vertically_on_load (nguillemot)
 6303:                          fix NEON support; fix mingw support
 6304:       2.02  (2015-01-19) fix incorrect assert, fix warning
 6305:       2.01  (2015-01-17) fix various warnings; suppress SIMD on gcc 32-bit without -msse2
 6306:       2.00b (2014-12-25) fix STBI_MALLOC in progressive JPEG
 6307:       2.00  (2014-12-25) optimize JPG, including x86 SSE2 & NEON SIMD (ryg)
 6308:                          progressive JPEG (stb)
 6309:                          PGM/PPM support (Ken Miller)
 6310:                          STBI_MALLOC,STBI_REALLOC,STBI_FREE
 6311:                          GIF bugfix -- seemingly never worked
 6312:                          STBI_NO_*, STBI_ONLY_*
 6313:       1.48  (2014-12-14) fix incorrectly-named assert()
 6314:       1.47  (2014-12-14) 1/2/4-bit PNG support, both direct and paletted (Omar Cornut & stb)
 6315:                          optimize PNG (ryg)
 6316:                          fix bug in interlaced PNG with user-specified channel count (stb)
 6317:       1.46  (2014-08-26)
 6318:               fix broken tRNS chunk (colorkey-style transparency) in non-paletted PNG
 6319:       1.45  (2014-08-16)
 6320:               fix MSVC-ARM internal compiler error by wrapping malloc
 6321:       1.44  (2014-08-07)
 6322:               various warning fixes from Ronny Chevalier
 6323:       1.43  (2014-07-15)
 6324:               fix MSVC-only compiler problem in code changed in 1.42
 6325:       1.42  (2014-07-09)
 6326:               don't define _CRT_SECURE_NO_WARNINGS (affects user code)
 6327:               fixes to stbi__cleanup_jpeg path
 6328:               added STBI_ASSERT to avoid requiring assert.h
 6329:       1.41  (2014-06-25)
 6330:               fix search&replace from 1.36 that messed up comments/error messages
 6331:       1.40  (2014-06-22)
 6332:               fix gcc struct-initialization warning
 6333:       1.39  (2014-06-15)
 6334:               fix to TGA optimization when req_comp != number of components in TGA;
 6335:               fix to GIF loading because BMP wasn't rewinding (whoops, no GIFs in my test suite)
 6336:               add support for BMP version 5 (more ignored fields)
 6337:       1.38  (2014-06-06)
 6338:               suppress MSVC warnings on integer casts truncating values
 6339:               fix accidental rename of 'skip' field of I/O
 6340:       1.37  (2014-06-04)
 6341:               remove duplicate typedef
 6342:       1.36  (2014-06-03)
 6343:               convert to header file single-file library
 6344:               if de-iphone isn't set, load iphone images color-swapped instead of returning NULL
 6345:       1.35  (2014-05-27)
 6346:               various warnings
 6347:               fix broken STBI_SIMD path
 6348:               fix bug where stbi_load_from_file no longer left file pointer in correct place
 6349:               fix broken non-easy path for 32-bit BMP (possibly never used)
 6350:               TGA optimization by Arseny Kapoulkine
 6351:       1.34  (unknown)
 6352:               use STBI_NOTUSED in stbi__resample_row_generic(), fix one more leak in tga failure case
 6353:       1.33  (2011-07-14)
 6354:               make stbi_is_hdr work in STBI_NO_HDR (as specified), minor compiler-friendly improvements
 6355:       1.32  (2011-07-13)
 6356:               support for "info" function for all supported filetypes (SpartanJ)
 6357:       1.31  (2011-06-20)
 6358:               a few more leak fixes, bug in PNG handling (SpartanJ)
 6359:       1.30  (2011-06-11)
 6360:               added ability to load files via callbacks to accomidate custom input streams (Ben Wenger)
 6361:               removed deprecated format-specific test/load functions
 6362:               removed support for installable file formats (stbi_loader) -- would have been broken for IO callbacks anyway
 6363:               error cases in bmp and tga give messages and don't leak (Raymond Barbiero, grisha)
 6364:               fix inefficiency in decoding 32-bit BMP (David Woo)
 6365:       1.29  (2010-08-16)
 6366:               various warning fixes from Aurelien Pocheville
 6367:       1.28  (2010-08-01)
 6368:               fix bug in GIF palette transparency (SpartanJ)
 6369:       1.27  (2010-08-01)
 6370:               cast-to-stbi_uc to fix warnings
 6371:       1.26  (2010-07-24)
 6372:               fix bug in file buffering for PNG reported by SpartanJ
 6373:       1.25  (2010-07-17)
 6374:               refix trans_data warning (Won Chun)
 6375:       1.24  (2010-07-12)
 6376:               perf improvements reading from files on platforms with lock-heavy fgetc()
 6377:               minor perf improvements for jpeg
 6378:               deprecated type-specific functions so we'll get feedback if they're needed
 6379:               attempt to fix trans_data warning (Won Chun)
 6380:       1.23    fixed bug in iPhone support
 6381:       1.22  (2010-07-10)
 6382:               removed image *writing* support
 6383:               stbi_info support from Jetro Lauha
 6384:               GIF support from Jean-Marc Lienher
 6385:               iPhone PNG-extensions from James Brown
 6386:               warning-fixes from Nicolas Schulz and Janez Zemva (i.stbi__err. Janez (U+017D)emva)
 6387:       1.21    fix use of 'stbi_uc' in header (reported by jon blow)
 6388:       1.20    added support for Softimage PIC, by Tom Seddon
 6389:       1.19    bug in interlaced PNG corruption check (found by ryg)
 6390:       1.18  (2008-08-02)
 6391:               fix a threading bug (local mutable static)
 6392:       1.17    support interlaced PNG
 6393:       1.16    major bugfix - stbi__convert_format converted one too many pixels
 6394:       1.15    initialize some fields for thread safety
 6395:       1.14    fix threadsafe conversion bug
 6396:               header-file-only version (#define STBI_HEADER_FILE_ONLY before including)
 6397:       1.13    threadsafe
 6398:       1.12    const qualifiers in the API
 6399:       1.11    Support installable IDCT, colorspace conversion routines
 6400:       1.10    Fixes for 64-bit (don't use "unsigned long")
 6401:               optimized upsampling by Fabian "ryg" Giesen
 6402:       1.09    Fix format-conversion for PSD code (bad global variables!)
 6403:       1.08    Thatcher Ulrich's PSD code integrated by Nicolas Schulz
 6404:       1.07    attempt to fix C++ warning/errors again
 6405:       1.06    attempt to fix C++ warning/errors again
 6406:       1.05    fix TGA loading to return correct *comp and use good luminance calc
 6407:       1.04    default float alpha is 1, not 255; use 'void *' for stbi_image_free
 6408:       1.03    bugfixes to STBI_NO_STDIO, STBI_NO_HDR
 6409:       1.02    support for (subset of) HDR files, float interface for preferred access to them
 6410:       1.01    fix bug: possible bug in handling right-side up bmps... not sure
 6411:               fix bug: the stbi__bmp_load() and stbi__tga_load() functions didn't work at all
 6412:       1.00    interface to zlib that skips zlib header
 6413:       0.99    correct handling of alpha in palette
 6414:       0.98    TGA loader by lonesock; dynamically add loaders (untested)
 6415:       0.97    jpeg errors on too large a file; also catch another malloc failure
 6416:       0.96    fix detection of invalid v value - particleman@mollyrocket forum
 6417:       0.95    during header scan, seek to markers in case of padding
 6418:       0.94    STBI_NO_STDIO to disable stdio usage; rename all #defines the same
 6419:       0.93    handle jpegtran output; verbose errors
 6420:       0.92    read 4,8,16,24,32-bit BMP files of several formats
 6421:       0.91    output 24-bit Windows 3.0 BMP files
 6422:       0.90    fix a few more warnings; bump version number to approach 1.0
 6423:       0.61    bugfixes due to Marc LeBlanc, Christopher Lloyd
 6424:       0.60    fix compiling as c++
 6425:       0.59    fix warnings: merge Dave Moore's -Wall fixes
 6426:       0.58    fix bug: zlib uncompressed mode len/nlen was wrong endian
 6427:       0.57    fix bug: jpg last huffman symbol before marker was >9 bits but less than 16 available
 6428:       0.56    fix bug: zlib uncompressed mode len vs. nlen
 6429:       0.55    fix bug: restart_interval not initialized to 0
 6430:       0.54    allow NULL for 'int *comp'
 6431:       0.53    fix bug in png 3->4; speedup png decoding
 6432:       0.52    png handles req_comp=3,4 directly; minor cleanup; jpeg comments
 6433:       0.51    obey req_comp requests, 1-component jpegs return as 1-component,
 6434:               on 'test' only check type, not whether we support this variant
 6435:       0.50  (2006-11-19)
 6436:               first released version
 6437: */
 6438  

/Users/anthonybudd/Development/darknet/src/stb_image_write.h:
    1: /* stb_image_write - v0.98 - public domain - http://nothings.org/stb/stb_image_write.h
    2:    writes out PNG/BMP/TGA images to C stdio - Sean Barrett 2010
    3:                             no warranty implied; use at your own risk
    4: 
    5: 
    6:    Before #including,
    7: 
    8:        #define STB_IMAGE_WRITE_IMPLEMENTATION
    9: 
   10:    in the file that you want to have the implementation.
   11: 
   12:    Will probably not work correctly with strict-aliasing optimizations.
   13: 
   14: ABOUT:
   15: 
   16:    This header file is a library for writing images to C stdio. It could be
   17:    adapted to write to memory or a general streaming interface; let me know.
   18: 
   19:    The PNG output is not optimal; it is 20-50% larger than the file
   20:    written by a decent optimizing implementation. This library is designed
   21:    for source code compactness and simplicitly, not optimal image file size
   22:    or run-time performance.
   23: 
   24: BUILDING:
   25: 
   26:    You can #define STBIW_ASSERT(x) before the #include to avoid using assert.h.
   27:    You can #define STBIW_MALLOC(), STBIW_REALLOC(), and STBIW_FREE() to replace
   28:    malloc,realloc,free.
   29:    You can define STBIW_MEMMOVE() to replace memmove()
   30: 
   31: USAGE:
   32: 
   33:    There are four functions, one for each image file format:
   34: 
   35:      int stbi_write_png(char const *filename, int w, int h, int comp, const void *data, int stride_in_bytes);
   36:      int stbi_write_bmp(char const *filename, int w, int h, int comp, const void *data);
   37:      int stbi_write_tga(char const *filename, int w, int h, int comp, const void *data);
   38:      int stbi_write_hdr(char const *filename, int w, int h, int comp, const void *data);
   39: 
   40:    Each function returns 0 on failure and non-0 on success.
   41: 
   42:    The functions create an image file defined by the parameters. The image
   43:    is a rectangle of pixels stored from left-to-right, top-to-bottom.
   44:    Each pixel contains 'comp' channels of data stored interleaved with 8-bits
   45:    per channel, in the following order: 1=Y, 2=YA, 3=RGB, 4=RGBA. (Y is
   46:    monochrome color.) The rectangle is 'w' pixels wide and 'h' pixels tall.
   47:    The *data pointer points to the first byte of the top-left-most pixel.
   48:    For PNG, "stride_in_bytes" is the distance in bytes from the first byte of
   49:    a row of pixels to the first byte of the next row of pixels.
   50: 
   51:    PNG creates output files with the same number of components as the input.
   52:    The BMP format expands Y to RGB in the file format and does not
   53:    output alpha.
   54: 
   55:    PNG supports writing rectangles of data even when the bytes storing rows of
   56:    data are not consecutive in memory (e.g. sub-rectangles of a larger image),
   57:    by supplying the stride between the beginning of adjacent rows. The other
   58:    formats do not. (Thus you cannot write a native-format BMP through the BMP
   59:    writer, both because it is in BGR order and because it may have padding
   60:    at the end of the line.)
   61: 
   62:    HDR expects linear float data. Since the format is always 32-bit rgb(e)
   63:    data, alpha (if provided) is discarded, and for monochrome data it is
   64:    replicated across all three channels.
   65: 
   66: CREDITS:
   67: 
   68:    PNG/BMP/TGA
   69:       Sean Barrett
   70:    HDR
   71:       Baldur Karlsson
   72:    TGA monochrome:
   73:       Jean-Sebastien Guay
   74:    misc enhancements:
   75:       Tim Kelsey
   76:    bugfixes:
   77:       github:Chribba
   78: */
   79  
   80  #ifndef INCLUDE_STB_IMAGE_WRITE_H
   ..
   94  #endif
   95  
   96: #endif//INCLUDE_STB_IMAGE_WRITE_H
   97  
   98  #ifdef STB_IMAGE_WRITE_IMPLEMENTATION
   ..
  105  
  106  #if defined(STBIW_MALLOC) && defined(STBIW_FREE) && defined(STBIW_REALLOC)
  107: // ok
  108  #elif !defined(STBIW_MALLOC) && !defined(STBIW_FREE) && !defined(STBIW_REALLOC)
  109: // ok
  110  #else
  111  #error "Must define all or none of STBIW_MALLOC, STBIW_FREE, and STBIW_REALLOC."
  ...
  180                      break;
  181              case 2: if (expand_mono)
  182:                        write3(f, d[0],d[0],d[0]); // monochrome bmp
  183                      else
  184:                        fwrite(d, 1, 1, f);  // monochrome TGA
  185                      break;
  186              case 4:
  187                 if (!write_alpha) {
  188:                   // composite against pink background
  189                    for (k=0; k < 3; ++k)
  190                       px[k] = bg[k] + ((d[k] - bg[k]) * d[3])/255;
  ...
  192                    break;
  193                 }
  194:                /* FALLTHROUGH */
  195              case 3:
  196                 write3(f, d[1-rgb_dir],d[1],d[1+rgb_dir]);
  ...
  225     return outfile(filename,-1,-1,x,y,comp,1,(void *) data,0,pad,
  226             "11 4 22 4" "4 44 22 444444",
  227:            'B', 'M', 14+40+(x*3+pad)*y, 0,0, 14+40,  // file header
  228:             40, x,y, 1,24, 0,0,0,0,0,0);             // bitmap header
  229  }
  230  
  ...
  233     int has_alpha = (comp == 2 || comp == 4);
  234     int colorbytes = has_alpha ? comp-1 : comp;
  235:    int format = colorbytes < 2 ? 3 : 2; // 3 color channels (RGB/RGBA) = 2, 1 color channel (Y/YA) = 3
  236     return outfile(filename, -1,-1, x, y, comp, 0, (void *) data, has_alpha, 0,
  237                    "111 221 2222 11", 0,0,format, 0,0,0, 0,0,x,y, (colorbytes+has_alpha)*8, has_alpha*8);
  238  }
  239  
  240: // *************************************************************************************************
  241: // Radiance RGBE HDR writer
  242: // by Baldur Karlsson
  243  #define stbiw__max(a, b)  ((a) > (b) ? (a) : (b))
  244  
  ...
  271  {
  272     unsigned char lengthbyte = (unsigned char )(length & 0xff);
  273:    STBIW_ASSERT(length <= 128); // inconsistent with spec but consistent with official code
  274     fwrite(&lengthbyte, 1, 1, f);
  275     fwrite(data, length, 1, f);
  ...
  286     scanlineheader[3] = (width&0x00ff);
  287  
  288:    /* skip RLE for images too small or large */
  289     if (width < 8 || width >= 32768) {
  290        for (x=0; x < width; x++) {
  291           switch (comp) {
  292:             case 4: /* fallthrough */
  293              case 3: linear[2] = scanline[x*comp + 2];
  294                      linear[1] = scanline[x*comp + 1];
  295                      linear[0] = scanline[x*comp + 0];
  296                      break;
  297:             case 2: /* fallthrough */
  298              case 1: linear[0] = linear[1] = linear[2] = scanline[x*comp + 0];
  299                      break;
  ...
  304     } else {
  305        int c,r;
  306:       /* encode into scratch buffer */
  307        for (x=0; x < width; x++) {
  308           switch(comp) {
  309:             case 4: /* fallthrough */
  310              case 3: linear[2] = scanline[x*comp + 2];
  311                      linear[1] = scanline[x*comp + 1];
  312                      linear[0] = scanline[x*comp + 0];
  313                      break;
  314:             case 2: /* fallthrough */
  315              case 1: linear[0] = linear[1] = linear[2] = scanline[x*comp + 0];
  316                      break;
  ...
  325        fwrite(scanlineheader, 4, 1, f);
  326  
  327:       /* RLE each component separately */
  328        for (c=0; c < 4; c++) {
  329           unsigned char *comp = &scratch[width*c];
  ...
  331           x = 0;
  332           while (x < width) {
  333:             // find first run
  334              r = x;
  335              while (r+2 < width) {
  ...
  340              if (r+2 >= width)
  341                 r = width;
  342:             // dump up to first run
  343              while (x < r) {
  344                 int len = r-x;
  ...
  347                 x += len;
  348              }
  349:             // if there's a run, output it
  350:             if (r+2 < width) { // same test as what we break out of in search loop, so only true if we break'd
  351:                // find next byte after run
  352                 while (r < width && comp[r] == comp[x])
  353                    ++r;
  354:                // output run up to r
  355                 while (x < r) {
  356                    int len = r-x;
  ...
  372     f = fopen(filename, "wb");
  373     if (f) {
  374:       /* Each component is stored separately. Allocate scratch space for full output scanline. */
  375        unsigned char *scratch = (unsigned char *) STBIW_MALLOC(x*4);
  376        fprintf(f, "#?RADIANCE\n# Written by stb_image_write.h\nFORMAT=32-bit_rle_rgbe\n"      );
  ...
  384  }
  385  
  386: /////////////////////////////////////////////////////////
  387: // PNG
  388  
  389: // stretchy buffer; stbiw__sbpush() == vector<>::push_back() -- stbiw__sbcount() == vector<>::size()
  390  #define stbiw__sbraw(a) ((int *) (a) - 2)
  391  #define stbiw__sbm(a)   stbiw__sbraw(a)[0]
  ...
  457        (bitbuf |= (code) << bitcount, bitcount += (codebits), stbiw__zlib_flush())
  458  #define stbiw__zlib_huffa(b,c)  stbiw__zlib_add(stbiw__zlib_bitrev(b,c),c)
  459: // default huffman tables
  460  #define stbiw__zlib_huff1(n)  stbiw__zlib_huffa(0x30 + (n), 8)
  461  #define stbiw__zlib_huff2(n)  stbiw__zlib_huffa(0x190 + (n)-144, 9)
  ...
  476     int i,j, bitcount=0;
  477     unsigned char *out = NULL;
  478:    unsigned char **hash_table[stbiw__ZHASH]; // 64KB on the stack!
  479     if (quality < 5) quality = 5;
  480  
  481:    stbiw__sbpush(out, 0x78);   // DEFLATE 32K window
  482:    stbiw__sbpush(out, 0x5e);   // FLEVEL = 1
  483:    stbiw__zlib_add(1,1);  // BFINAL = 1
  484:    stbiw__zlib_add(1,2);  // BTYPE = 1 -- fixed huffman
  485  
  486     for (i=0; i < stbiw__ZHASH; ++i)
  ...
  489     i=0;
  490     while (i < data_len-3) {
  491:       // hash next 3 bytes of data to be compressed
  492        int h = stbiw__zhash(data+i)&(stbiw__ZHASH-1), best=3;
  493        unsigned char *bestloc = 0;
  ...
  495        int n = stbiw__sbcount(hlist);
  496        for (j=0; j < n; ++j) {
  497:          if (hlist[j]-data > i-32768) { // if entry lies within window
  498              int d = stbiw__zlib_countm(hlist[j], data+i, data_len-i);
  499              if (d >= best) best=d,bestloc=hlist[j];
  500           }
  501        }
  502:       // when hash table entry is too long, delete half the entries
  503        if (hash_table[h] && stbiw__sbn(hash_table[h]) == 2*quality) {
  504           STBIW_MEMMOVE(hash_table[h], hash_table[h]+quality, sizeof(hash_table[h][0])*quality);
  ...
  508  
  509        if (bestloc) {
  510:          // "lazy matching" - check match at *next* byte, and if it's better, do cur byte as literal
  511           h = stbiw__zhash(data+i+1)&(stbiw__ZHASH-1);
  512           hlist = hash_table[h];
  ...
  515              if (hlist[j]-data > i-32767) {
  516                 int e = stbiw__zlib_countm(hlist[j], data+i+1, data_len-i-1);
  517:                if (e > best) { // if next match is better, bail on current match
  518                    bestloc = NULL;
  519                    break;
  ...
  524  
  525        if (bestloc) {
  526:          int d = (int) (data+i - bestloc); // distance back
  527           STBIW_ASSERT(d <= 32767 && best <= 258);
  528           for (j=0; best > lengthc[j+1]-1; ++j);
  ...
  538        }
  539     }
  540:    // write out final bytes
  541     for (;i < data_len; ++i)
  542        stbiw__zlib_huffb(data[i]);
  543:    stbiw__zlib_huff(256); // end of block
  544:    // pad with 0 bits to byte boundary
  545     while (bitcount)
  546        stbiw__zlib_add(0,1);
  ...
  550  
  551     {
  552:       // compute adler32 on input
  553        unsigned int i=0, s1=1, s2=0, blocklen = data_len % 5552;
  554        int j=0;
  ...
  565     }
  566     *out_len = stbiw__sbn(out);
  567:    // make returned pointer freeable
  568     STBIW_MEMMOVE(stbiw__sbraw(out), out, *out_len);
  569     return (unsigned char *) stbiw__sbraw(out);
  ...
  651           }
  652        }
  653:       // when we get here, best contains the filter type, and line_buffer contains the data
  654        filt[j*(x*n+1)] = (unsigned char) best;
  655        STBIW_MEMMOVE(filt+j*(x*n+1)+1, line_buffer, x*n);
  656     }
  657     STBIW_FREE(line_buffer);
  658:    zlib = stbi_zlib_compress(filt, y*( x*n+1), &zlen, 8); // increase 8 to get smaller but use more memory
  659     STBIW_FREE(filt);
  660     if (!zlib) return 0;
  661  
  662:    // each tag requires 12 bytes of overhead
  663     out = (unsigned char *) STBIW_MALLOC(8 + 12+13 + 12+zlen + 12);
  664     if (!out) return 0;
  ...
  667     o=out;
  668     STBIW_MEMMOVE(o,sig,8); o+= 8;
  669:    stbiw__wp32(o, 13); // header length
  670     stbiw__wptag(o, "IHDR");
  671     stbiw__wp32(o, x);
  ...
  707     return 1;
  708  }
  709: #endif // STB_IMAGE_WRITE_IMPLEMENTATION
  710  
  711: /* Revision history
  712:       0.98 (2015-04-08)
  713:              added STBIW_MALLOC, STBIW_ASSERT etc
  714:       0.97 (2015-01-18)
  715:              fixed HDR asserts, rewrote HDR rle logic
  716:       0.96 (2015-01-17)
  717:              add HDR output
  718:              fix monochrome BMP
  719:       0.95 (2014-08-17)
  720: 		       add monochrome TGA output
  721:       0.94 (2014-05-31)
  722:              rename private functions to avoid conflicts with stb_image.h
  723:       0.93 (2014-05-27)
  724:              warning fixes
  725:       0.92 (2010-08-01)
  726:              casts to unsigned char to fix warnings
  727:       0.91 (2010-07-17)
  728:              first public release
  729:       0.90   first internal release
  730: */
  731  

/Users/anthonybudd/Development/darknet/src/super.c:
   27  
   28      list *plist = get_paths(train_images);
   29:     //int N = plist->size;
   30      char **paths = (char **)list_to_array(plist);
   31  
   ..
   42      pthread_t load_thread = load_data_in_thread(args);
   43      clock_t time;
   44:     //while(i*imgs < N*120){
   45      while(get_current_batch(net) < net.max_batches){
   46          i += 1;
   ..
  126      if(0==strcmp(argv[2], "train")) train_super(cfg, weights);
  127      else if(0==strcmp(argv[2], "test")) test_super(cfg, weights, filename);
  128:     /*
  129:     else if(0==strcmp(argv[2], "valid")) validate_super(cfg, weights);
  130:     */
  131  }
  132  

/Users/anthonybudd/Development/darknet/src/swag.c:
   34  
   35      list *plist = get_paths(train_images);
   36:     //int N = plist->size;
   37      char **paths = (char **)list_to_array(plist);
   38  
   ..
   51      pthread_t load_thread = load_data_in_thread(args);
   52      clock_t time;
   53:     //while(i*imgs < N*120){
   54      while(get_current_batch(net) < net.max_batches){
   55          i += 1;

/Users/anthonybudd/Development/darknet/src/tree.c:
  133      tree *tree_ptr = calloc(1, sizeof(tree));
  134      *tree_ptr = t;
  135:     //error(0);
  136      return tree_ptr;
  137  }

/Users/anthonybudd/Development/darknet/src/utils.c:
  157  
  158      sprintf(buffer, "%s", str);
  159:     if(!(p = strstr(buffer, orig))){  // Is 'orig' even in 'str'?
  160          sprintf(output, "%s", str);
  161          return;
  ...
  391              field[count] = strtod(p, &end);
  392              if(p == c) field[count] = nan("");
  393:             if(end != c && (end != c-1 || *end != '\r')) field[count] = nan(""); //DOS file formats!
  394              p = c+1;
  395              ++count;
  ...
  550  }
  551  
  552: // From http://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform
  553  float rand_normal()
  554  {
  ...
  572  }
  573  
  574: /*
  575:    float rand_normal()
  576:    {
  577:    int n = 12;
  578:    int i;
  579:    float sum= 0;
  580:    for(i = 0; i < n; ++i) sum += (float)rand()/RAND_MAX;
  581:    return sum-n/2.;
  582:    }
  583:  */
  584  
  585  size_t rand_size_t()

/Users/anthonybudd/Development/darknet/src/voxel.c:
   64  
   65      list *plist = get_paths(train_images);
   66:     //int N = plist->size;
   67      char **paths = (char **)list_to_array(plist);
   68  
   ..
   79      pthread_t load_thread = load_data_in_thread(args);
   80      clock_t time;
   81:     //while(i*imgs < N*120){
   82      while(get_current_batch(net) < net.max_batches){
   83          i += 1;
   ..
  164      else if(0==strcmp(argv[2], "test")) test_voxel(cfg, weights, filename);
  165      else if(0==strcmp(argv[2], "extract")) extract_voxel(argv[3], argv[4], argv[5]);
  166:     /*
  167:        else if(0==strcmp(argv[2], "valid")) validate_voxel(cfg, weights);
  168:      */
  169  }
  170  

/Users/anthonybudd/Development/darknet/src/writing.c:
   52          float loss = train_network(net, train);
   53  
   54:         /*
   55:            image pred = float_to_image(64, 64, 1, out);
   56:            print_image(pred);
   57:          */
   58  
   59:         /*
   60:            image im = float_to_image(256, 256, 3, train.X.vals[0]);
   61:            image lab = float_to_image(64, 64, 1, train.y.vals[0]);
   62:            image pred = float_to_image(64, 64, 1, out);
   63:            show_image(im, "image");
   64:            show_image(lab, "label");
   65:            print_image(lab);
   66:            show_image(pred, "pred");
   67:            cvWaitKey(0);
   68:          */
   69  
   70          if(avg_loss == -1) avg_loss = loss;

/Users/anthonybudd/Development/darknet/src/yolo.c:
   38  
   39      list *plist = get_paths(train_images);
   40:     //int N = plist->size;
   41      char **paths = (char **)list_to_array(plist);
   42  
   ..
   60      pthread_t load_thread = load_data_in_thread(args);
   61      clock_t time;
   62:     //while(i*imgs < N*120){
   63      while(get_current_batch(net) < net.max_batches){
   64          i += 1;
   ..
  120  
  121      char *base = "results/comp4_det_test_";
  122:     //list *plist = get_paths("data/voc.2007.test");
  123      list *plist = get_paths("/home/pjreddie/data/voc/2007_test.txt");
  124:     //list *plist = get_paths("data/voc.2012.test");
  125      char **paths = (char **)list_to_array(plist);
  126  
  ...
  319          get_detection_boxes(l, 1, 1, thresh, probs, boxes, 0);
  320          if (nms) do_nms_sort(boxes, probs, l.side*l.side*l.n, l.classes, nms);
  321:         //draw_detections(im, l.side*l.side*l.n, thresh, boxes, probs, voc_names, alphabet, 20);
  322          draw_detections(im, l.side*l.side*l.n, thresh, boxes, probs, voc_names, alphabet, 20);
  323          save_image(im, "predictions");

1211 matches across 52 files


Searching 111 files for "(/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+/)|(//.*)" (regex)

/Users/anthonybudd/Development/darknet/src/blas_kernels.cu:
   92  }
   93  
   94: /*
   95: __global__ void dot_kernel(float *output, float scale, int batch, int n, int size, float *delta)
   96: {
   97:     int index = (blockIdx.x + blockIdx.y*gridDim.x) * blockDim.x + threadIdx.x;
   98:     int f1 = index / n;
   99:     int f2 = index % n;
  100:     if (f2 <= f1) return;
  101:     
  102:     float sum = 0;
  103:     float norm1 = 0;
  104:     float norm2 = 0;
  105:     int b, i;
  106:     for(b = 0; b <  batch; ++b){
  107:         for(i = 0; i < size; ++i){
  108:             int i1 = b * size * n + f1 * size + i;
  109:             int i2 = b * size * n + f2 * size + i;
  110:             sum += output[i1] * output[i2];
  111:             norm1 += output[i1] * output[i1];
  112:             norm2 += output[i2] * output[i2];
  113:         }
  114:     }
  115:     norm1 = sqrt(norm1);
  116:     norm2 = sqrt(norm2);
  117:     float norm = norm1 * norm2;
  118:     sum = sum / norm;
  119:     for(b = 0; b <  batch; ++b){
  120:         for(i = 0; i < size; ++i){
  121:             int i1 = b * size * n + f1 * size + i;
  122:             int i2 = b * size * n + f2 * size + i;
  123:             delta[i1] += - scale * sum * output[i2] / norm;
  124:             delta[i2] += - scale * sum * output[i1] / norm;
  125:         }
  126:     }
  127: }
  128: 
  129: void dot_error_gpu(layer l)
  130: {
  131:     dot_kernel<<<cuda_gridsize(l.n*l.n), BLOCK>>>(l.output_gpu, l.dot, l.batch, l.n, l.out_w * l.out_h, l.delta_gpu);
  132:     check_error(cudaPeekAtLastError());
  133: }
  134: */
  135  
  136  void backward_bias_gpu(float *bias_updates, float *delta, int batch, int n, int size)
  ...
  147      
  148      x[index] = x[index] - (rate * sqrt(1.-pow(B2, t)) / (1.-pow(B1, t)) * m[index] / (sqrt(v[index]) + eps));
  149:     //if(index == 0) printf("%f %f %f %f\n", m[index], v[index], (rate * sqrt(1.-pow(B2, t)) / (1.-pow(B1, t)) * m[index] / (sqrt(v[index]) + eps)));
  150  }
  151  
  ...
  347      int w2 = in_w*stride + offset % stride;
  348      int h2 = in_h*stride + offset / stride;
  349:     //printf("%d\n", offset);
  350      int out_index = w2 + w*stride*(h2 + h*stride*(c2 + out_c*b));
  351  
  352:    // printf("%d %d %d\n", w2, h2, c2);
  353:     //printf("%d %d\n", in_index, out_index);
  354:     //if(out_index >= N || out_index < 0) printf("bad bad bad \n");
  355  
  356      if(forward) out[out_index] = x[in_index];
  357      else out[in_index] = x[out_index];
  358:     //if(forward) out[1] = x[1];
  359:     //else out[0] = x[0];
  360  }
  361  
  ...
  675      if(i < n){
  676          float diff = truth[i] - pred[i];
  677:         error[i] = diff * diff; //I know this is technically wrong, deal with it.
  678          delta[i] = diff;
  679      }

/Users/anthonybudd/Development/darknet/src/captcha.c:
   74          fix_data_captcha(train, solved);
   75  
   76:         /*
   77:            image im = float_to_image(256, 256, 3, train.X.vals[114]);
   78:            show_image(im, "training");
   79:            cvWaitKey(0);
   80:          */
   81  
   82          load_thread = load_data_in_thread(args);
   ..
  113              strncpy(input, filename, 256);
  114          }else{
  115:             //printf("Enter Image Path: ");
  116:             //fflush(stdout);
  117              input = fgets(input, 256, stdin);
  118              if(!input) return;
  ...
  123          float *predictions = network_predict(net, X);
  124          top_predictions(net, 26, indexes);
  125:         //printf("%s: Predicted in %f seconds.\n", input, sec(clock()-time));
  126          for(i = 0; i < 26; ++i){
  127              int index = indexes[i];
  ...
  156          float *X = im.data;
  157          float *predictions = network_predict(net, X);
  158:         //printf("%s: Predicted in %f seconds.\n", input, sec(clock()-time));
  159          int truth = -1;
  160          for(j = 0; j < 13; ++j){
  ...
  177  }
  178  
  179: /*
  180:    void train_captcha(char *cfgfile, char *weightfile)
  181:    {
  182:    float avg_loss = -1;
  183:    srand(time(0));
  184:    char *base = basecfg(cfgfile);
  185:    printf("%s\n", base);
  186:    network net = parse_network_cfg(cfgfile);
  187:    if(weightfile){
  188:    load_weights(&net, weightfile);
  189:    }
  190:    printf("Learning Rate: %g, Momentum: %g, Decay: %g\n", net.learning_rate, net.momentum, net.decay);
  191:    int imgs = 1024;
  192:    int i = net.seen/imgs;
  193:    list *plist = get_paths("/data/captcha/train.auto5");
  194:    char **paths = (char **)list_to_array(plist);
  195:    printf("%d\n", plist->size);
  196:    clock_t time;
  197:    while(1){
  198:    ++i;
  199:    time=clock();
  200:    data train = load_data_captcha(paths, imgs, plist->size, 10, 200, 60);
  201:    translate_data_rows(train, -128);
  202:    scale_data_rows(train, 1./128);
  203:    printf("Loaded: %lf seconds\n", sec(clock()-time));
  204:    time=clock();
  205:    float loss = train_network(net, train);
  206:    net.seen += imgs;
  207:    if(avg_loss == -1) avg_loss = loss;
  208:    avg_loss = avg_loss*.9 + loss*.1;
  209:    printf("%d: %f, %f avg, %lf seconds, %d images\n", i, loss, avg_loss, sec(clock()-time), net.seen);
  210:    free_data(train);
  211:    if(i%10==0){
  212:    char buff[256];
  213:    sprintf(buff, "/home/pjreddie/imagenet_backup/%s_%d.weights",base, i);
  214:    save_weights(net, buff);
  215:    }
  216:    }
  217:    }
  218: 
  219:    void decode_captcha(char *cfgfile, char *weightfile)
  220:    {
  221:    setbuf(stdout, NULL);
  222:    srand(time(0));
  223:    network net = parse_network_cfg(cfgfile);
  224:    set_batch_network(&net, 1);
  225:    if(weightfile){
  226:    load_weights(&net, weightfile);
  227:    }
  228:    char filename[256];
  229:    while(1){
  230:    printf("Enter filename: ");
  231:    fgets(filename, 256, stdin);
  232:    strtok(filename, "\n");
  233:    image im = load_image_color(filename, 300, 57);
  234:    scale_image(im, 1./255.);
  235:    float *X = im.data;
  236:    float *predictions = network_predict(net, X);
  237:    image out  = float_to_image(300, 57, 1, predictions);
  238:    show_image(out, "decoded");
  239: #ifdef OPENCV
  240: cvWaitKey(0);
  241: #endif
  242: free_image(im);
  243: }
  244: }
  245: 
  246: void encode_captcha(char *cfgfile, char *weightfile)
  247: {
  248: float avg_loss = -1;
  249: srand(time(0));
  250: char *base = basecfg(cfgfile);
  251: printf("%s\n", base);
  252: network net = parse_network_cfg(cfgfile);
  253: if(weightfile){
  254:     load_weights(&net, weightfile);
  255: }
  256: printf("Learning Rate: %g, Momentum: %g, Decay: %g\n", net.learning_rate, net.momentum, net.decay);
  257: int imgs = 1024;
  258: int i = net.seen/imgs;
  259: list *plist = get_paths("/data/captcha/encode.list");
  260: char **paths = (char **)list_to_array(plist);
  261: printf("%d\n", plist->size);
  262: clock_t time;
  263: while(1){
  264:     ++i;
  265:     time=clock();
  266:     data train = load_data_captcha_encode(paths, imgs, plist->size, 300, 57);
  267:     scale_data_rows(train, 1./255);
  268:     printf("Loaded: %lf seconds\n", sec(clock()-time));
  269:     time=clock();
  270:     float loss = train_network(net, train);
  271:     net.seen += imgs;
  272:     if(avg_loss == -1) avg_loss = loss;
  273:     avg_loss = avg_loss*.9 + loss*.1;
  274:     printf("%d: %f, %f avg, %lf seconds, %d images\n", i, loss, avg_loss, sec(clock()-time), net.seen);
  275:     free_matrix(train.X);
  276:     if(i%100==0){
  277:         char buff[256];
  278:         sprintf(buff, "/home/pjreddie/imagenet_backup/%s_%d.weights",base, i);
  279:         save_weights(net, buff);
  280:     }
  281: }
  282: }
  283: 
  284: void validate_captcha(char *cfgfile, char *weightfile)
  285: {
  286:     srand(time(0));
  287:     char *base = basecfg(cfgfile);
  288:     printf("%s\n", base);
  289:     network net = parse_network_cfg(cfgfile);
  290:     if(weightfile){
  291:         load_weights(&net, weightfile);
  292:     }
  293:     int numchars = 37;
  294:     list *plist = get_paths("/data/captcha/solved.hard");
  295:     char **paths = (char **)list_to_array(plist);
  296:     int imgs = plist->size;
  297:     data valid = load_data_captcha(paths, imgs, 0, 10, 200, 60);
  298:     translate_data_rows(valid, -128);
  299:     scale_data_rows(valid, 1./128);
  300:     matrix pred = network_predict_data(net, valid);
  301:     int i, k;
  302:     int correct = 0;
  303:     int total = 0;
  304:     int accuracy = 0;
  305:     for(i = 0; i < imgs; ++i){
  306:         int allcorrect = 1;
  307:         for(k = 0; k < 10; ++k){
  308:             char truth = int_to_alphanum(max_index(valid.y.vals[i]+k*numchars, numchars));
  309:             char prediction = int_to_alphanum(max_index(pred.vals[i]+k*numchars, numchars));
  310:             if (truth != prediction) allcorrect=0;
  311:             if (truth != '.' && truth == prediction) ++correct;
  312:             if (truth != '.' || truth != prediction) ++total;
  313:         }
  314:         accuracy += allcorrect;
  315:     }
  316:     printf("Word Accuracy: %f, Char Accuracy %f\n", (float)accuracy/imgs, (float)correct/total);
  317:     free_data(valid);
  318: }
  319: 
  320: void test_captcha(char *cfgfile, char *weightfile)
  321: {
  322:     setbuf(stdout, NULL);
  323:     srand(time(0));
  324:     //char *base = basecfg(cfgfile);
  325:     //printf("%s\n", base);
  326:     network net = parse_network_cfg(cfgfile);
  327:     set_batch_network(&net, 1);
  328:     if(weightfile){
  329:         load_weights(&net, weightfile);
  330:     }
  331:     char filename[256];
  332:     while(1){
  333:         //printf("Enter filename: ");
  334:         fgets(filename, 256, stdin);
  335:         strtok(filename, "\n");
  336:         image im = load_image_color(filename, 200, 60);
  337:         translate_image(im, -128);
  338:         scale_image(im, 1/128.);
  339:         float *X = im.data;
  340:         float *predictions = network_predict(net, X);
  341:         print_letters(predictions, 10);
  342:         free_image(im);
  343:     }
  344: }
  345:     */
  346  void run_captcha(int argc, char **argv)
  347  {
  ...
  357      else if(0==strcmp(argv[2], "test")) test_captcha(cfg, weights, filename);
  358      else if(0==strcmp(argv[2], "valid")) valid_captcha(cfg, weights, filename);
  359:     //if(0==strcmp(argv[2], "test")) test_captcha(cfg, weights);
  360:     //else if(0==strcmp(argv[2], "encode")) encode_captcha(cfg, weights);
  361:     //else if(0==strcmp(argv[2], "decode")) decode_captcha(cfg, weights);
  362:     //else if(0==strcmp(argv[2], "valid")) validate_captcha(cfg, weights);
  363  }
  364  

/Users/anthonybudd/Development/darknet/src/classifier.c:
  147  
  148  
  149: /*
  150:    void train_classifier(char *datacfg, char *cfgfile, char *weightfile, int clear)
  151:    {
  152:    srand(time(0));
  153:    float avg_loss = -1;
  154:    char *base = basecfg(cfgfile);
  155:    printf("%s\n", base);
  156:    network net = parse_network_cfg(cfgfile);
  157:    if(weightfile){
  158:    load_weights(&net, weightfile);
  159:    }
  160:    if(clear) *net.seen = 0;
  161: 
  162:    int imgs = net.batch * net.subdivisions;
  163: 
  164:    printf("Learning Rate: %g, Momentum: %g, Decay: %g\n", net.learning_rate, net.momentum, net.decay);
  165:    list *options = read_data_cfg(datacfg);
  166: 
  167:    char *backup_directory = option_find_str(options, "backup", "/backup/");
  168:    char *label_list = option_find_str(options, "labels", "data/labels.list");
  169:    char *train_list = option_find_str(options, "train", "data/train.list");
  170:    int classes = option_find_int(options, "classes", 2);
  171: 
  172:    char **labels = get_labels(label_list);
  173:    list *plist = get_paths(train_list);
  174:    char **paths = (char **)list_to_array(plist);
  175:    printf("%d\n", plist->size);
  176:    int N = plist->size;
  177:    clock_t time;
  178: 
  179:    load_args args = {0};
  180:    args.w = net.w;
  181:    args.h = net.h;
  182:    args.threads = 8;
  183: 
  184:    args.min = net.min_crop;
  185:    args.max = net.max_crop;
  186:    args.angle = net.angle;
  187:    args.aspect = net.aspect;
  188:    args.exposure = net.exposure;
  189:    args.saturation = net.saturation;
  190:    args.hue = net.hue;
  191:    args.size = net.w;
  192:    args.hierarchy = net.hierarchy;
  193: 
  194:    args.paths = paths;
  195:    args.classes = classes;
  196:    args.n = imgs;
  197:    args.m = N;
  198:    args.labels = labels;
  199:    args.type = CLASSIFICATION_DATA;
  200: 
  201:    data train;
  202:    data buffer;
  203:    pthread_t load_thread;
  204:    args.d = &buffer;
  205:    load_thread = load_data(args);
  206: 
  207:    int epoch = (*net.seen)/N;
  208:    while(get_current_batch(net) < net.max_batches || net.max_batches == 0){
  209:    time=clock();
  210: 
  211:    pthread_join(load_thread, 0);
  212:    train = buffer;
  213:    load_thread = load_data(args);
  214: 
  215:    printf("Loaded: %lf seconds\n", sec(clock()-time));
  216:    time=clock();
  217: 
  218: #ifdef OPENCV
  219: if(0){
  220: int u;
  221: for(u = 0; u < imgs; ++u){
  222:     image im = float_to_image(net.w, net.h, 3, train.X.vals[u]);
  223:     show_image(im, "loaded");
  224:     cvWaitKey(0);
  225: }
  226: }
  227: #endif
  228: 
  229: float loss = train_network(net, train);
  230: free_data(train);
  231: 
  232: if(avg_loss == -1) avg_loss = loss;
  233: avg_loss = avg_loss*.9 + loss*.1;
  234: printf("%d, %.3f: %f, %f avg, %f rate, %lf seconds, %d images\n", get_current_batch(net), (float)(*net.seen)/N, loss, avg_loss, get_current_rate(net), sec(clock()-time), *net.seen);
  235: if(*net.seen/N > epoch){
  236:     epoch = *net.seen/N;
  237:     char buff[256];
  238:     sprintf(buff, "%s/%s_%d.weights",backup_directory,base, epoch);
  239:     save_weights(net, buff);
  240: }
  241: if(get_current_batch(net)%100 == 0){
  242:     char buff[256];
  243:     sprintf(buff, "%s/%s.backup",backup_directory,base);
  244:     save_weights(net, buff);
  245: }
  246: }
  247: char buff[256];
  248: sprintf(buff, "%s/%s.weights", backup_directory, base);
  249: save_weights(net, buff);
  250: 
  251: free_network(net);
  252: free_ptrs((void**)labels, classes);
  253: free_ptrs((void**)paths, plist->size);
  254: free_list(plist);
  255: free(base);
  256: }
  257: */
  258  
  259  void validate_classifier_crop(char *datacfg, char *filename, char *weightfile)
  ...
  437          image resized = resize_min(im, size);
  438          resize_network(&net, resized.w, resized.h);
  439:         //show_image(im, "orig");
  440:         //show_image(crop, "cropped");
  441:         //cvWaitKey(0);
  442          float *pred = network_predict(net, resized.data);
  443          if(net.hierarchy) hierarchy_predictions(pred, net.outputs, net.hierarchy, 1);
  ...
  499          image resized = resize_min(im, net.w);
  500          image crop = crop_image(resized, (resized.w - net.w)/2, (resized.h - net.h)/2, net.w, net.h);
  501:         //show_image(im, "orig");
  502:         //show_image(crop, "cropped");
  503:         //cvWaitKey(0);
  504          float *pred = network_predict(net, crop.data);
  505          if(net.hierarchy) hierarchy_predictions(pred, net.outputs, net.hierarchy, 1);
  ...
  640              printf("%f\n", l.output[i]);
  641          }
  642:         /*
  643: 
  644:            printf("\n\nWeights\n");
  645:            for(i = 0; i < l.n*l.size*l.size*l.c; ++i){
  646:            printf("%f\n", l.filters[i]);
  647:            }
  648: 
  649:            printf("\n\nBiases\n");
  650:            for(i = 0; i < l.n; ++i){
  651:            printf("%f\n", l.biases[i]);
  652:            }
  653:          */
  654  
  655          top_predictions(net, top, indexes);
  ...
  812          int i, j;
  813          if (target_layer >= 0){
  814:             //layer l = net.layers[target_layer];
  815          }
  816  
  ...
  862  
  863      if(!cap) error("Couldn't connect to webcam.\n");
  864:     //cvNamedWindow("Threat", CV_WINDOW_NORMAL); 
  865:     //cvResizeWindow("Threat", 512, 512);
  866      float fps = 0;
  867      int i;
  ...
  937          char buff[256];
  938          sprintf(buff, "/home/pjreddie/tmp/threat_%06d", count);
  939:         //save_image(out, buff);
  940  
  941          printf("\033[2J");

/Users/anthonybudd/Development/darknet/src/coco.c:
   19  void train_coco(char *cfgfile, char *weightfile)
   20  {
   21:     //char *train_images = "/home/pjreddie/data/voc/test/train.txt";
   22:     //char *train_images = "/home/pjreddie/data/coco/train.txt";
   23      char *train_images = "data/coco.trainval.txt";
   24:     //char *train_images = "data/bags.train.list";
   25      char *backup_directory = "/home/pjreddie/backup/";
   26      srand(time(0));
   ..
   45  
   46      list *plist = get_paths(train_images);
   47:     //int N = plist->size;
   48      char **paths = (char **)list_to_array(plist);
   49  
   ..
   67      pthread_t load_thread = load_data_in_thread(args);
   68      clock_t time;
   69:     //while(i*imgs < N*120){
   70      while(get_current_batch(net) < net.max_batches){
   71          i += 1;
   ..
   77          printf("Loaded: %lf seconds\n", sec(clock()-time));
   78  
   79:         /*
   80:            image im = float_to_image(net.w, net.h, 3, train.X.vals[113]);
   81:            image copy = copy_image(im);
   82:            draw_coco(copy, train.y.vals[113], 7, "truth");
   83:            cvWaitKey(0);
   84:            free_image(copy);
   85:          */
   86  
   87          time=clock();
   ..
  151      char *base = "results/";
  152      list *plist = get_paths("data/coco_val_5k.list");
  153:     //list *plist = get_paths("/home/pjreddie/data/people-art/test.txt");
  154:     //list *plist = get_paths("/home/pjreddie/data/voc/test/2007_test.txt");
  155      char **paths = (char **)list_to_array(plist);
  156  

/Users/anthonybudd/Development/darknet/src/col2im.c:
   11      im[col + width*(row + height*channel)] += val;
   12  }
   13: //This one might be too, can't remember.
   14  void col2im_cpu(float* data_col,
   15           int channels,  int height,  int width,

/Users/anthonybudd/Development/darknet/src/col2im_kernels.cu:
    8  }
    9  
   10: // src: https://github.com/BVLC/caffe/blob/master/src/caffe/util/im2col.cu
   11: // You may also want to read: https://github.com/BVLC/caffe/blob/master/LICENSE
   12  
   13  __global__ void col2im_gpu_kernel(const int n, const float* data_col,
   ..
   23          int h = (index / width) % height + pad;
   24          int c = index / (width * height);
   25:         // compute the start and end of the output
   26          int w_col_start = (w < ksize) ? 0 : (w - ksize) / stride + 1;
   27          int w_col_end = min(w / stride + 1, width_col);
   28          int h_col_start = (h < ksize) ? 0 : (h - ksize) / stride + 1;
   29          int h_col_end = min(h / stride + 1, height_col);
   30:         // equivalent implementation
   31          int offset =
   32              (c * ksize * ksize + h * ksize + w) * height_col * width_col;
   ..
   45          int channels, int height, int width,
   46          int ksize, int stride, int pad, float *data_im){
   47:     // We are going to launch channels * height_col * width_col kernels, each
   48:     // kernel responsible for copying a single-channel grid.
   49      int height_col = (height + 2 * pad - ksize) / stride + 1;
   50      int width_col = (width + 2 * pad - ksize) / stride + 1;

/Users/anthonybudd/Development/darknet/src/compare.c:
   89  
   90      list *plist = get_paths("data/compare.val.list");
   91:     //list *plist = get_paths("data/compare.val.old");
   92      char **paths = (char **)list_to_array(plist);
   93      int N = plist->size/2;
   ..
  236  
  237      list *plist = get_paths("data/compare.sort.list");
  238:     //list *plist = get_paths("data/compare.val.old");
  239      char **paths = (char **)list_to_array(plist);
  240      int N = plist->size;
  ...
  268  
  269      list *plist = get_paths("data/compare.sort.list");
  270:     //list *plist = get_paths("data/compare.small.list");
  271:     //list *plist = get_paths("data/compare.cat.list");
  272:     //list *plist = get_paths("data/compare.val.old");
  273      char **paths = (char **)list_to_array(plist);
  274      int N = plist->size;
  ...
  340      char *cfg = argv[3];
  341      char *weights = (argc > 4) ? argv[4] : 0;
  342:     //char *filename = (argc > 5) ? argv[5]: 0;
  343      if(0==strcmp(argv[2], "train")) train_compare(cfg, weights);
  344      else if(0==strcmp(argv[2], "valid")) validate_compare(cfg, weights);
  345      else if(0==strcmp(argv[2], "sort")) SortMaster3000(cfg, weights);
  346      else if(0==strcmp(argv[2], "battle")) BattleRoyaleWithCheese(cfg, weights);
  347:     /*
  348:        else if(0==strcmp(argv[2], "train")) train_coco(cfg, weights);
  349:        else if(0==strcmp(argv[2], "extract")) extract_boxes(cfg, weights);
  350:        else if(0==strcmp(argv[2], "valid")) validate_recall(cfg, weights);
  351:      */
  352  }
  353  

/Users/anthonybudd/Development/darknet/src/connected_layer.c:
   41      l.update = update_connected_layer;
   42  
   43:     //float scale = 1./sqrt(inputs);
   44      float scale = sqrt(2./inputs);
   45      for(i = 0; i < outputs*inputs; ++i){
   ..
  213          printf("Scales ");
  214          print_statistics(l.scales, l.outputs);
  215:         /*
  216:         printf("Rolling Mean ");
  217:         print_statistics(l.rolling_mean, l.outputs);
  218:         printf("Rolling Variance ");
  219:         print_statistics(l.rolling_variance, l.outputs);
  220:         */
  221      }
  222      printf("Biases ");

/Users/anthonybudd/Development/darknet/src/convolutional_kernels.cu:
   61      for(i = 0; i < size; ++i){
   62          binary[f*size + i] = (weights[f*size + i] > 0) ? mean : -mean;
   63:         //binary[f*size + i] = weights[f*size + i];
   64      }
   65  }
   ..
  122  
  123      activate_array_ongpu(l.output_gpu, l.outputs*l.batch, l.activation);
  124:     //if(l.dot > 0) dot_error_gpu(l);
  125      if(l.binary || l.xnor) swap_binary(&l);
  126  }
  ...
  128  void backward_convolutional_layer_gpu(convolutional_layer l, network_state state)
  129  {
  130:     //constrain_ongpu(l.outputs*l.batch, 1, l.delta_gpu, 1);
  131      gradient_array_ongpu(l.output_gpu, l.outputs*l.batch, l.activation, l.delta_gpu);
  132  
  ...
  135      if(l.batch_normalize){
  136          backward_batchnorm_layer_gpu(l, state);
  137:         //axpy_ongpu(l.outputs*l.batch, -state.net.decay, l.x_gpu, 1, l.delta_gpu, 1);
  138      } else {
  139:         //axpy_ongpu(l.outputs*l.batch, -state.net.decay, l.output_gpu, 1, l.delta_gpu, 1);
  140      }
  141      float *original_input = state.input;

/Users/anthonybudd/Development/darknet/src/convolutional_layer.c:
  196      l.bias_updates = calloc(n, sizeof(float));
  197  
  198:     // float scale = 1./sqrt(size*size*c);
  199      float scale = sqrt(2./(size*size*c));
  200      for(i = 0; i < c*n*size*size; ++i) l.weights[i] = scale*rand_uniform(-1, 1);
  ...
  559      for(i = 0; i < l.n; ++i){
  560          weights[i] = copy_image(get_convolutional_weight(l, i));
  561:         //normalize_image(weights[i]);
  562      }
  563      return weights;
  ...
  573      char buff[256];
  574      sprintf(buff, "%s: Output", window);
  575:     //show_image(dc, buff);
  576:     //save_image(dc, buff);
  577      free_image(dc);
  578      return single_weights;

/Users/anthonybudd/Development/darknet/src/crnn_layer.c:
  153  
  154          l.state -= l.hidden*l.batch;
  155:         /*
  156:            if(i > 0){
  157:            copy_cpu(l.hidden * l.batch, input_layer.output - l.hidden*l.batch, 1, l.state, 1);
  158:            axpy_cpu(l.hidden * l.batch, 1, self_layer.output - l.hidden*l.batch, 1, l.state, 1);
  159:            }else{
  160:            fill_cpu(l.hidden * l.batch, 0, l.state, 1);
  161:            }
  162:          */
  163  
  164          s.input = l.state;

/Users/anthonybudd/Development/darknet/src/crop_layer_kernels.cu:
  204      check_error(cudaPeekAtLastError());
  205  
  206: /*
  207:        cuda_pull_array(layer.output_gpu, layer.output, size);
  208:        image im = float_to_image(layer.crop_width, layer.crop_height, layer.c, layer.output + 0*(size/layer.batch));
  209:        image im2 = float_to_image(layer.crop_width, layer.crop_height, layer.c, layer.output + 1*(size/layer.batch));
  210:        image im3 = float_to_image(layer.crop_width, layer.crop_height, layer.c, layer.output + 2*(size/layer.batch));
  211: 
  212:        translate_image(im, -translate);
  213:        scale_image(im, 1/scale);
  214:        translate_image(im2, -translate);
  215:        scale_image(im2, 1/scale);
  216:        translate_image(im3, -translate);
  217:        scale_image(im3, 1/scale);
  218:        
  219:        show_image(im, "cropped");
  220:        show_image(im2, "cropped2");
  221:        show_image(im3, "cropped3");
  222:        cvWaitKey(0);
  223:        */
  224  }
  225  

/Users/anthonybudd/Development/darknet/src/cuda.c:
   27  void check_error(cudaError_t status)
   28  {
   29:     //cudaDeviceSynchronize();
   30      cudaError_t status2 = cudaGetLastError();
   31      if (status != cudaSuccess)
   ..
   58      }
   59      dim3 d = {x, y, 1};
   60:     //printf("%ld %ld %ld %ld\n", n, x, y, x*y*BLOCK);
   61      return d;
   62  }
   ..
  120      float *tmp = calloc(n, sizeof(float));
  121      cuda_pull_array(x_gpu, tmp, n);
  122:     //int i;
  123:     //for(i = 0; i < n; ++i) printf("%f %f\n", tmp[i], x[i]);
  124      axpy_cpu(n, -1, x, 1, tmp, 1);
  125      float err = dot_cpu(n, tmp, 1, tmp, 1);

/Users/anthonybudd/Development/darknet/src/darknet.c:
  353  int main(int argc, char **argv)
  354  {
  355:     //test_resize("data/bad.jpg");
  356:     //test_box();
  357:     //test_convolutional_layer();
  358      if(argc < 2){
  359          fprintf(stderr, "usage: %s <function>\n", argv[0]);

/Users/anthonybudd/Development/darknet/src/data.c:
   23  }
   24  
   25: /*
   26: char **get_random_paths_indexes(char **paths, int n, int m, int *indexes)
   27: {
   28:     char **random_paths = calloc(n, sizeof(char*));
   29:     int i;
   30:     pthread_mutex_lock(&mutex);
   31:     for(i = 0; i < n; ++i){
   32:         int index = rand()%m;
   33:         indexes[i] = index;
   34:         random_paths[i] = paths[index];
   35:         if(i == 0) printf("%s\n", paths[index]);
   36:     }
   37:     pthread_mutex_unlock(&mutex);
   38:     return random_paths;
   39: }
   40: */
   41  
   42  char **get_random_paths(char **paths, int n, int m)
   ..
   48          int index = rand()%m;
   49          random_paths[i] = paths[index];
   50:         //if(i == 0) printf("%s\n", paths[index]);
   51      }
   52      pthread_mutex_unlock(&mutex);
   ..
  118          random_distort_image(crop, hue, saturation, exposure);
  119  
  120:         /*
  121:         show_image(im, "orig");
  122:         show_image(crop, "crop");
  123:         cvWaitKey(0);
  124:         */
  125          free_image(im);
  126          X.vals[i] = crop.data;
  ...
  412      int count = 0;
  413      for(j = 0; j < hierarchy->groups; ++j){
  414:         //printf("%d\n", count);
  415          int mask = 1;
  416          for(i = 0; i < hierarchy->group_size[j]; ++i){
  ...
  715  void *load_thread(void *ptr)
  716  {
  717:     //printf("Loading data: %d\n", rand());
  718      load_args a = *(struct load_args*)ptr;
  719      if(a.exposure == 0) a.exposure = 1;
  ...
  820  }
  821  
  822: /*
  823:    data load_data_study(char **paths, int n, int m, char **labels, int k, int min, int max, int size, float angle, float aspect, float hue, float saturation, float exposure)
  824:    {
  825:    data d = {0};
  826:    d.indexes = calloc(n, sizeof(int));
  827:    if(m) paths = get_random_paths_indexes(paths, n, m, d.indexes);
  828:    d.shallow = 0;
  829:    d.X = load_image_augment_paths(paths, n, min, max, size, angle, aspect, hue, saturation, exposure);
  830:    d.y = load_labels_paths(paths, n, labels, k);
  831:    if(m) free(paths);
  832:    return d;
  833:    }
  834:  */
  835  
  836  data load_data_super(char **paths, int n, int m, int w, int h, int scale)
  ...
  963          }
  964      }
  965:     //translate_data_rows(d, -128);
  966      scale_data_rows(d, 1./255);
  967:     //normalize_data_rows(d);
  968      fclose(fp);
  969      return d;
  ...
 1029          fclose(fp);
 1030      }
 1031:     //normalize_data_rows(d);
 1032:     //translate_data_rows(d, -128);
 1033      scale_data_rows(d, 1./255);
 1034      smooth_data(d);

/Users/anthonybudd/Development/darknet/src/demo.c:
   95  void demo(char *cfgfile, char *weightfile, float thresh, int cam_index, const char *filename, char **names, int classes, int frame_skip, char *prefix, float hier_thresh)
   96  {
   97:     //skip = frame_skip;
   98      image **alphabet = load_alphabet();
   99      int delay = frame_skip;

/Users/anthonybudd/Development/darknet/src/detection_layer.c:
   52      int i,j;
   53      memcpy(l.output, state.input, l.outputs*l.batch*sizeof(float));
   54:     //if(l.reorg) reorg(l.output, l.w*l.h, size*l.n, l.batch, 1);
   55      int b;
   56      if (l.softmax){
   ..
  118  
  119                      float iou  = box_iou(out, truth);
  120:                     //iou = 0;
  121                      float rmse = box_rmse(out, truth);
  122                      if(best_iou > 0 || iou > 0){
  ...
  156                  float iou  = box_iou(out, truth);
  157  
  158:                 //printf("%d,", best_index);
  159                  int p_index = index + locations*l.classes + i*l.n + best_index;
  160                  *(l.cost) -= l.noobject_scale * pow(l.output[p_index], 2);
  ...
  213  
  214          printf("Detection Avg IOU: %f, Pos Cat: %f, All Cat: %f, Pos Obj: %f, Any Obj: %f, count: %d\n", avg_iou/count, avg_cat/count, avg_allcat/(count*l.classes), avg_obj/count, avg_anyobj/(l.batch*locations*l.n), count);
  215:         //if(l.reorg) reorg(l.delta, l.w*l.h, size*l.n, l.batch, 0);
  216      }
  217  }
  ...
  226      int i,j,n;
  227      float *predictions = l.output;
  228:     //int per_cell = 5*num+classes;
  229      for (i = 0; i < l.side*l.side; ++i){
  230          int row = i / l.side;
  ...
  282  {
  283      axpy_ongpu(l.batch*l.inputs, 1, l.delta_gpu, 1, state.delta, 1);
  284:     //copy_ongpu(l.batch*l.inputs, l.delta_gpu, 1, state.delta, 1);
  285  }
  286  #endif

/Users/anthonybudd/Development/darknet/src/detector.c:
   53  
   54      list *plist = get_paths(train_images);
   55:     //int N = plist->size;
   56      char **paths = (char **)list_to_array(plist);
   57  
   ..
   77      clock_t time;
   78      int count = 0;
   79:     //while(i*imgs < N*120){
   80      while(get_current_batch(net) < net.max_batches){
   81          if(l.random && count++%10 == 0){
   ..
   83              int dim = (rand() % 10 + 10) * 32;
   84              if (get_current_batch(net)+200 > net.max_batches) dim = 608;
   85:             //int dim = (rand() % 4 + 16) * 32;
   86              printf("%d\n", dim);
   87              args.w = dim;
   ..
  103          load_thread = load_data(args);
  104  
  105:         /*
  106:            int k;
  107:            for(k = 0; k < l.max_boxes; ++k){
  108:            box b = float_to_box(train.y.vals[10] + 1 + k*5);
  109:            if(!b.x) break;
  110:            printf("loaded: %f %f %f %f\n", b.x, b.y, b.w, b.h);
  111:            }
  112:            image im = float_to_image(448, 448, 3, train.X.vals[10]);
  113:            int k;
  114:            for(k = 0; k < l.max_boxes; ++k){
  115:            box b = float_to_box(train.y.vals[10] + 1 + k*5);
  116:            printf("%d %d %d %d\n", truth.x, truth.y, truth.w, truth.h);
  117:            draw_bbox(im, b, 8, 1,0,0);
  118:            }
  119:            save_image(im, "truth11");
  120:          */
  121  
  122          printf("Loaded: %lf seconds\n", sec(clock()-time));

/Users/anthonybudd/Development/darknet/src/dropout_layer_kernels.cu:
   20      int size = layer.inputs*layer.batch;
   21      cuda_random(layer.rand_gpu, size);
   22:     /*
   23:     int i;
   24:     for(i = 0; i < size; ++i){
   25:         layer.rand[i] = rand_uniform();
   26:     }
   27:     cuda_push_array(layer.rand_gpu, layer.rand, size);
   28:     */
   29  
   30      yoloswag420blazeit360noscope<<<cuda_gridsize(size), BLOCK>>>(state.input, size, layer.rand_gpu, layer.probability, layer.scale);

/Users/anthonybudd/Development/darknet/src/gemm.c:
  145          float *C, int ldc)
  146  {
  147:     //printf("cpu: %d %d %d %d %d %f %d %d %f %d\n",TA, TB, M, N, K, ALPHA, lda, ldb, BETA, ldc);
  148      int i, j;
  149      for(i = 0; i < M; ++i){
  ...
  277      memset(c_gpu, 0, m*n*sizeof(float));
  278      int i;
  279:     //pm(m,k,b);
  280      gemm_gpu(TA,TB,m,n,k,1,a,lda,b,ldb,1,c_gpu,n);
  281:     //printf("GPU\n");
  282:     //pm(m, n, c_gpu);
  283  
  284      gemm_cpu(TA,TB,m,n,k,1,a,lda,b,ldb,1,c,n);
  285:     //printf("\n\nCPU\n");
  286:     //pm(m, n, c);
  287      double sse = 0;
  288      for(i = 0; i < m*n; ++i) {
  289:         //printf("%f %f\n", c[i], c_gpu[i]);
  290          sse += pow(c[i]-c_gpu[i], 2);
  291      }
  ...
  299  int test_gpu_blas()
  300  {
  301:     /*
  302:        test_gpu_accuracy(0,0,10,576,75); 
  303: 
  304:        test_gpu_accuracy(0,0,17,10,10); 
  305:        test_gpu_accuracy(1,0,17,10,10); 
  306:        test_gpu_accuracy(0,1,17,10,10); 
  307:        test_gpu_accuracy(1,1,17,10,10); 
  308: 
  309:        test_gpu_accuracy(0,0,1000,10,100); 
  310:        test_gpu_accuracy(1,0,1000,10,100); 
  311:        test_gpu_accuracy(0,1,1000,10,100); 
  312:        test_gpu_accuracy(1,1,1000,10,100); 
  313: 
  314:        test_gpu_accuracy(0,0,10,10,10); 
  315: 
  316:        time_ongpu(0,0,64,2916,363); 
  317:        time_ongpu(0,0,64,2916,363); 
  318:        time_ongpu(0,0,64,2916,363); 
  319:        time_ongpu(0,0,192,729,1600); 
  320:        time_ongpu(0,0,384,196,1728); 
  321:        time_ongpu(0,0,256,196,3456); 
  322:        time_ongpu(0,0,256,196,2304); 
  323:        time_ongpu(0,0,128,4096,12544); 
  324:        time_ongpu(0,0,128,4096,4096); 
  325:      */
  326      time_ongpu(0,0,64,75,12544); 
  327      time_ongpu(0,0,64,75,12544); 

/Users/anthonybudd/Development/darknet/src/go.c:
   56  {
   57      int i, j;
   58:     //memset(board, 0, 1*19*19*sizeof(float));
   59      int count = 0;
   60      for(i = 0; i < 91; ++i){
   ..
  133      float *move = calloc(19*19*net.batch, sizeof(float));
  134      moves m = load_go_moves("/home/pjreddie/backup/go.train");
  135:     //moves m = load_go_moves("games.txt");
  136  
  137      int N = m.n;
  ...
  207  void print_board(float *board, int swap, int *indexes)
  208  {
  209:     //FILE *stream = stdout;
  210      FILE *stream = stderr;
  211      int i,j,n;
  ...
  225                      if(index == indexes[n]){
  226                          found = 1;
  227:                         /*
  228:                         if(n == 0) fprintf(stream, "\uff11");
  229:                         else if(n == 1) fprintf(stream, "\uff12");
  230:                         else if(n == 2) fprintf(stream, "\uff13");
  231:                         else if(n == 3) fprintf(stream, "\uff14");
  232:                         else if(n == 4) fprintf(stream, "\uff15");
  233:                         */
  234                          if(n == 0) fprintf(stream, " 1");
  235                          else if(n == 1) fprintf(stream, " 2");
  ...
  241                  if(found) continue;
  242              }
  243:             //if(board[index]*-swap > 0) fprintf(stream, "\u25C9 ");
  244:             //else if(board[index]*-swap < 0) fprintf(stream, "\u25EF ");
  245              if(board[index]*-swap > 0) fprintf(stream, " O");
  246              else if(board[index]*-swap < 0) fprintf(stream, " X");
  ...
  451          char ids[256];
  452          sprintf(ids, "%d", id);
  453:         //fprintf(stderr, "%s\n", buff);
  454          if (!has_id) ids[0] = 0;
  455          if (!strcmp(buff, "protocol_version")){
  ...
  483              int boardsize = 0;
  484              scanf("%d", &boardsize);
  485:             //fprintf(stderr, "%d\n", boardsize);
  486              if(boardsize != 19){
  487                  printf("?%s unacceptable size\n\n", ids);
  ...
  555  
  556          } else if (!strcmp(buff, "p")){
  557:             //print_board(board, 1, 0);
  558          } else if (!strcmp(buff, "final_status_list")){
  559              char type[256];
  ...
  648              printf("%d: %c %d, %.2f%%\n", i+1, col + 'A' + 1*(col > 7 && noi), (inverted)?19 - row : row+1, move[index]*100);
  649          }
  650:         //if(color == 1) printf("\u25EF Enter move: ");
  651:         //else printf("\u25C9 Enter move: ");
  652          if(color == 1) printf("X Enter move: ");
  653          else printf("O Enter move: ");
  ...
  674                  if (num == 2) board[row*19 + col] = 1;
  675              } else if (c == 'p') {
  676:                 // Pass
  677              } else if(c=='b' || c == 'w'){
  678                  char g;
  ...
  782              fflush(stderr);
  783          }
  784:         //print_board(board, 1, 0);
  785:         //sleep(1);
  786          network use = ((total%2==0) == (player==1)) ? net : net2;
  787          int index = generate_move(use, player, board, multi, .1, .7, two, 0);
  ...
  813  void run_go(int argc, char **argv)
  814  {
  815:     //boards_go();
  816      if(argc < 4){
  817          fprintf(stderr, "usage: %s %s [train/test/valid] [cfg] [weights (optional)]\n", argv[0], argv[1]);

/Users/anthonybudd/Development/darknet/src/im2col.c:
   12  }
   13  
   14: //From Berkeley Vision's Caffe!
   15: //https://github.com/BVLC/caffe/blob/master/LICENSE
   16  void im2col_cpu(float* data_im,
   17       int channels,  int height,  int width,

/Users/anthonybudd/Development/darknet/src/im2col_kernels.cu:
    8  }
    9  
   10: // src: https://github.com/BVLC/caffe/blob/master/src/caffe/util/im2col.cu
   11: // You may also want to read: https://github.com/BVLC/caffe/blob/master/LICENSE
   12  
   13  __global__ void im2col_gpu_kernel(const int n, const float* data_im,
   ..
   38                      data_im_ptr[i * width + j] : 0;
   39  
   40:                 //*data_col_ptr = data_im_ptr[ii * width + jj];
   41  
   42                  data_col_ptr += height_col * width_col;
   ..
   49           int channels, int height, int width,
   50           int ksize, int stride, int pad, float *data_col){
   51:     // We are going to launch channels * height_col * width_col kernels, each
   52:     // kernel responsible for copying a single-channel grid.
   53      int height_col = (height + 2 * pad - ksize) / stride + 1;
   54      int width_col = (width + 2 * pad - ksize) / stride + 1;

/Users/anthonybudd/Development/darknet/src/image.c:
   28      ratio -= i;
   29      float r = (1-ratio) * colors[i][c] + ratio*colors[j][c];
   30:     //printf("%f\n", r);
   31      return r;
   32  }
   ..
  107  void draw_box(image a, int x1, int y1, int x2, int y2, float r, float g, float b)
  108  {
  109:     //normalize_image(a);
  110      int i;
  111      if(x1 < 0) x1 = 0;
  ...
  201              float rgb[3];
  202  
  203:             //width = prob*20+2;
  204  
  205              rgb[0] = red;
  ...
  406      constrain_image(copy);
  407      if(p.c == 3) rgbgr_image(copy);
  408:     //normalize_image(copy);
  409  
  410      char buff[256];
  411:     //sprintf(buff, "%s (%d)", name, windows);
  412      sprintf(buff, "%s", name);
  413  
  ...
  415      int step = disp->widthStep;
  416      cvNamedWindow(buff, CV_WINDOW_NORMAL); 
  417:     //cvMoveWindow(buff, 100*(windows%10) + 200*(windows/10), 100*(windows%10));
  418      ++windows;
  419      for(y = 0; y < p.h; ++y){
  ...
  492          system(buff);
  493          return make_image(10,10,3);
  494:         //exit(0);
  495      }
  496      image out = ipl_to_image(src);
  ...
  536  {
  537      char buff[256];
  538:     //sprintf(buff, "%s (%d)", name, windows);
  539      sprintf(buff, "%s.png", name);
  540      unsigned char *data = calloc(im.w*im.h*im.c, sizeof(char));
  ...
  825  }
  826  
  827: // http://www.cs.rit.edu/~ncs/color/t_convert.html
  828  void rgb_to_hsv(image im)
  829  {
  ...
 1269          int h_offset = i*(ims[0].h+border);
 1270          image copy = copy_image(ims[i]);
 1271:         //normalize_image(copy);
 1272          if(c == 3 && color){
 1273              embed_image(copy, filters, 0, h_offset);
 ....
 1305          int w_offset = i*(size+border);
 1306          image copy = copy_image(ims[i]);
 1307:         //normalize_image(copy);
 1308          if(c == 3 && color){
 1309              embed_image(copy, filters, w_offset, 0);
 ....
 1333  {
 1334      image m = collapse_images_vert(ims, n);
 1335:     /*
 1336:        int w = 448;
 1337:        int h = ((float)m.h/m.w) * 448;
 1338:        if(h > 896){
 1339:        h = 896;
 1340:        w = ((float)m.w/m.h) * 896;
 1341:        }
 1342:        image sized = resize_image(m, w, h);
 1343:      */
 1344      normalize_image(m);
 1345      save_image(m, window);

/Users/anthonybudd/Development/darknet/src/list.c:
   12  }
   13  
   14: /*
   15: void transfer_node(list *s, list *d, node *n)
   16: {
   17:     node *prev, *next;
   18:     prev = n->prev;
   19:     next = n->next;
   20:     if(prev) prev->next = next;
   21:     if(next) next->prev = prev;
   22:     --s->size;
   23:     if(s->front == n) s->front = next;
   24:     if(s->back == n) s->back = prev;
   25: }
   26: */
   27  
   28  void *list_pop(list *l){

/Users/anthonybudd/Development/darknet/src/local_layer.c:
   54      l.bias_updates = calloc(l.outputs, sizeof(float));
   55  
   56:     // float scale = 1./sqrt(size*size*c);
   57      float scale = sqrt(2./(size*size*c));
   58      for(i = 0; i < c*n*size*size; ++i) l.weights[i] = scale*rand_uniform(-1,1);

/Users/anthonybudd/Development/darknet/src/network.c:
   42      net.decay = 0;
   43      #ifdef GPU
   44:         //if(net.gpu_index >= 0) update_network_gpu(net);
   45      #endif
   46  }
   ..
   61                  if(net.steps[i] > batch_num) return rate;
   62                  rate *= net.scales[i];
   63:                 //if(net.steps[i] > batch_num - 1 && net.scales[i] > 1) reset_momentum(net);
   64              }
   65              return rate;
   ..
  329  #endif
  330      int i;
  331:     //if(w == net->w && h == net->h) return 0;
  332      net->w = w;
  333      net->h = h;
  334      int inputs = 0;
  335      size_t workspace_size = 0;
  336:     //fprintf(stderr, "Resizing to %d x %d...\n", w, h);
  337:     //fflush(stderr);
  338      for (i = 0; i < net->n; ++i){
  339          layer l = net->layers[i];
  ...
  383      net->workspace = calloc(1, workspace_size);
  384  #endif
  385:     //fprintf(stderr, " Done!\n");
  386      return 0;
  387  }

/Users/anthonybudd/Development/darknet/src/network.h:
    1: // Oh boy, why am I about to do this....
    2  #ifndef NETWORK_H
    3  #define NETWORK_H

/Users/anthonybudd/Development/darknet/src/network_kernels.cu:
  279  void sync_layer(network *nets, int n, int j)
  280  {
  281:     //printf("Syncing layer %d\n", j);
  282      int i;
  283      network net = nets[0];
  ...
  297          distribute_weights(l, base);
  298      }
  299:     //printf("Done syncing layer %d\n", j);
  300  }
  301  
  ...
  360      for(i = 0; i < n; ++i){
  361          pthread_join(threads[i], 0);
  362:         //printf("%f\n", errors[i]);
  363          sum += errors[i];
  364      }
  365:     //cudaDeviceSynchronize();
  366      if (get_current_batch(nets[0]) % interval == 0) {
  367          printf("Syncing... ");
  ...
  370          printf("Done!\n");
  371      }
  372:     //cudaDeviceSynchronize();
  373      free(threads);
  374      free(errors);

/Users/anthonybudd/Development/darknet/src/nightmare.c:
    9  #endif
   10  
   11: // ./darknet nightmare cfg/extractor.recon.cfg ~/trained/yolo-coco.conv frame6.png -reconstruct -iters 500 -i 3 -lambda .1 -rate .01 -smooth 2
   12  
   13  float abs_mean(float *x, int n)
   ..
   34  void optimize_picture(network *net, image orig, int max_layer, float scale, float rate, float thresh, int norm)
   35  {
   36:     //scale_image(orig, 2);
   37:     //translate_image(orig, -1);
   38      net->n = max_layer + 1;
   39  
   ..
   48      resize_network(net, im.w, im.h);
   49      layer last = net->layers[net->n-1];
   50:     //net->layers[net->n - 1].activation = LINEAR;
   51  
   52      image delta = make_image(im.w, im.h, im.c);
   ..
   80  
   81      if(flip) flip_image(delta);
   82:     //normalize_array(delta.data, delta.w*delta.h*delta.c);
   83      image resized = resize_image(delta, orig.w, orig.h);
   84      image out = crop_image(resized, -dx, -dy, orig.w, orig.h);
   85  
   86:     /*
   87:        image g = grayscale_image(out);
   88:        free_image(out);
   89:        out = g;
   90:      */
   91  
   92:     //rate = rate / abs_mean(out.data, out.w*out.h*out.c);
   93  
   94      if(norm) normalize_array(out.data, out.w*out.h*out.c);
   95      axpy_cpu(orig.w*orig.h*orig.c, rate, out.data, 1, orig.data, 1);
   96  
   97:     /*
   98:        normalize_array(orig.data, orig.w*orig.h*orig.c);
   99:        scale_image(orig, sqrt(var));
  100:        translate_image(orig, mean);
  101:      */
  102  
  103:     //translate_image(orig, 1);
  104:     //scale_image(orig, .5);
  105:     //normalize_image(orig);
  106  
  107      constrain_image(orig);
  ...
  171          scal_cpu(recon.w*recon.h*recon.c, momentum, update.data, 1);
  172  
  173:         //float mag = mag_array(recon.data, recon.w*recon.h*recon.c);
  174:         //scal_cpu(recon.w*recon.h*recon.c, 600/mag, recon.data, 1);
  175  
  176          constrain_image(recon);
  ...
  235          image out_im = get_network_image(net);
  236          image crop = crop_image(out_im, zz, zz, out_im.w-2*zz, out_im.h-2*zz);
  237:         //flip_image(crop);
  238          image f_im = resize_image(crop, out_im.w, out_im.h);
  239          free_image(crop);
  ...
  266              if(reconstruct){
  267                  reconstruct_picture(net, features, im, update, rate, momentum, lambda, smooth_size, 1);
  268:                 //if ((n+1)%30 == 0) rate *= .5;
  269                  show_image(im, "reconstruction");
  270  #ifdef OPENCV
  ...
  291          printf("%d %s\n", e, buff);
  292          save_image(im, buff);
  293:         //show_image(im, buff);
  294:         //cvWaitKey(0);
  295  
  296          if(rotate){

/Users/anthonybudd/Development/darknet/src/normalization_layer.c:
   96  void backward_normalization_layer(const layer layer, network_state state)
   97  {
   98:     // TODO This is approximate ;-)
   99:     // Also this should add in to delta instead of overwritting.
  100  
  101      int w = layer.w;
  ...
  140  void backward_normalization_layer_gpu(const layer layer, network_state state)
  141  {
  142:     // TODO This is approximate ;-)
  143  
  144      int w = layer.w;

/Users/anthonybudd/Development/darknet/src/parser.c:
  685      net.output = get_network_output(net);
  686      if(workspace_size){
  687:         //printf("%ld\n", workspace_size);
  688  #ifdef GPU
  689          if(gpu_index >= 0){
  ...
  769  {
  770      if(l.binary){
  771:         //save_convolutional_weights_binary(l, fp);
  772:         //return;
  773      }
  774  #ifdef GPU
  ...
  901          transpose_matrix(l.weights, l.inputs, l.outputs);
  902      }
  903:     //printf("Biases: %f mean %f variance\n", mean_array(l.biases, l.outputs), variance_array(l.biases, l.outputs));
  904:     //printf("Weights: %f mean %f variance\n", mean_array(l.weights, l.outputs*l.inputs), variance_array(l.weights, l.outputs*l.inputs));
  905      if (l.batch_normalize && (!l.dontloadscales)){
  906          fread(l.scales, sizeof(float), l.outputs, fp);
  907          fread(l.rolling_mean, sizeof(float), l.outputs, fp);
  908          fread(l.rolling_variance, sizeof(float), l.outputs, fp);
  909:         //printf("Scales: %f mean %f variance\n", mean_array(l.scales, l.outputs), variance_array(l.scales, l.outputs));
  910:         //printf("rolling_mean: %f mean %f variance\n", mean_array(l.rolling_mean, l.outputs), variance_array(l.rolling_mean, l.outputs));
  911:         //printf("rolling_variance: %f mean %f variance\n", mean_array(l.rolling_variance, l.outputs), variance_array(l.rolling_variance, l.outputs));
  912      }
  913  #ifdef GPU
  ...
  963  {
  964      if(l.binary){
  965:         //load_convolutional_weights_binary(l, fp);
  966:         //return;
  967      }
  968      int num = l.n*l.c*l.size*l.size;
  ...
  993          fread(l.v, sizeof(float), num, fp);
  994      }
  995:     //if(l.c == 3) scal_cpu(num, 1./256, l.weights, 1);
  996      if (l.flipped) {
  997          transpose_matrix(l.weights, l.c*l.size*l.size, l.n);
  998      }
  999:     //if (l.binary) binarize_weights(l.weights, l.n, l.c*l.size*l.size, l.weights);
 1000  #ifdef GPU
 1001      if(gpu_index >= 0){

/Users/anthonybudd/Development/darknet/src/region_layer.c:
  246              i = (truth.x * l.w);
  247              j = (truth.y * l.h);
  248:             //printf("%d %f %d %f\n", i, truth.x*l.w, j, truth.y*l.h);
  249              box truth_shift = truth;
  250              truth_shift.x = 0;
  251              truth_shift.y = 0;
  252:             //printf("index %d %d\n",i, j);
  253              for(n = 0; n < l.n; ++n){
  254                  int index = size*(j*l.w*l.n + i*l.n + n) + b*l.outputs;
  ...
  258                      pred.h = l.biases[2*n+1]/l.h;
  259                  }
  260:                 //printf("pred: (%f, %f) %f x %f\n", pred.x, pred.y, pred.w, pred.h);
  261                  pred.x = 0;
  262                  pred.y = 0;
  ...
  268                  }
  269              }
  270:             //printf("%d %f (%f, %f) %f x %f\n", best_n, best_iou, truth.x, truth.y, truth.w, truth.h);
  271  
  272              float iou = delta_region_box(truth, l.output, l.biases, best_n, best_index, i, j, l.w, l.h, l.delta, l.coord_scale);
  ...
  274              avg_iou += iou;
  275  
  276:             //l.delta[best_index + 4] = iou - l.output[best_index + 4];
  277              avg_obj += l.output[best_index + 4];
  278              l.delta[best_index + 4] = l.object_scale * (1 - l.output[best_index + 4]) * logistic_gradient(l.output[best_index + 4]);
  ...
  289          }
  290      }
  291:     //printf("\n");
  292  #ifndef GPU
  293      flatten(l.delta, l.w*l.h, size*l.n, l.batch, 0);
  ...
  351  void forward_region_layer_gpu(const layer l, network_state state)
  352  {
  353:     /*
  354:        if(!state.train){
  355:        copy_ongpu(l.batch*l.inputs, state.input, 1, l.output_gpu, 1);
  356:        return;
  357:        }
  358:      */
  359      flatten_ongpu(state.input, l.h*l.w, l.n*(l.coords + l.classes + 1), l.batch, 1, l.output_gpu);
  360      if(l.softmax_tree){
  ...
  383      cpu_state.input = in_cpu;
  384      forward_region_layer(l, cpu_state);
  385:     //cuda_push_array(l.output_gpu, l.output, l.batch*l.outputs);
  386      free(cpu_state.input);
  387      if(!state.train) return;

/Users/anthonybudd/Development/darknet/src/rnn.c:
  100  
  101              if(curr > 255 || curr <= 0 || next > 255 || next <= 0){
  102:                 /*text[(index+j+2)%len] = 0;
  103:                 printf("%ld %d %d %d %d\n", index, j, len, (int)text[index+j], (int)text[index+j+1]);
  104:                 printf("%s", text+index);
  105:                 */
  106                  error("Bad char");
  107              }
  ...
  191  
  192          for(j = 0; j < streams; ++j){
  193:             //printf("%d\n", j);
  194              if(rand()%10 == 0){
  195:                 //fprintf(stderr, "Reset\n");
  196                  offsets[j] = rand_size_t()%size;
  197                  reset_rnn_state(net, j);
  ...
  247      float *input = calloc(inputs, sizeof(float));
  248  
  249:     /*
  250:        fill_cpu(inputs, 0, input, 1);
  251:        for(i = 0; i < 10; ++i){
  252:        network_predict(net, input);
  253:        }
  254:        fill_cpu(inputs, 0, input, 1);
  255:      */
  256  
  257      for(i = 0; i < len-1; ++i){
  ...
  269          input[c] = 0;
  270          for(j = 32; j < 127; ++j){
  271:             //printf("%d %c %f\n",j, j, out[j]);
  272          }
  273          for(j = 0; j < inputs; ++j){

/Users/anthonybudd/Development/darknet/src/rnn_layer.c:
  145  
  146          l.state -= l.hidden*l.batch;
  147:         /*
  148:            if(i > 0){
  149:            copy_cpu(l.hidden * l.batch, input_layer.output - l.hidden*l.batch, 1, l.state, 1);
  150:            axpy_cpu(l.hidden * l.batch, 1, self_layer.output - l.hidden*l.batch, 1, l.state, 1);
  151:            }else{
  152:            fill_cpu(l.hidden * l.batch, 0, l.state, 1);
  153:            }
  154:          */
  155  
  156          s.input = l.state;
  ...
  263          backward_connected_layer_gpu(self_layer, s);
  264  
  265:         //copy_ongpu(l.hidden*l.batch, self_layer.delta_gpu, 1, input_layer.delta_gpu, 1);
  266          if (i > 0 && l.shortcut) axpy_ongpu(l.hidden*l.batch, 1, self_layer.delta_gpu, 1, self_layer.delta_gpu - l.hidden*l.batch, 1);
  267          s.input = state.input + i*l.inputs*l.batch;

/Users/anthonybudd/Development/darknet/src/rnn_vid.c:
   48              rgbgr_image(im);
   49              image re = resize_image(im, net.w, net.h);
   50:             //show_image(re, "loaded");
   51:             //cvWaitKey(10);
   52              memcpy(input + i*input_size, re.data, input_size*sizeof(float));
   53              free_image(im);
   ..
   65      }
   66  
   67:     //printf("%d %d %d\n", out_im.w, out_im.h, out_im.c);
   68      float_pair p = {0};
   69      p.x = feats;
   70:     p.y = feats + output_size*batch; //+ out_im.w*out_im.h*out_im.c;
   71  
   72      return p;
   ..
  202      char *cfg = argv[3];
  203      char *weights = (argc > 4) ? argv[4] : 0;
  204:     //char *filename = (argc > 5) ? argv[5]: 0;
  205      if(0==strcmp(argv[2], "train")) train_vid_rnn(cfg, weights);
  206      else if(0==strcmp(argv[2], "generate")) generate_vid_rnn(cfg, weights);

/Users/anthonybudd/Development/darknet/src/stb_image.h:
    1: /* stb_image - v2.06 - public domain image loader - http://nothings.org/stb_image.h
    2:                                      no warranty implied; use at your own risk
    3: 
    4:    Do this:
    5:       #define STB_IMAGE_IMPLEMENTATION
    6:    before you include this file in *one* C or C++ file to create the implementation.
    7: 
    8:    // i.e. it should look like this:
    9:    #include ...
   10:    #include ...
   11:    #include ...
   12:    #define STB_IMAGE_IMPLEMENTATION
   13:    #include "stb_image.h"
   14: 
   15:    You can #define STBI_ASSERT(x) before the #include to avoid using assert.h.
   16:    And #define STBI_MALLOC, STBI_REALLOC, and STBI_FREE to avoid using malloc,realloc,free
   17: 
   18: 
   19:    QUICK NOTES:
   20:       Primarily of interest to game developers and other people who can
   21:           avoid problematic images and only need the trivial interface
   22: 
   23:       JPEG baseline & progressive (12 bpc/arithmetic not supported, same as stock IJG lib)
   24:       PNG 1/2/4/8-bit-per-channel (16 bpc not supported)
   25: 
   26:       TGA (not sure what subset, if a subset)
   27:       BMP non-1bpp, non-RLE
   28:       PSD (composited view only, no extra channels)
   29: 
   30:       GIF (*comp always reports as 4-channel)
   31:       HDR (radiance rgbE format)
   32:       PIC (Softimage PIC)
   33:       PNM (PPM and PGM binary only)
   34: 
   35:       - decode from memory or through FILE (define STBI_NO_STDIO to remove code)
   36:       - decode from arbitrary I/O callbacks
   37:       - SIMD acceleration on x86/x64 (SSE2) and ARM (NEON)
   38: 
   39:    Full documentation under "DOCUMENTATION" below.
   40: 
   41: 
   42:    Revision 2.00 release notes:
   43: 
   44:       - Progressive JPEG is now supported.
   45: 
   46:       - PPM and PGM binary formats are now supported, thanks to Ken Miller.
   47: 
   48:       - x86 platforms now make use of SSE2 SIMD instructions for
   49:         JPEG decoding, and ARM platforms can use NEON SIMD if requested.
   50:         This work was done by Fabian "ryg" Giesen. SSE2 is used by
   51:         default, but NEON must be enabled explicitly; see docs.
   52: 
   53:         With other JPEG optimizations included in this version, we see
   54:         2x speedup on a JPEG on an x86 machine, and a 1.5x speedup
   55:         on a JPEG on an ARM machine, relative to previous versions of this
   56:         library. The same results will not obtain for all JPGs and for all
   57:         x86/ARM machines. (Note that progressive JPEGs are significantly
   58:         slower to decode than regular JPEGs.) This doesn't mean that this
   59:         is the fastest JPEG decoder in the land; rather, it brings it
   60:         closer to parity with standard libraries. If you want the fastest
   61:         decode, look elsewhere. (See "Philosophy" section of docs below.)
   62: 
   63:         See final bullet items below for more info on SIMD.
   64: 
   65:       - Added STBI_MALLOC, STBI_REALLOC, and STBI_FREE macros for replacing
   66:         the memory allocator. Unlike other STBI libraries, these macros don't
   67:         support a context parameter, so if you need to pass a context in to
   68:         the allocator, you'll have to store it in a global or a thread-local
   69:         variable.
   70: 
   71:       - Split existing STBI_NO_HDR flag into two flags, STBI_NO_HDR and
   72:         STBI_NO_LINEAR.
   73:             STBI_NO_HDR:     suppress implementation of .hdr reader format
   74:             STBI_NO_LINEAR:  suppress high-dynamic-range light-linear float API
   75: 
   76:       - You can suppress implementation of any of the decoders to reduce
   77:         your code footprint by #defining one or more of the following
   78:         symbols before creating the implementation.
   79: 
   80:             STBI_NO_JPEG
   81:             STBI_NO_PNG
   82:             STBI_NO_BMP
   83:             STBI_NO_PSD
   84:             STBI_NO_TGA
   85:             STBI_NO_GIF
   86:             STBI_NO_HDR
   87:             STBI_NO_PIC
   88:             STBI_NO_PNM   (.ppm and .pgm)
   89: 
   90:       - You can request *only* certain decoders and suppress all other ones
   91:         (this will be more forward-compatible, as addition of new decoders
   92:         doesn't require you to disable them explicitly):
   93: 
   94:             STBI_ONLY_JPEG
   95:             STBI_ONLY_PNG
   96:             STBI_ONLY_BMP
   97:             STBI_ONLY_PSD
   98:             STBI_ONLY_TGA
   99:             STBI_ONLY_GIF
  100:             STBI_ONLY_HDR
  101:             STBI_ONLY_PIC
  102:             STBI_ONLY_PNM   (.ppm and .pgm)
  103: 
  104:          Note that you can define multiples of these, and you will get all
  105:          of them ("only x" and "only y" is interpreted to mean "only x&y").
  106: 
  107:        - If you use STBI_NO_PNG (or _ONLY_ without PNG), and you still
  108:          want the zlib decoder to be available, #define STBI_SUPPORT_ZLIB
  109: 
  110:       - Compilation of all SIMD code can be suppressed with
  111:             #define STBI_NO_SIMD
  112:         It should not be necessary to disable SIMD unless you have issues
  113:         compiling (e.g. using an x86 compiler which doesn't support SSE
  114:         intrinsics or that doesn't support the method used to detect
  115:         SSE2 support at run-time), and even those can be reported as
  116:         bugs so I can refine the built-in compile-time checking to be
  117:         smarter.
  118: 
  119:       - The old STBI_SIMD system which allowed installing a user-defined
  120:         IDCT etc. has been removed. If you need this, don't upgrade. My
  121:         assumption is that almost nobody was doing this, and those who
  122:         were will find the built-in SIMD more satisfactory anyway.
  123: 
  124:       - RGB values computed for JPEG images are slightly different from
  125:         previous versions of stb_image. (This is due to using less
  126:         integer precision in SIMD.) The C code has been adjusted so
  127:         that the same RGB values will be computed regardless of whether
  128:         SIMD support is available, so your app should always produce
  129:         consistent results. But these results are slightly different from
  130:         previous versions. (Specifically, about 3% of available YCbCr values
  131:         will compute different RGB results from pre-1.49 versions by +-1;
  132:         most of the deviating values are one smaller in the G channel.)
  133: 
  134:       - If you must produce consistent results with previous versions of
  135:         stb_image, #define STBI_JPEG_OLD and you will get the same results
  136:         you used to; however, you will not get the SIMD speedups for
  137:         the YCbCr-to-RGB conversion step (although you should still see
  138:         significant JPEG speedup from the other changes).
  139: 
  140:         Please note that STBI_JPEG_OLD is a temporary feature; it will be
  141:         removed in future versions of the library. It is only intended for
  142:         near-term back-compatibility use.
  143: 
  144: 
  145:    Latest revision history:
  146:       2.06  (2015-04-19) fix bug where PSD returns wrong '*comp' value
  147:       2.05  (2015-04-19) fix bug in progressive JPEG handling, fix warning
  148:       2.04  (2015-04-15) try to re-enable SIMD on MinGW 64-bit
  149:       2.03  (2015-04-12) additional corruption checking
  150:                          stbi_set_flip_vertically_on_load
  151:                          fix NEON support; fix mingw support
  152:       2.02  (2015-01-19) fix incorrect assert, fix warning
  153:       2.01  (2015-01-17) fix various warnings
  154:       2.00b (2014-12-25) fix STBI_MALLOC in progressive JPEG
  155:       2.00  (2014-12-25) optimize JPEG, including x86 SSE2 & ARM NEON SIMD
  156:                          progressive JPEG
  157:                          PGM/PPM support
  158:                          STBI_MALLOC,STBI_REALLOC,STBI_FREE
  159:                          STBI_NO_*, STBI_ONLY_*
  160:                          GIF bugfix
  161:       1.48  (2014-12-14) fix incorrectly-named assert()
  162:       1.47  (2014-12-14) 1/2/4-bit PNG support (both grayscale and paletted)
  163:                          optimize PNG
  164:                          fix bug in interlaced PNG with user-specified channel count
  165: 
  166:    See end of file for full revision history.
  167: 
  168: 
  169:  ============================    Contributors    =========================
  170: 
  171:  Image formats                                Bug fixes & warning fixes
  172:     Sean Barrett (jpeg, png, bmp)                Marc LeBlanc
  173:     Nicolas Schulz (hdr, psd)                    Christpher Lloyd
  174:     Jonathan Dummer (tga)                        Dave Moore
  175:     Jean-Marc Lienher (gif)                      Won Chun
  176:     Tom Seddon (pic)                             the Horde3D community
  177:     Thatcher Ulrich (psd)                        Janez Zemva
  178:     Ken Miller (pgm, ppm)                        Jonathan Blow
  179:                                                  Laurent Gomila
  180:                                                  Aruelien Pocheville
  181:  Extensions, features                            Ryamond Barbiero
  182:     Jetro Lauha (stbi_info)                      David Woo
  183:     Martin "SpartanJ" Golini (stbi_info)         Martin Golini
  184:     James "moose2000" Brown (iPhone PNG)         Roy Eltham
  185:     Ben "Disch" Wenger (io callbacks)            Luke Graham
  186:     Omar Cornut (1/2/4-bit PNG)                  Thomas Ruf
  187:     Nicolas Guillemot (vertical flip)            John Bartholomew
  188:                                                  Ken Hamada
  189:  Optimizations & bugfixes                        Cort Stratton
  190:     Fabian "ryg" Giesen                          Blazej Dariusz Roszkowski
  191:     Arseny Kapoulkine                            Thibault Reuille
  192:                                                  Paul Du Bois
  193:                                                  Guillaume George
  194:   If your name should be here but                Jerry Jansson
  195:   isn't, let Sean know.                          Hayaki Saito
  196:                                                  Johan Duparc
  197:                                                  Ronny Chevalier
  198:                                                  Michal Cichon
  199:                                                  Tero Hanninen
  200:                                                  Sergio Gonzalez
  201:                                                  Cass Everitt
  202:                                                  Engin Manap
  203:                                                  Martins Mozeiko
  204:                                                  Joseph Thomson
  205:                                                  Phil Jordan
  206: 
  207: License:
  208:    This software is in the public domain. Where that dedication is not
  209:    recognized, you are granted a perpetual, irrevocable license to copy
  210:    and modify this file however you want.
  211: 
  212: */
  213  
  214  #ifndef STBI_INCLUDE_STB_IMAGE_H
  215  #define STBI_INCLUDE_STB_IMAGE_H
  216  
  217: // DOCUMENTATION
  218: //
  219: // Limitations:
  220: //    - no 16-bit-per-channel PNG
  221: //    - no 12-bit-per-channel JPEG
  222: //    - no JPEGs with arithmetic coding
  223: //    - no 1-bit BMP
  224: //    - GIF always returns *comp=4
  225: //
  226: // Basic usage (see HDR discussion below for HDR usage):
  227: //    int x,y,n;
  228: //    unsigned char *data = stbi_load(filename, &x, &y, &n, 0);
  229: //    // ... process data if not NULL ...
  230: //    // ... x = width, y = height, n = # 8-bit components per pixel ...
  231: //    // ... replace '0' with '1'..'4' to force that many components per pixel
  232: //    // ... but 'n' will always be the number that it would have been if you said 0
  233: //    stbi_image_free(data)
  234: //
  235: // Standard parameters:
  236: //    int *x       -- outputs image width in pixels
  237: //    int *y       -- outputs image height in pixels
  238: //    int *comp    -- outputs # of image components in image file
  239: //    int req_comp -- if non-zero, # of image components requested in result
  240: //
  241: // The return value from an image loader is an 'unsigned char *' which points
  242: // to the pixel data, or NULL on an allocation failure or if the image is
  243: // corrupt or invalid. The pixel data consists of *y scanlines of *x pixels,
  244: // with each pixel consisting of N interleaved 8-bit components; the first
  245: // pixel pointed to is top-left-most in the image. There is no padding between
  246: // image scanlines or between pixels, regardless of format. The number of
  247: // components N is 'req_comp' if req_comp is non-zero, or *comp otherwise.
  248: // If req_comp is non-zero, *comp has the number of components that _would_
  249: // have been output otherwise. E.g. if you set req_comp to 4, you will always
  250: // get RGBA output, but you can check *comp to see if it's trivially opaque
  251: // because e.g. there were only 3 channels in the source image.
  252: //
  253: // An output image with N components has the following components interleaved
  254: // in this order in each pixel:
  255: //
  256: //     N=#comp     components
  257: //       1           grey
  258: //       2           grey, alpha
  259: //       3           red, green, blue
  260: //       4           red, green, blue, alpha
  261: //
  262: // If image loading fails for any reason, the return value will be NULL,
  263: // and *x, *y, *comp will be unchanged. The function stbi_failure_reason()
  264: // can be queried for an extremely brief, end-user unfriendly explanation
  265: // of why the load failed. Define STBI_NO_FAILURE_STRINGS to avoid
  266: // compiling these strings at all, and STBI_FAILURE_USERMSG to get slightly
  267: // more user-friendly ones.
  268: //
  269: // Paletted PNG, BMP, GIF, and PIC images are automatically depalettized.
  270: //
  271: // ===========================================================================
  272: //
  273: // Philosophy
  274: //
  275: // stb libraries are designed with the following priorities:
  276: //
  277: //    1. easy to use
  278: //    2. easy to maintain
  279: //    3. good performance
  280: //
  281: // Sometimes I let "good performance" creep up in priority over "easy to maintain",
  282: // and for best performance I may provide less-easy-to-use APIs that give higher
  283: // performance, in addition to the easy to use ones. Nevertheless, it's important
  284: // to keep in mind that from the standpoint of you, a client of this library,
  285: // all you care about is #1 and #3, and stb libraries do not emphasize #3 above all.
  286: //
  287: // Some secondary priorities arise directly from the first two, some of which
  288: // make more explicit reasons why performance can't be emphasized.
  289: //
  290: //    - Portable ("ease of use")
  291: //    - Small footprint ("easy to maintain")
  292: //    - No dependencies ("ease of use")
  293: //
  294: // ===========================================================================
  295: //
  296: // I/O callbacks
  297: //
  298: // I/O callbacks allow you to read from arbitrary sources, like packaged
  299: // files or some other source. Data read from callbacks are processed
  300: // through a small internal buffer (currently 128 bytes) to try to reduce
  301: // overhead.
  302: //
  303: // The three functions you must define are "read" (reads some bytes of data),
  304: // "skip" (skips some bytes of data), "eof" (reports if the stream is at the end).
  305: //
  306: // ===========================================================================
  307: //
  308: // SIMD support
  309: //
  310: // The JPEG decoder will try to automatically use SIMD kernels on x86 when
  311: // supported by the compiler. For ARM Neon support, you must explicitly
  312: // request it.
  313: //
  314: // (The old do-it-yourself SIMD API is no longer supported in the current
  315: // code.)
  316: //
  317: // On x86, SSE2 will automatically be used when available based on a run-time
  318: // test; if not, the generic C versions are used as a fall-back. On ARM targets,
  319: // the typical path is to have separate builds for NEON and non-NEON devices
  320: // (at least this is true for iOS and Android). Therefore, the NEON support is
  321: // toggled by a build flag: define STBI_NEON to get NEON loops.
  322: //
  323: // The output of the JPEG decoder is slightly different from versions where
  324: // SIMD support was introduced (that is, for versions before 1.49). The
  325: // difference is only +-1 in the 8-bit RGB channels, and only on a small
  326: // fraction of pixels. You can force the pre-1.49 behavior by defining
  327: // STBI_JPEG_OLD, but this will disable some of the SIMD decoding path
  328: // and hence cost some performance.
  329: //
  330: // If for some reason you do not want to use any of SIMD code, or if
  331: // you have issues compiling it, you can disable it entirely by
  332: // defining STBI_NO_SIMD.
  333: //
  334: // ===========================================================================
  335: //
  336: // HDR image support   (disable by defining STBI_NO_HDR)
  337: //
  338: // stb_image now supports loading HDR images in general, and currently
  339: // the Radiance .HDR file format, although the support is provided
  340: // generically. You can still load any file through the existing interface;
  341: // if you attempt to load an HDR file, it will be automatically remapped to
  342: // LDR, assuming gamma 2.2 and an arbitrary scale factor defaulting to 1;
  343: // both of these constants can be reconfigured through this interface:
  344: //
  345: //     stbi_hdr_to_ldr_gamma(2.2f);
  346: //     stbi_hdr_to_ldr_scale(1.0f);
  347: //
  348: // (note, do not use _inverse_ constants; stbi_image will invert them
  349: // appropriately).
  350: //
  351: // Additionally, there is a new, parallel interface for loading files as
  352: // (linear) floats to preserve the full dynamic range:
  353: //
  354: //    float *data = stbi_loadf(filename, &x, &y, &n, 0);
  355: //
  356: // If you load LDR images through this interface, those images will
  357: // be promoted to floating point values, run through the inverse of
  358: // constants corresponding to the above:
  359: //
  360: //     stbi_ldr_to_hdr_scale(1.0f);
  361: //     stbi_ldr_to_hdr_gamma(2.2f);
  362: //
  363: // Finally, given a filename (or an open file or memory block--see header
  364: // file for details) containing image data, you can query for the "most
  365: // appropriate" interface to use (that is, whether the image is HDR or
  366: // not), using:
  367: //
  368: //     stbi_is_hdr(char *filename);
  369: //
  370: // ===========================================================================
  371: //
  372: // iPhone PNG support:
  373: //
  374: // By default we convert iphone-formatted PNGs back to RGB, even though
  375: // they are internally encoded differently. You can disable this conversion
  376: // by by calling stbi_convert_iphone_png_to_rgb(0), in which case
  377: // you will always just get the native iphone "format" through (which
  378: // is BGR stored in RGB).
  379: //
  380: // Call stbi_set_unpremultiply_on_load(1) as well to force a divide per
  381: // pixel to remove any premultiplied alpha *only* if the image file explicitly
  382: // says there's premultiplied data (currently only happens in iPhone images,
  383: // and only if iPhone convert-to-rgb processing is on).
  384: //
  385  
  386  
  387  #ifndef STBI_NO_STDIO
  388  #include <stdio.h>
  389: #endif // STBI_NO_STDIO
  390  
  391  #define STBI_VERSION 1
  ...
  393  enum
  394  {
  395:    STBI_default = 0, // only used for req_comp
  396  
  397     STBI_grey       = 1,
  ...
  413  #endif
  414  
  415: //////////////////////////////////////////////////////////////////////////////
  416: //
  417: // PRIMARY API - works on images of any type
  418: //
  419  
  420: //
  421: // load image by filename, open file, or memory buffer
  422: //
  423  
  424  typedef struct
  425  {
  426:    int      (*read)  (void *user,char *data,int size);   // fill 'data' with 'size' bytes.  return number of bytes actually read
  427:    void     (*skip)  (void *user,int n);                 // skip the next 'n' bytes, or 'unget' the last -n bytes if negative
  428:    int      (*eof)   (void *user);                       // returns nonzero if we are at end of file/data
  429  } stbi_io_callbacks;
  430  
  ...
  435  #ifndef STBI_NO_STDIO
  436  STBIDEF stbi_uc *stbi_load_from_file  (FILE *f,                  int *x, int *y, int *comp, int req_comp);
  437: // for stbi_load_from_file, file pointer is left pointing immediately after image
  438  #endif
  439  
  ...
  456     STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma);
  457     STBIDEF void   stbi_ldr_to_hdr_scale(float scale);
  458: #endif // STBI_NO_HDR
  459  
  460: // stbi_is_hdr is always defined, but always returns false if STBI_NO_HDR
  461  STBIDEF int    stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user);
  462  STBIDEF int    stbi_is_hdr_from_memory(stbi_uc const *buffer, int len);
  ...
  464  STBIDEF int      stbi_is_hdr          (char const *filename);
  465  STBIDEF int      stbi_is_hdr_from_file(FILE *f);
  466: #endif // STBI_NO_STDIO
  467  
  468  
  469: // get a VERY brief reason for failure
  470: // NOT THREADSAFE
  471  STBIDEF const char *stbi_failure_reason  (void);
  472  
  473: // free the loaded image -- this is just free()
  474  STBIDEF void     stbi_image_free      (void *retval_from_stbi_load);
  475  
  476: // get image dimensions & components without fully decoding
  477  STBIDEF int      stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp);
  478  STBIDEF int      stbi_info_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp);
  ...
  486  
  487  
  488: // for image formats that explicitly notate that they have premultiplied alpha,
  489: // we just return the colors as stored in the file. set this flag to force
  490: // unpremultiplication. results are undefined if the unpremultiply overflow.
  491  STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply);
  492  
  493: // indicate whether we should process iphone images back to canonical format,
  494: // or just pass them through "as-is"
  495  STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert);
  496  
  497: // flip the image vertically, so the first pixel in the output array is the bottom left
  498  STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip);
  499  
  500: // ZLIB client - used by PNG, available for other purposes
  501  
  502  STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen);
  ...
  513  #endif
  514  
  515: //
  516: //
  517: ////   end header file   /////////////////////////////////////////////////////
  518: #endif // STBI_INCLUDE_STB_IMAGE_H
  519  
  520  #ifdef STB_IMAGE_IMPLEMENTATION
  ...
  559  
  560  #include <stdarg.h>
  561: #include <stddef.h> // ptrdiff_t on osx
  562  #include <stdlib.h>
  563  #include <string.h>
  564  
  565  #if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR)
  566: #include <math.h>  // ldexp
  567  #endif
  568  
  ...
  601  #endif
  602  
  603: // should produce compiler error if size is wrong
  604  typedef unsigned char validate_uint32[sizeof(stbi__uint32)==4 ? 1 : -1];
  605  
  ...
  621  
  622  #if defined(STBI_MALLOC) && defined(STBI_FREE) && defined(STBI_REALLOC)
  623: // ok
  624  #elif !defined(STBI_MALLOC) && !defined(STBI_FREE) && !defined(STBI_REALLOC)
  625: // ok
  626  #else
  627  #error "Must define all or none of STBI_MALLOC, STBI_FREE, and STBI_REALLOC."
  ...
  634  #endif
  635  
  636: // x86/x64 detection
  637  #if defined(__x86_64__) || defined(_M_X64)
  638  #define STBI__X64_TARGET
  ...
  642  
  643  #if defined(__GNUC__) && (defined(STBI__X86_TARGET) || defined(STBI__X64_TARGET)) && !defined(__SSE2__) && !defined(STBI_NO_SIMD)
  644: // NOTE: not clear do we actually need this for the 64-bit path?
  645: // gcc doesn't support sse2 intrinsics unless you compile with -msse2,
  646: // (but compiling with -msse2 allows the compiler to use SSE2 everywhere;
  647: // this is just broken and gcc are jerks for not fixing it properly
  648: // http://www.virtualdub.org/blog/pivot/entry.php?id=363 )
  649  #define STBI_NO_SIMD
  650  #endif
  651  
  652  #if defined(__MINGW32__) && defined(STBI__X86_TARGET) && !defined(STBI_MINGW_ENABLE_SSE2) && !defined(STBI_NO_SIMD)
  653: // Note that __MINGW32__ doesn't actually mean 32-bit, so we have to avoid STBI__X64_TARGET
  654: //
  655: // 32-bit MinGW wants ESP to be 16-byte aligned, but this is not in the
  656: // Windows ABI and VC++ as well as Windows DLLs don't maintain that invariant.
  657: // As a result, enabling SSE2 on 32-bit MinGW is dangerous when not
  658: // simultaneously enabling "-mstackrealign".
  659: //
  660: // See https://github.com/nothings/stb/issues/81 for more information.
  661: //
  662: // So default to no SSE2 on 32-bit MinGW. If you've read this far and added
  663: // -mstackrealign to your build settings, feel free to #define STBI_MINGW_ENABLE_SSE2.
  664  #define STBI_NO_SIMD
  665  #endif
  ...
  671  #ifdef _MSC_VER
  672  
  673: #if _MSC_VER >= 1400  // not VC6
  674: #include <intrin.h> // __cpuid
  675  static int stbi__cpuid3(void)
  676  {
  ...
  699     return ((info3 >> 26) & 1) != 0;
  700  }
  701: #else // assume GCC-style if not VC++
  702  #define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))
  703  
  704  static int stbi__sse2_available()
  705  {
  706: #if defined(__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__) >= 408 // GCC 4.8 or later
  707:    // GCC 4.8+ has a nice way to do this
  708     return __builtin_cpu_supports("sse2");
  709  #else
  710:    // portable way to do this, preferably without using GCC inline ASM?
  711:    // just bail for now.
  712     return 0;
  713  #endif
  ...
  716  #endif
  717  
  718: // ARM NEON
  719  #if defined(STBI_NO_SIMD) && defined(STBI_NEON)
  720  #undef STBI_NEON
  ...
  723  #ifdef STBI_NEON
  724  #include <arm_neon.h>
  725: // assume GCC or Clang on ARM targets
  726  #define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))
  727  #endif
  ...
  731  #endif
  732  
  733: ///////////////////////////////////////////////
  734: //
  735: //  stbi__context struct and start_xxx functions
  736  
  737: // stbi__context structure is our basic context used by all images, so it
  738: // contains all the IO context, plus some basic image information
  739  typedef struct
  740  {
  ...
  756  static void stbi__refill_buffer(stbi__context *s);
  757  
  758: // initialize a memory-decode context
  759  static void stbi__start_mem(stbi__context *s, stbi_uc const *buffer, int len)
  760  {
  ...
  765  }
  766  
  767: // initialize a callback-based context
  768  static void stbi__start_callbacks(stbi__context *s, stbi_io_callbacks *c, void *user)
  769  {
  ...
  805  }
  806  
  807: //static void stop_file(stbi__context *s) { }
  808  
  809: #endif // !STBI_NO_STDIO
  810  
  811  static void stbi__rewind(stbi__context *s)
  812  {
  813:    // conceptually rewind SHOULD rewind to the beginning of the stream,
  814:    // but we just rewind to the beginning of the initial buffer, because
  815:    // we only use it after doing 'test', which only ever looks at at most 92 bytes
  816     s->img_buffer = s->img_buffer_original;
  817  }
  ...
  871  #endif
  872  
  873: // this is not threadsafe
  874  static const char *stbi__g_failure_reason;
  875  
  ...
  890  }
  891  
  892: // stbi__err - error
  893: // stbi__errpf - error returning pointer to float
  894: // stbi__errpuc - error returning pointer to unsigned char
  895  
  896  #ifdef STBI_NO_FAILURE_STRINGS
  ...
  957  
  958     #ifndef STBI_NO_TGA
  959:    // test tga last because it's a crappy test!
  960     if (stbi__tga_test(s))
  961        return stbi__tga_load(s,x,y,comp,req_comp);
  ...
  975        stbi_uc temp;
  976  
  977:       // @OPTIMIZE: use a bigger temp buffer and memcpy multiple pixels at once
  978        for (row = 0; row < (h>>1); row++) {
  979           for (col = 0; col < w; col++) {
  ...
  998        float temp;
  999  
 1000:       // @OPTIMIZE: use a bigger temp buffer and memcpy multiple pixels at once
 1001        for (row = 0; row < (h>>1); row++) {
 1002           for (col = 0; col < w; col++) {
 ....
 1044     result = stbi__load_flip(&s,x,y,comp,req_comp);
 1045     if (result) {
 1046:       // need to 'unget' all the characters in the IO buffer
 1047        fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
 1048     }
 1049     return result;
 1050  }
 1051: #endif //!STBI_NO_STDIO
 1052  
 1053  STBIDEF stbi_uc *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
 ....
 1114     return stbi__loadf_main(&s,x,y,comp,req_comp);
 1115  }
 1116: #endif // !STBI_NO_STDIO
 1117  
 1118: #endif // !STBI_NO_LINEAR
 1119  
 1120: // these is-hdr-or-not is defined independent of whether STBI_NO_LINEAR is
 1121: // defined, for API simplicity; if STBI_NO_LINEAR is defined, it always
 1122: // reports false!
 1123  
 1124  STBIDEF int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)
 ....
 1157     #endif
 1158  }
 1159: #endif // !STBI_NO_STDIO
 1160  
 1161  STBIDEF int      stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user)
 ....
 1182  
 1183  
 1184: //////////////////////////////////////////////////////////////////////////////
 1185: //
 1186: // Common code used by all image loaders
 1187: //
 1188  
 1189  enum
 ....
 1198     int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);
 1199     if (n == 0) {
 1200:       // at end of file, treat same as if from memory, but need to handle case
 1201:       // where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file
 1202        s->read_from_callbacks = 0;
 1203        s->img_buffer = s->buffer_start;
 ....
 1225     if (s->io.read) {
 1226        if (!(s->io.eof)(s->io_user_data)) return 0;
 1227:       // if feof() is true, check if buffer = end
 1228:       // special case: we've only got the special 0 character at the end
 1229        if (s->read_from_callbacks == 0) return 1;
 1230     }
 ....
 1298  }
 1299  
 1300: #define STBI__BYTECAST(x)  ((stbi_uc) ((x) & 255))  // truncate int to byte without warnings
 1301  
 1302  
 1303: //////////////////////////////////////////////////////////////////////////////
 1304: //
 1305: //  generic converter from built-in img_n to req_comp
 1306: //    individual types do this automatically as much as possible (e.g. jpeg
 1307: //    does all cases internally since it needs to colorspace convert anyway,
 1308: //    and it never has alpha, so very few cases ). png can automatically
 1309: //    interleave an alpha=255 channel, but falls back to this for other cases
 1310: //
 1311: //  assume data buffer is malloced, so malloc a new one and free that one
 1312: //  only failure mode is malloc failing
 1313  
 1314  static stbi_uc stbi__compute_y(int r, int g, int b)
 ....
 1337        #define COMBO(a,b)  ((a)*8+(b))
 1338        #define CASE(a,b)   case COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
 1339:       // convert source image with img_n components to one with req_comp components;
 1340:       // avoid switch per pixel, so use switch per scanline and massive macros
 1341        switch (COMBO(img_n, req_comp)) {
 1342           CASE(1,2) dest[0]=src[0], dest[1]=255; break;
 ....
 1367     float *output = (float *) stbi__malloc(x * y * comp * sizeof(float));
 1368     if (output == NULL) { STBI_FREE(data); return stbi__errpf("outofmem", "Out of memory"); }
 1369:    // compute number of non-alpha components
 1370     if (comp & 1) n = comp; else n = comp-1;
 1371     for (i=0; i < x*y; ++i) {
 ....
 1387     stbi_uc *output = (stbi_uc *) stbi__malloc(x * y * comp);
 1388     if (output == NULL) { STBI_FREE(data); return stbi__errpuc("outofmem", "Out of memory"); }
 1389:    // compute number of non-alpha components
 1390     if (comp & 1) n = comp; else n = comp-1;
 1391     for (i=0; i < x*y; ++i) {
 ....
 1408  #endif
 1409  
 1410: //////////////////////////////////////////////////////////////////////////////
 1411: //
 1412: //  "baseline" JPEG/JFIF decoder
 1413: //
 1414: //    simple implementation
 1415: //      - doesn't support delayed output of y-dimension
 1416: //      - simple interface (only one output format: 8-bit interleaved RGB)
 1417: //      - doesn't try to recover corrupt jpegs
 1418: //      - doesn't allow partial loading, loading multiple at once
 1419: //      - still fast on x86 (copying globals into locals doesn't help x86)
 1420: //      - allocates lots of intermediate memory (full size of all components)
 1421: //        - non-interleaved case requires this anyway
 1422: //        - allows good upsampling (see next)
 1423: //    high-quality
 1424: //      - upsampled channels are bilinearly interpolated, even across blocks
 1425: //      - quality integer IDCT derived from IJG's 'slow'
 1426: //    performance
 1427: //      - fast huffman; reasonable integer IDCT
 1428: //      - some SIMD kernels for common paths on targets with SSE2/NEON
 1429: //      - uses a lot of intermediate memory, could cache poorly
 1430  
 1431  #ifndef STBI_NO_JPEG
 1432  
 1433: // huffman decoding acceleration
 1434: #define FAST_BITS   9  // larger handles more cases; smaller stomps less cache
 1435  
 1436  typedef struct
 1437  {
 1438     stbi_uc  fast[1 << FAST_BITS];
 1439:    // weirdly, repacking this into AoS is a 10% speed loss, instead of a win
 1440     stbi__uint16 code[256];
 1441     stbi_uc  values[256];
 1442     stbi_uc  size[257];
 1443     unsigned int maxcode[18];
 1444:    int    delta[17];   // old 'firstsymbol' - old 'firstcode'
 1445  } stbi__huffman;
 1446  
 ....
 1453     stbi__int16 fast_ac[4][1 << FAST_BITS];
 1454  
 1455: // sizes for components, interleaved MCUs
 1456     int img_h_max, img_v_max;
 1457     int img_mcu_x, img_mcu_y;
 1458     int img_mcu_w, img_mcu_h;
 1459  
 1460: // definition of jpeg image component
 1461     struct
 1462     {
 ....
 1471        void *raw_data, *raw_coeff;
 1472        stbi_uc *linebuf;
 1473:       short   *coeff;   // progressive only
 1474:       int      coeff_w, coeff_h; // number of 8x8 coefficient blocks
 1475     } img_comp[4];
 1476  
 1477:    stbi__uint32   code_buffer; // jpeg entropy-coded buffer
 1478:    int            code_bits;   // number of valid bits
 1479:    unsigned char  marker;      // marker seen while filling entropy buffer
 1480:    int            nomore;      // flag if we saw a marker so must stop
 1481  
 1482     int            progressive;
 ....
 1490     int restart_interval, todo;
 1491  
 1492: // kernels
 1493     void (*idct_block_kernel)(stbi_uc *out, int out_stride, short data[64]);
 1494     void (*YCbCr_to_RGB_kernel)(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step);
 ....
 1499  {
 1500     int i,j,k=0,code;
 1501:    // build size list for each symbol (from JPEG spec)
 1502     for (i=0; i < 16; ++i)
 1503        for (j=0; j < count[i]; ++j)
 ....
 1505     h->size[k] = 0;
 1506  
 1507:    // compute actual symbols (from jpeg spec)
 1508     code = 0;
 1509     k = 0;
 1510     for(j=1; j <= 16; ++j) {
 1511:       // compute delta to add to code to compute symbol id
 1512        h->delta[j] = k - code;
 1513        if (h->size[k] == j) {
 ....
 1516           if (code-1 >= (1 << j)) return stbi__err("bad code lengths","Corrupt JPEG");
 1517        }
 1518:       // compute largest code + 1 for this size, preshifted as needed later
 1519        h->maxcode[j] = code << (16-j);
 1520        code <<= 1;
 ....
 1522     h->maxcode[j] = 0xffffffff;
 1523  
 1524:    // build non-spec acceleration table; 255 is flag for not-accelerated
 1525     memset(h->fast, 255, 1 << FAST_BITS);
 1526     for (i=0; i < k; ++i) {
 ....
 1537  }
 1538  
 1539: // build a table that decodes both magnitude and value of small ACs in
 1540: // one go.
 1541  static void stbi__build_fast_ac(stbi__int16 *fast_ac, stbi__huffman *h)
 1542  {
 ....
 1552  
 1553           if (magbits && len + magbits <= FAST_BITS) {
 1554:             // magnitude code followed by receive_extend code
 1555              int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);
 1556              int m = 1 << (magbits - 1);
 1557              if (k < m) k += (-1 << magbits) + 1;
 1558:             // if the result is small enough, we can fit it in fast_ac table
 1559              if (k >= -128 && k <= 127)
 1560                 fast_ac[i] = (stbi__int16) ((k << 8) + (run << 4) + (len + magbits));
 ....
 1581  }
 1582  
 1583: // (1 << n) - 1
 1584  static stbi__uint32 stbi__bmask[17]={0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535};
 1585  
 1586: // decode a jpeg huffman value from the bitstream
 1587  stbi_inline static int stbi__jpeg_huff_decode(stbi__jpeg *j, stbi__huffman *h)
 1588  {
 ....
 1592     if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
 1593  
 1594:    // look at the top FAST_BITS and determine what symbol ID it is,
 1595:    // if the code is <= FAST_BITS
 1596     c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
 1597     k = h->fast[c];
 ....
 1605     }
 1606  
 1607:    // naive test is to shift the code_buffer down so k bits are
 1608:    // valid, then test against maxcode. To speed this up, we've
 1609:    // preshifted maxcode left so that it has (16-k) 0s at the
 1610:    // end; in other words, regardless of the number of bits, it
 1611:    // wants to be compared against something shifted to have 16;
 1612:    // that way we don't need to shift inside the loop.
 1613     temp = j->code_buffer >> 16;
 1614     for (k=FAST_BITS+1 ; ; ++k)
 ....
 1616           break;
 1617     if (k == 17) {
 1618:       // error! code not found
 1619        j->code_bits -= 16;
 1620        return -1;
 ....
 1624        return -1;
 1625  
 1626:    // convert the huffman code to the symbol id
 1627     c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];
 1628     STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);
 1629  
 1630:    // convert the id to a symbol
 1631     j->code_bits -= k;
 1632     j->code_buffer <<= k;
 ....
 1634  }
 1635  
 1636: // bias[n] = (-1<<n) + 1
 1637  static int const stbi__jbias[16] = {0,-1,-3,-7,-15,-31,-63,-127,-255,-511,-1023,-2047,-4095,-8191,-16383,-32767};
 1638  
 1639: // combined JPEG 'receive' and JPEG 'extend', since baseline
 1640: // always extends everything it receives.
 1641  stbi_inline static int stbi__extend_receive(stbi__jpeg *j, int n)
 1642  {
 ....
 1645     if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
 1646  
 1647:    sgn = (stbi__int32)j->code_buffer >> 31; // sign bit is always in MSB
 1648     k = stbi_lrot(j->code_buffer, n);
 1649     STBI_ASSERT(n >= 0 && n < (int) (sizeof(stbi__bmask)/sizeof(*stbi__bmask)));
 ....
 1654  }
 1655  
 1656: // get some unsigned bits
 1657  stbi_inline static int stbi__jpeg_get_bits(stbi__jpeg *j, int n)
 1658  {
 ....
 1676  }
 1677  
 1678: // given a value that's at position X in the zigzag stream,
 1679: // where does it appear in the 8x8 matrix coded as row-major?
 1680  static stbi_uc stbi__jpeg_dezigzag[64+15] =
 1681  {
 ....
 1688     58, 59, 52, 45, 38, 31, 39, 46,
 1689     53, 60, 61, 54, 47, 55, 62, 63,
 1690:    // let corrupt input sample past end
 1691     63, 63, 63, 63, 63, 63, 63, 63,
 1692     63, 63, 63, 63, 63, 63, 63
 1693  };
 1694  
 1695: // decode one 64-entry block--
 1696  static int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi_uc *dequant)
 1697  {
 ....
 1703     if (t < 0) return stbi__err("bad huffman code","Corrupt JPEG");
 1704  
 1705:    // 0 all the ac values now so we can do it 32-bits at a time
 1706     memset(data,0,64*sizeof(data[0]));
 1707  
 ....
 1711     data[0] = (short) (dc * dequant[0]);
 1712  
 1713:    // decode AC components, see JPEG spec
 1714     k = 1;
 1715     do {
 ....
 1719        c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
 1720        r = fac[c];
 1721:       if (r) { // fast-AC path
 1722:          k += (r >> 4) & 15; // run
 1723:          s = r & 15; // combined length
 1724           j->code_buffer <<= s;
 1725           j->code_bits -= s;
 1726:          // decode into unzigzag'd location
 1727           zig = stbi__jpeg_dezigzag[k++];
 1728           data[zig] = (short) ((r >> 8) * dequant[zig]);
 ....
 1733           r = rs >> 4;
 1734           if (s == 0) {
 1735:             if (rs != 0xf0) break; // end block
 1736              k += 16;
 1737           } else {
 1738              k += r;
 1739:             // decode into unzigzag'd location
 1740              zig = stbi__jpeg_dezigzag[k++];
 1741              data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);
 ....
 1755  
 1756     if (j->succ_high == 0) {
 1757:       // first scan for DC coefficient, must be first
 1758:       memset(data,0,64*sizeof(data[0])); // 0 all the ac values now
 1759        t = stbi__jpeg_huff_decode(j, hdc);
 1760        diff = t ? stbi__extend_receive(j, t) : 0;
 ....
 1764        data[0] = (short) (dc << j->succ_low);
 1765     } else {
 1766:       // refinement scan for DC coefficient
 1767        if (stbi__jpeg_get_bit(j))
 1768           data[0] += (short) (1 << j->succ_low);
 ....
 1771  }
 1772  
 1773: // @OPTIMIZE: store non-zigzagged during the decode passes,
 1774: // and only de-zigzag when dequantizing
 1775  static int stbi__jpeg_decode_block_prog_ac(stbi__jpeg *j, short data[64], stbi__huffman *hac, stbi__int16 *fac)
 1776  {
 ....
 1793           c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
 1794           r = fac[c];
 1795:          if (r) { // fast-AC path
 1796:             k += (r >> 4) & 15; // run
 1797:             s = r & 15; // combined length
 1798              j->code_buffer <<= s;
 1799              j->code_bits -= s;
 ....
 1822        } while (k <= j->spec_end);
 1823     } else {
 1824:       // refinement scan for these AC coefficients
 1825  
 1826        short bit = (short) (1 << j->succ_low);
 ....
 1843           do {
 1844              int r,s;
 1845:             int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh
 1846              if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
 1847              s = rs & 15;
 ....
 1852                    if (r)
 1853                       j->eob_run += stbi__jpeg_get_bits(j, r);
 1854:                   r = 64; // force end of block
 1855                 } else {
 1856:                   // r=15 s=0 should write 16 0s, so we just do
 1857:                   // a run of 15 0s and then write s (which is 0),
 1858:                   // so we don't have to do anything special here
 1859                 }
 1860              } else {
 1861                 if (s != 1) return stbi__err("bad huffman code", "Corrupt JPEG");
 1862:                // sign bit
 1863                 if (stbi__jpeg_get_bit(j))
 1864                    s = bit;
 ....
 1867              }
 1868  
 1869:             // advance by r
 1870              while (k <= j->spec_end) {
 1871                 short *p = &data[stbi__jpeg_dezigzag[k++]];
 ....
 1892  }
 1893  
 1894: // take a -128..127 value and stbi__clamp it and convert to 0..255
 1895  stbi_inline static stbi_uc stbi__clamp(int x)
 1896  {
 1897:    // trick to use a single test to catch both cases
 1898     if ((unsigned int) x > 255) {
 1899        if (x < 0) return 0;
 ....
 1906  #define stbi__fsh(x)  ((x) << 12)
 1907  
 1908: // derived from jidctint -- DCT_ISLOW
 1909  #define STBI__IDCT_1D(s0,s1,s2,s3,s4,s5,s6,s7) \
 1910     int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; \
 ....
 1950     short *d = data;
 1951  
 1952:    // columns
 1953     for (i=0; i < 8; ++i,++d, ++v) {
 1954:       // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
 1955        if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
 1956             && d[40]==0 && d[48]==0 && d[56]==0) {
 1957:          //    no shortcut                 0     seconds
 1958:          //    (1|2|3|4|5|6|7)==0          0     seconds
 1959:          //    all separate               -0.047 seconds
 1960:          //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
 1961           int dcterm = d[0] << 2;
 1962           v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;
 1963        } else {
 1964           STBI__IDCT_1D(d[ 0],d[ 8],d[16],d[24],d[32],d[40],d[48],d[56])
 1965:          // constants scaled things up by 1<<12; let's bring them back
 1966:          // down, but keep 2 extra bits of precision
 1967           x0 += 512; x1 += 512; x2 += 512; x3 += 512;
 1968           v[ 0] = (x0+t3) >> 10;
 ....
 1978  
 1979     for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {
 1980:       // no fast case since the first 1D IDCT spread components out
 1981        STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])
 1982:       // constants scaled things up by 1<<12, plus we had 1<<2 from first
 1983:       // loop, plus horizontal and vertical each scale by sqrt(8) so together
 1984:       // we've got an extra 1<<3, so 1<<17 total we need to remove.
 1985:       // so we want to round that, which means adding 0.5 * 1<<17,
 1986:       // aka 65536. Also, we'll end up with -128 to 127 that we want
 1987:       // to encode as 0..255 by adding 128, so we'll add that before the shift
 1988        x0 += 65536 + (128<<17);
 1989        x1 += 65536 + (128<<17);
 1990        x2 += 65536 + (128<<17);
 1991        x3 += 65536 + (128<<17);
 1992:       // tried computing the shifts into temps, or'ing the temps to see
 1993:       // if any were out of range, but that was slower
 1994        o[0] = stbi__clamp((x0+t3) >> 17);
 1995        o[7] = stbi__clamp((x0-t3) >> 17);
 ....
 2004  
 2005  #ifdef STBI_SSE2
 2006: // sse2 integer IDCT. not the fastest possible implementation but it
 2007: // produces bit-identical results to the generic C version so it's
 2008: // fully "transparent".
 2009  static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
 2010  {
 2011:    // This is constructed to match our regular (generic) integer IDCT exactly.
 2012     __m128i row0, row1, row2, row3, row4, row5, row6, row7;
 2013     __m128i tmp;
 2014  
 2015:    // dot product constant: even elems=x, odd elems=y
 2016     #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))
 2017  
 2018:    // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)
 2019:    // out(1) = c1[even]*x + c1[odd]*y
 2020     #define dct_rot(out0,out1, x,y,c0,c1) \
 2021        __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \
 ....
 2026        __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)
 2027  
 2028:    // out = in << 12  (in 16-bit, out 32-bit)
 2029     #define dct_widen(out, in) \
 2030        __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \
 2031        __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)
 2032  
 2033:    // wide add
 2034     #define dct_wadd(out, a, b) \
 2035        __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \
 2036        __m128i out##_h = _mm_add_epi32(a##_h, b##_h)
 2037  
 2038:    // wide sub
 2039     #define dct_wsub(out, a, b) \
 2040        __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \
 2041        __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)
 2042  
 2043:    // butterfly a/b, add bias, then shift by "s" and pack
 2044     #define dct_bfly32o(out0, out1, a,b,bias,s) \
 2045        { \
 ....
 2052        }
 2053  
 2054:    // 8-bit interleave step (for transposes)
 2055     #define dct_interleave8(a, b) \
 2056        tmp = a; \
 ....
 2058        b = _mm_unpackhi_epi8(tmp, b)
 2059  
 2060:    // 16-bit interleave step (for transposes)
 2061     #define dct_interleave16(a, b) \
 2062        tmp = a; \
 ....
 2066     #define dct_pass(bias,shift) \
 2067        { \
 2068:          /* even part */ \
 2069           dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \
 2070           __m128i sum04 = _mm_add_epi16(row0, row4); \
 ....
 2076           dct_wadd(x1, t1e, t2e); \
 2077           dct_wsub(x2, t1e, t2e); \
 2078:          /* odd part */ \
 2079           dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \
 2080           dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \
 ....
 2101     __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f( 1.501321110f));
 2102  
 2103:    // rounding biases in column/row passes, see stbi__idct_block for explanation.
 2104     __m128i bias_0 = _mm_set1_epi32(512);
 2105     __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));
 2106  
 2107:    // load
 2108     row0 = _mm_load_si128((const __m128i *) (data + 0*8));
 2109     row1 = _mm_load_si128((const __m128i *) (data + 1*8));
 ....
 2115     row7 = _mm_load_si128((const __m128i *) (data + 7*8));
 2116  
 2117:    // column pass
 2118     dct_pass(bias_0, 10);
 2119  
 2120     {
 2121:       // 16bit 8x8 transpose pass 1
 2122        dct_interleave16(row0, row4);
 2123        dct_interleave16(row1, row5);
 ....
 2125        dct_interleave16(row3, row7);
 2126  
 2127:       // transpose pass 2
 2128        dct_interleave16(row0, row2);
 2129        dct_interleave16(row1, row3);
 ....
 2131        dct_interleave16(row5, row7);
 2132  
 2133:       // transpose pass 3
 2134        dct_interleave16(row0, row1);
 2135        dct_interleave16(row2, row3);
 ....
 2138     }
 2139  
 2140:    // row pass
 2141     dct_pass(bias_1, 17);
 2142  
 2143     {
 2144:       // pack
 2145:       __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7
 2146        __m128i p1 = _mm_packus_epi16(row2, row3);
 2147        __m128i p2 = _mm_packus_epi16(row4, row5);
 2148        __m128i p3 = _mm_packus_epi16(row6, row7);
 2149  
 2150:       // 8bit 8x8 transpose pass 1
 2151:       dct_interleave8(p0, p2); // a0e0a1e1...
 2152:       dct_interleave8(p1, p3); // c0g0c1g1...
 2153  
 2154:       // transpose pass 2
 2155:       dct_interleave8(p0, p1); // a0c0e0g0...
 2156:       dct_interleave8(p2, p3); // b0d0f0h0...
 2157  
 2158:       // transpose pass 3
 2159:       dct_interleave8(p0, p2); // a0b0c0d0...
 2160:       dct_interleave8(p1, p3); // a4b4c4d4...
 2161  
 2162:       // store
 2163        _mm_storel_epi64((__m128i *) out, p0); out += out_stride;
 2164        _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;
 ....
 2182  }
 2183  
 2184: #endif // STBI_SSE2
 2185  
 2186  #ifdef STBI_NEON
 2187  
 2188: // NEON integer IDCT. should produce bit-identical
 2189: // results to the generic C version.
 2190  static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
 2191  {
 ....
 2217     int32x4_t out##_h = vshll_n_s16(vget_high_s16(inq), 12)
 2218  
 2219: // wide add
 2220  #define dct_wadd(out, a, b) \
 2221     int32x4_t out##_l = vaddq_s32(a##_l, b##_l); \
 2222     int32x4_t out##_h = vaddq_s32(a##_h, b##_h)
 2223  
 2224: // wide sub
 2225  #define dct_wsub(out, a, b) \
 2226     int32x4_t out##_l = vsubq_s32(a##_l, b##_l); \
 2227     int32x4_t out##_h = vsubq_s32(a##_h, b##_h)
 2228  
 2229: // butterfly a/b, then shift using "shiftop" by "s" and pack
 2230  #define dct_bfly32o(out0,out1, a,b,shiftop,s) \
 2231     { \
 ....
 2238  #define dct_pass(shiftop, shift) \
 2239     { \
 2240:       /* even part */ \
 2241        int16x8_t sum26 = vaddq_s16(row2, row6); \
 2242        dct_long_mul(p1e, sum26, rot0_0); \
 ....
 2251        dct_wadd(x1, t1e, t2e); \
 2252        dct_wsub(x2, t1e, t2e); \
 2253:       /* odd part */ \
 2254        int16x8_t sum15 = vaddq_s16(row1, row5); \
 2255        int16x8_t sum17 = vaddq_s16(row1, row7); \
 ....
 2276     }
 2277  
 2278:    // load
 2279     row0 = vld1q_s16(data + 0*8);
 2280     row1 = vld1q_s16(data + 1*8);
 ....
 2286     row7 = vld1q_s16(data + 7*8);
 2287  
 2288:    // add DC bias
 2289     row0 = vaddq_s16(row0, vsetq_lane_s16(1024, vdupq_n_s16(0), 0));
 2290  
 2291:    // column pass
 2292     dct_pass(vrshrn_n_s32, 10);
 2293  
 2294:    // 16bit 8x8 transpose
 2295     {
 2296: // these three map to a single VTRN.16, VTRN.32, and VSWP, respectively.
 2297: // whether compilers actually get this is another story, sadly.
 2298  #define dct_trn16(x, y) { int16x8x2_t t = vtrnq_s16(x, y); x = t.val[0]; y = t.val[1]; }
 2299  #define dct_trn32(x, y) { int32x4x2_t t = vtrnq_s32(vreinterpretq_s32_s16(x), vreinterpretq_s32_s16(y)); x = vreinterpretq_s16_s32(t.val[0]); y = vreinterpretq_s16_s32(t.val[1]); }
 2300  #define dct_trn64(x, y) { int16x8_t x0 = x; int16x8_t y0 = y; x = vcombine_s16(vget_low_s16(x0), vget_low_s16(y0)); y = vcombine_s16(vget_high_s16(x0), vget_high_s16(y0)); }
 2301  
 2302:       // pass 1
 2303:       dct_trn16(row0, row1); // a0b0a2b2a4b4a6b6
 2304        dct_trn16(row2, row3);
 2305        dct_trn16(row4, row5);
 2306        dct_trn16(row6, row7);
 2307  
 2308:       // pass 2
 2309:       dct_trn32(row0, row2); // a0b0c0d0a4b4c4d4
 2310        dct_trn32(row1, row3);
 2311        dct_trn32(row4, row6);
 2312        dct_trn32(row5, row7);
 2313  
 2314:       // pass 3
 2315:       dct_trn64(row0, row4); // a0b0c0d0e0f0g0h0
 2316        dct_trn64(row1, row5);
 2317        dct_trn64(row2, row6);
 ....
 2323     }
 2324  
 2325:    // row pass
 2326:    // vrshrn_n_s32 only supports shifts up to 16, we need
 2327:    // 17. so do a non-rounding shift of 16 first then follow
 2328:    // up with a rounding shift by 1.
 2329     dct_pass(vshrn_n_s32, 16);
 2330  
 2331     {
 2332:       // pack and round
 2333        uint8x8_t p0 = vqrshrun_n_s16(row0, 1);
 2334        uint8x8_t p1 = vqrshrun_n_s16(row1, 1);
 ....
 2340        uint8x8_t p7 = vqrshrun_n_s16(row7, 1);
 2341  
 2342:       // again, these can translate into one instruction, but often don't.
 2343  #define dct_trn8_8(x, y) { uint8x8x2_t t = vtrn_u8(x, y); x = t.val[0]; y = t.val[1]; }
 2344  #define dct_trn8_16(x, y) { uint16x4x2_t t = vtrn_u16(vreinterpret_u16_u8(x), vreinterpret_u16_u8(y)); x = vreinterpret_u8_u16(t.val[0]); y = vreinterpret_u8_u16(t.val[1]); }
 2345  #define dct_trn8_32(x, y) { uint32x2x2_t t = vtrn_u32(vreinterpret_u32_u8(x), vreinterpret_u32_u8(y)); x = vreinterpret_u8_u32(t.val[0]); y = vreinterpret_u8_u32(t.val[1]); }
 2346  
 2347:       // sadly can't use interleaved stores here since we only write
 2348:       // 8 bytes to each scan line!
 2349  
 2350:       // 8x8 8-bit transpose pass 1
 2351        dct_trn8_8(p0, p1);
 2352        dct_trn8_8(p2, p3);
 ....
 2354        dct_trn8_8(p6, p7);
 2355  
 2356:       // pass 2
 2357        dct_trn8_16(p0, p2);
 2358        dct_trn8_16(p1, p3);
 ....
 2360        dct_trn8_16(p5, p7);
 2361  
 2362:       // pass 3
 2363        dct_trn8_32(p0, p4);
 2364        dct_trn8_32(p1, p5);
 ....
 2366        dct_trn8_32(p3, p7);
 2367  
 2368:       // store
 2369        vst1_u8(out, p0); out += out_stride;
 2370        vst1_u8(out, p1); out += out_stride;
 ....
 2390  }
 2391  
 2392: #endif // STBI_NEON
 2393  
 2394  #define STBI__MARKER_none  0xff
 2395: // if there's a pending marker from the entropy stream, return that
 2396: // otherwise, fetch from the stream and get a marker. if there's no
 2397: // marker, return 0xff, which is never a valid marker value
 2398  static stbi_uc stbi__get_marker(stbi__jpeg *j)
 2399  {
 ....
 2407  }
 2408  
 2409: // in each scan, we'll have scan_n components, and the order
 2410: // of the components is specified by order[]
 2411  #define STBI__RESTART(x)     ((x) >= 0xd0 && (x) <= 0xd7)
 2412  
 2413: // after a restart interval, stbi__jpeg_reset the entropy decoder and
 2414: // the dc prediction
 2415  static void stbi__jpeg_reset(stbi__jpeg *j)
 2416  {
 ....
 2422     j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;
 2423     j->eob_run = 0;
 2424:    // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
 2425:    // since we don't even allow 1<<30 pixels
 2426  }
 2427  
 ....
 2434           STBI_SIMD_ALIGN(short, data[64]);
 2435           int n = z->order[0];
 2436:          // non-interleaved data, we just need to process one block at a time,
 2437:          // in trivial scanline order
 2438:          // number of blocks to do just depends on how many actual "pixels" this
 2439:          // component has, independent of interleaved MCU blocking and such
 2440           int w = (z->img_comp[n].x+7) >> 3;
 2441           int h = (z->img_comp[n].y+7) >> 3;
 ....
 2445                 if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
 2446                 z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
 2447:                // every data block is an MCU, so countdown the restart interval
 2448                 if (--z->todo <= 0) {
 2449                    if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
 2450:                   // if it's NOT a restart, then just bail, so we get corrupt data
 2451:                   // rather than no data
 2452                    if (!STBI__RESTART(z->marker)) return 1;
 2453                    stbi__jpeg_reset(z);
 ....
 2456           }
 2457           return 1;
 2458:       } else { // interleaved
 2459           int i,j,k,x,y;
 2460           STBI_SIMD_ALIGN(short, data[64]);
 2461           for (j=0; j < z->img_mcu_y; ++j) {
 2462              for (i=0; i < z->img_mcu_x; ++i) {
 2463:                // scan an interleaved mcu... process scan_n components in order
 2464                 for (k=0; k < z->scan_n; ++k) {
 2465                    int n = z->order[k];
 2466:                   // scan out an mcu's worth of this component; that's just determined
 2467:                   // by the basic H and V specified for the component
 2468                    for (y=0; y < z->img_comp[n].v; ++y) {
 2469                       for (x=0; x < z->img_comp[n].h; ++x) {
 ....
 2476                    }
 2477                 }
 2478:                // after all interleaved components, that's an interleaved MCU,
 2479:                // so now count down the restart interval
 2480                 if (--z->todo <= 0) {
 2481                    if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
 ....
 2491           int i,j;
 2492           int n = z->order[0];
 2493:          // non-interleaved data, we just need to process one block at a time,
 2494:          // in trivial scanline order
 2495:          // number of blocks to do just depends on how many actual "pixels" this
 2496:          // component has, independent of interleaved MCU blocking and such
 2497           int w = (z->img_comp[n].x+7) >> 3;
 2498           int h = (z->img_comp[n].y+7) >> 3;
 ....
 2508                       return 0;
 2509                 }
 2510:                // every data block is an MCU, so countdown the restart interval
 2511                 if (--z->todo <= 0) {
 2512                    if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
 ....
 2517           }
 2518           return 1;
 2519:       } else { // interleaved
 2520           int i,j,k,x,y;
 2521           for (j=0; j < z->img_mcu_y; ++j) {
 2522              for (i=0; i < z->img_mcu_x; ++i) {
 2523:                // scan an interleaved mcu... process scan_n components in order
 2524                 for (k=0; k < z->scan_n; ++k) {
 2525                    int n = z->order[k];
 2526:                   // scan out an mcu's worth of this component; that's just determined
 2527:                   // by the basic H and V specified for the component
 2528                    for (y=0; y < z->img_comp[n].v; ++y) {
 2529                       for (x=0; x < z->img_comp[n].h; ++x) {
 ....
 2536                    }
 2537                 }
 2538:                // after all interleaved components, that's an interleaved MCU,
 2539:                // so now count down the restart interval
 2540                 if (--z->todo <= 0) {
 2541                    if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
 ....
 2560  {
 2561     if (z->progressive) {
 2562:       // dequantize and idct the data
 2563        int i,j,n;
 2564        for (n=0; n < z->s->img_n; ++n) {
 ....
 2580     int L;
 2581     switch (m) {
 2582:       case STBI__MARKER_none: // no marker found
 2583           return stbi__err("expected marker","Corrupt JPEG");
 2584  
 2585:       case 0xDD: // DRI - specify restart interval
 2586           if (stbi__get16be(z->s) != 4) return stbi__err("bad DRI len","Corrupt JPEG");
 2587           z->restart_interval = stbi__get16be(z->s);
 2588           return 1;
 2589  
 2590:       case 0xDB: // DQT - define quantization table
 2591           L = stbi__get16be(z->s)-2;
 2592           while (L > 0) {
 ....
 2602           return L==0;
 2603  
 2604:       case 0xC4: // DHT - define huffman table
 2605           L = stbi__get16be(z->s)-2;
 2606           while (L > 0) {
 ....
 2631           return L==0;
 2632     }
 2633:    // check for comment block or APP blocks
 2634     if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {
 2635        stbi__skip(z->s, stbi__get16be(z->s)-2);
 ....
 2639  }
 2640  
 2641: // after we see SOS
 2642  static int stbi__process_scan_header(stbi__jpeg *z)
 2643  {
 ....
 2653           if (z->img_comp[which].id == id)
 2654              break;
 2655:       if (which == z->s->img_n) return 0; // no match
 2656        z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err("bad DC huff","Corrupt JPEG");
 2657        z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err("bad AC huff","Corrupt JPEG");
 ....
 2662        int aa;
 2663        z->spec_start = stbi__get8(z->s);
 2664:       z->spec_end   = stbi__get8(z->s); // should be 63, but might be 0
 2665        aa = stbi__get8(z->s);
 2666        z->succ_high = (aa >> 4);
 ....
 2683     stbi__context *s = z->s;
 2684     int Lf,p,i,q, h_max=1,v_max=1,c;
 2685:    Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err("bad SOF len","Corrupt JPEG"); // JPEG
 2686:    p  = stbi__get8(s);            if (p != 8) return stbi__err("only 8-bit","JPEG format not supported: 8-bit only"); // JPEG baseline
 2687:    s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err("no header height", "JPEG format not supported: delayed height"); // Legal, but we don't handle it--but neither does IJG
 2688:    s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err("0 width","Corrupt JPEG"); // JPEG requires
 2689     c = stbi__get8(s);
 2690:    if (c != 3 && c != 1) return stbi__err("bad component count","Corrupt JPEG");    // JFIF requires
 2691     s->img_n = c;
 2692     for (i=0; i < c; ++i) {
 ....
 2699     for (i=0; i < s->img_n; ++i) {
 2700        z->img_comp[i].id = stbi__get8(s);
 2701:       if (z->img_comp[i].id != i+1)   // JFIF requires
 2702:          if (z->img_comp[i].id != i)  // some version of jpegtran outputs non-JFIF-compliant files!
 2703              return stbi__err("bad component ID","Corrupt JPEG");
 2704        q = stbi__get8(s);
 ....
 2717     }
 2718  
 2719:    // compute interleaved mcu info
 2720     z->img_h_max = h_max;
 2721     z->img_v_max = v_max;
 ....
 2726  
 2727     for (i=0; i < s->img_n; ++i) {
 2728:       // number of effective pixels (e.g. for non-interleaved MCU)
 2729        z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;
 2730        z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;
 2731:       // to simplify generation, we'll allocate enough memory to decode
 2732:       // the bogus oversized data from using interleaved MCUs and their
 2733:       // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't
 2734:       // discard the extra data until colorspace conversion
 2735        z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;
 2736        z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;
 ....
 2744           return stbi__err("outofmem", "Out of memory");
 2745        }
 2746:       // align blocks for idct using mmx/sse
 2747        z->img_comp[i].data = (stbi_uc*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);
 2748        z->img_comp[i].linebuf = NULL;
 ....
 2761  }
 2762  
 2763: // use comparisons since in some cases we handle more than one case (e.g. SOF)
 2764  #define stbi__DNL(x)         ((x) == 0xdc)
 2765  #define stbi__SOI(x)         ((x) == 0xd8)
 ....
 2773  {
 2774     int m;
 2775:    z->marker = STBI__MARKER_none; // initialize cached marker to empty
 2776     m = stbi__get_marker(z);
 2777     if (!stbi__SOI(m)) return stbi__err("no SOI","Corrupt JPEG");
 ....
 2782        m = stbi__get_marker(z);
 2783        while (m == STBI__MARKER_none) {
 2784:          // some files have extra padding after their blocks, so ok, we'll scan
 2785           if (stbi__at_eof(z->s)) return stbi__err("no SOF", "Corrupt JPEG");
 2786           m = stbi__get_marker(z);
 ....
 2792  }
 2793  
 2794: // decode image to YCbCr format
 2795  static int stbi__decode_jpeg_image(stbi__jpeg *j)
 2796  {
 ....
 2808           if (!stbi__parse_entropy_coded_data(j)) return 0;
 2809           if (j->marker == STBI__MARKER_none ) {
 2810:             // handle 0s at the end of image data from IP Kamera 9060
 2811              while (!stbi__at_eof(j->s)) {
 2812                 int x = stbi__get8(j->s);
 ....
 2818                 }
 2819              }
 2820:             // if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0
 2821           }
 2822        } else {
 ....
 2830  }
 2831  
 2832: // static jfif-centered resampling (across block boundaries)
 2833  
 2834  typedef stbi_uc *(*resample_row_func)(stbi_uc *out, stbi_uc *in0, stbi_uc *in1,
 ....
 2848  static stbi_uc* stbi__resample_row_v_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
 2849  {
 2850:    // need to generate two samples vertically for every one in input
 2851     int i;
 2852     STBI_NOTUSED(hs);
 ....
 2858  static stbi_uc*  stbi__resample_row_h_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
 2859  {
 2860:    // need to generate two samples horizontally for every one in input
 2861     int i;
 2862     stbi_uc *input = in_near;
 2863  
 2864     if (w == 1) {
 2865:       // if only one sample, can't do any interpolation
 2866        out[0] = out[1] = input[0];
 2867        return out;
 ....
 2888  static stbi_uc *stbi__resample_row_hv_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
 2889  {
 2890:    // need to generate 2x2 samples for every one in input
 2891     int i,t0,t1;
 2892     if (w == 1) {
 ....
 2913  static stbi_uc *stbi__resample_row_hv_2_simd(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
 2914  {
 2915:    // need to generate 2x2 samples for every one in input
 2916     int i=0,t0,t1;
 2917  
 ....
 2922  
 2923     t1 = 3*in_near[0] + in_far[0];
 2924:    // process groups of 8 pixels for as long as we can.
 2925:    // note we can't handle the last pixel in a row in this loop
 2926:    // because we need to handle the filter boundary conditions.
 2927     for (; i < ((w-1) & ~7); i += 8) {
 2928  #if defined(STBI_SSE2)
 2929:       // load and perform the vertical filtering pass
 2930:       // this uses 3*x + y = 4*x + (y - x)
 2931        __m128i zero  = _mm_setzero_si128();
 2932        __m128i farb  = _mm_loadl_epi64((__m128i *) (in_far + i));
 ....
 2936        __m128i diff  = _mm_sub_epi16(farw, nearw);
 2937        __m128i nears = _mm_slli_epi16(nearw, 2);
 2938:       __m128i curr  = _mm_add_epi16(nears, diff); // current row
 2939  
 2940:       // horizontal filter works the same based on shifted vers of current
 2941:       // row. "prev" is current row shifted right by 1 pixel; we need to
 2942:       // insert the previous pixel value (from t1).
 2943:       // "next" is current row shifted left by 1 pixel, with first pixel
 2944:       // of next block of 8 pixels added in.
 2945        __m128i prv0 = _mm_slli_si128(curr, 2);
 2946        __m128i nxt0 = _mm_srli_si128(curr, 2);
 ....
 2948        __m128i next = _mm_insert_epi16(nxt0, 3*in_near[i+8] + in_far[i+8], 7);
 2949  
 2950:       // horizontal filter, polyphase implementation since it's convenient:
 2951:       // even pixels = 3*cur + prev = cur*4 + (prev - cur)
 2952:       // odd  pixels = 3*cur + next = cur*4 + (next - cur)
 2953:       // note the shared term.
 2954        __m128i bias  = _mm_set1_epi16(8);
 2955        __m128i curs = _mm_slli_epi16(curr, 2);
 ....
 2960        __m128i odd  = _mm_add_epi16(nxtd, curb);
 2961  
 2962:       // interleave even and odd pixels, then undo scaling.
 2963        __m128i int0 = _mm_unpacklo_epi16(even, odd);
 2964        __m128i int1 = _mm_unpackhi_epi16(even, odd);
 ....
 2966        __m128i de1  = _mm_srli_epi16(int1, 4);
 2967  
 2968:       // pack and write output
 2969        __m128i outv = _mm_packus_epi16(de0, de1);
 2970        _mm_storeu_si128((__m128i *) (out + i*2), outv);
 2971  #elif defined(STBI_NEON)
 2972:       // load and perform the vertical filtering pass
 2973:       // this uses 3*x + y = 4*x + (y - x)
 2974        uint8x8_t farb  = vld1_u8(in_far + i);
 2975        uint8x8_t nearb = vld1_u8(in_near + i);
 2976        int16x8_t diff  = vreinterpretq_s16_u16(vsubl_u8(farb, nearb));
 2977        int16x8_t nears = vreinterpretq_s16_u16(vshll_n_u8(nearb, 2));
 2978:       int16x8_t curr  = vaddq_s16(nears, diff); // current row
 2979  
 2980:       // horizontal filter works the same based on shifted vers of current
 2981:       // row. "prev" is current row shifted right by 1 pixel; we need to
 2982:       // insert the previous pixel value (from t1).
 2983:       // "next" is current row shifted left by 1 pixel, with first pixel
 2984:       // of next block of 8 pixels added in.
 2985        int16x8_t prv0 = vextq_s16(curr, curr, 7);
 2986        int16x8_t nxt0 = vextq_s16(curr, curr, 1);
 ....
 2988        int16x8_t next = vsetq_lane_s16(3*in_near[i+8] + in_far[i+8], nxt0, 7);
 2989  
 2990:       // horizontal filter, polyphase implementation since it's convenient:
 2991:       // even pixels = 3*cur + prev = cur*4 + (prev - cur)
 2992:       // odd  pixels = 3*cur + next = cur*4 + (next - cur)
 2993:       // note the shared term.
 2994        int16x8_t curs = vshlq_n_s16(curr, 2);
 2995        int16x8_t prvd = vsubq_s16(prev, curr);
 ....
 2998        int16x8_t odd  = vaddq_s16(curs, nxtd);
 2999  
 3000:       // undo scaling and round, then store with even/odd phases interleaved
 3001        uint8x8x2_t o;
 3002        o.val[0] = vqrshrun_n_s16(even, 4);
 ....
 3005  #endif
 3006  
 3007:       // "previous" value for next iter
 3008        t1 = 3*in_near[i+7] + in_far[i+7];
 3009     }
 ....
 3029  static stbi_uc *stbi__resample_row_generic(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
 3030  {
 3031:    // resample with nearest-neighbor
 3032     int i,j;
 3033     STBI_NOTUSED(in_far);
 ....
 3039  
 3040  #ifdef STBI_JPEG_OLD
 3041: // this is the same YCbCr-to-RGB calculation that stb_image has used
 3042: // historically before the algorithm changes in 1.49
 3043  #define float2fixed(x)  ((int) ((x) * 65536 + 0.5))
 3044  static void stbi__YCbCr_to_RGB_row(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step)
 ....
 3046     int i;
 3047     for (i=0; i < count; ++i) {
 3048:       int y_fixed = (y[i] << 16) + 32768; // rounding
 3049        int r,g,b;
 3050        int cr = pcr[i] - 128;
 ....
 3067  }
 3068  #else
 3069: // this is a reduced-precision calculation of YCbCr-to-RGB introduced
 3070: // to make sure the code produces the same results in both SIMD and scalar
 3071  #define float2fixed(x)  (((int) ((x) * 4096.0f + 0.5f)) << 8)
 3072  static void stbi__YCbCr_to_RGB_row(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step)
 ....
 3074     int i;
 3075     for (i=0; i < count; ++i) {
 3076:       int y_fixed = (y[i] << 20) + (1<<19); // rounding
 3077        int r,g,b;
 3078        int cr = pcr[i] - 128;
 ....
 3102  
 3103  #ifdef STBI_SSE2
 3104:    // step == 3 is pretty ugly on the final interleave, and i'm not convinced
 3105:    // it's useful in practice (you wouldn't use it for textures, for example).
 3106:    // so just accelerate step == 4 case.
 3107     if (step == 4) {
 3108:       // this is a fairly straightforward implementation and not super-optimized.
 3109        __m128i signflip  = _mm_set1_epi8(-0x80);
 3110        __m128i cr_const0 = _mm_set1_epi16(   (short) ( 1.40200f*4096.0f+0.5f));
 ....
 3113        __m128i cb_const1 = _mm_set1_epi16(   (short) ( 1.77200f*4096.0f+0.5f));
 3114        __m128i y_bias = _mm_set1_epi8((char) (unsigned char) 128);
 3115:       __m128i xw = _mm_set1_epi16(255); // alpha channel
 3116  
 3117        for (; i+7 < count; i += 8) {
 3118:          // load
 3119           __m128i y_bytes = _mm_loadl_epi64((__m128i *) (y+i));
 3120           __m128i cr_bytes = _mm_loadl_epi64((__m128i *) (pcr+i));
 3121           __m128i cb_bytes = _mm_loadl_epi64((__m128i *) (pcb+i));
 3122:          __m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128
 3123:          __m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128
 3124  
 3125:          // unpack to short (and left-shift cr, cb by 8)
 3126           __m128i yw  = _mm_unpacklo_epi8(y_bias, y_bytes);
 3127           __m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);
 3128           __m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);
 3129  
 3130:          // color transform
 3131           __m128i yws = _mm_srli_epi16(yw, 4);
 3132           __m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);
 ....
 3139           __m128i gws = _mm_add_epi16(gwt, cr1);
 3140  
 3141:          // descale
 3142           __m128i rw = _mm_srai_epi16(rws, 4);
 3143           __m128i bw = _mm_srai_epi16(bws, 4);
 3144           __m128i gw = _mm_srai_epi16(gws, 4);
 3145  
 3146:          // back to byte, set up for transpose
 3147           __m128i brb = _mm_packus_epi16(rw, bw);
 3148           __m128i gxb = _mm_packus_epi16(gw, xw);
 3149  
 3150:          // transpose to interleave channels
 3151           __m128i t0 = _mm_unpacklo_epi8(brb, gxb);
 3152           __m128i t1 = _mm_unpackhi_epi8(brb, gxb);
 ....
 3154           __m128i o1 = _mm_unpackhi_epi16(t0, t1);
 3155  
 3156:          // store
 3157           _mm_storeu_si128((__m128i *) (out + 0), o0);
 3158           _mm_storeu_si128((__m128i *) (out + 16), o1);
 ....
 3163  
 3164  #ifdef STBI_NEON
 3165:    // in this version, step=3 support would be easy to add. but is there demand?
 3166     if (step == 4) {
 3167:       // this is a fairly straightforward implementation and not super-optimized.
 3168        uint8x8_t signflip = vdup_n_u8(0x80);
 3169        int16x8_t cr_const0 = vdupq_n_s16(   (short) ( 1.40200f*4096.0f+0.5f));
 ....
 3173  
 3174        for (; i+7 < count; i += 8) {
 3175:          // load
 3176           uint8x8_t y_bytes  = vld1_u8(y + i);
 3177           uint8x8_t cr_bytes = vld1_u8(pcr + i);
 ....
 3180           int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));
 3181  
 3182:          // expand to s16
 3183           int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));
 3184           int16x8_t crw = vshll_n_s8(cr_biased, 7);
 3185           int16x8_t cbw = vshll_n_s8(cb_biased, 7);
 3186  
 3187:          // color transform
 3188           int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);
 3189           int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);
 ....
 3194           int16x8_t bws = vaddq_s16(yws, cb1);
 3195  
 3196:          // undo scaling, round, convert to byte
 3197           uint8x8x4_t o;
 3198           o.val[0] = vqrshrun_n_s16(rws, 4);
 ....
 3201           o.val[3] = vdup_n_u8(255);
 3202  
 3203:          // store, interleaving r/g/b/a
 3204           vst4_u8(out, o);
 3205           out += 8*4;
 ....
 3209  
 3210     for (; i < count; ++i) {
 3211:       int y_fixed = (y[i] << 20) + (1<<19); // rounding
 3212        int r,g,b;
 3213        int cr = pcr[i] - 128;
 ....
 3231  #endif
 3232  
 3233: // set up the kernels
 3234  static void stbi__setup_jpeg(stbi__jpeg *j)
 3235  {
 ....
 3257  }
 3258  
 3259: // clean up the temporary component buffers
 3260  static void stbi__cleanup_jpeg(stbi__jpeg *j)
 3261  {
 ....
 3283     resample_row_func resample;
 3284     stbi_uc *line0,*line1;
 3285:    int hs,vs;   // expansion factor in each axis
 3286:    int w_lores; // horizontal pixels pre-expansion
 3287:    int ystep;   // how far through vertical expansion we are
 3288:    int ypos;    // which pre-expansion row we're on
 3289  } stbi__resample;
 3290  
 ....
 3292  {
 3293     int n, decode_n;
 3294:    z->s->img_n = 0; // make stbi__cleanup_jpeg safe
 3295  
 3296:    // validate req_comp
 3297     if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");
 3298  
 3299:    // load a jpeg image from whichever source, but leave in YCbCr format
 3300     if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }
 3301  
 3302:    // determine actual number of components to generate
 3303     n = req_comp ? req_comp : z->s->img_n;
 3304  
 ....
 3308        decode_n = z->s->img_n;
 3309  
 3310:    // resample and color-convert
 3311     {
 3312        int k;
 ....
 3320           stbi__resample *r = &res_comp[k];
 3321  
 3322:          // allocate line buffer big enough for upsampling off the edges
 3323:          // with upsample factor of 4
 3324           z->img_comp[k].linebuf = (stbi_uc *) stbi__malloc(z->s->img_x + 3);
 3325           if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }
 ....
 3339        }
 3340  
 3341:       // can't error after this so, this is safe
 3342        output = (stbi_uc *) stbi__malloc(n * z->s->img_x * z->s->img_y + 1);
 3343        if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }
 3344  
 3345:       // now go ahead and resample
 3346        for (j=0; j < z->s->img_y; ++j) {
 3347           stbi_uc *out = output + n * z->s->img_x * j;
 ....
 3367                 for (i=0; i < z->s->img_x; ++i) {
 3368                    out[0] = out[1] = out[2] = y[i];
 3369:                   out[3] = 255; // not used if n==3
 3370                    out += n;
 3371                 }
 ....
 3381        *out_x = z->s->img_x;
 3382        *out_y = z->s->img_y;
 3383:       if (comp) *comp  = z->s->img_n; // report original components, not output
 3384        return output;
 3385     }
 ....
 3425  #endif
 3426  
 3427: // public domain zlib decode    v0.2  Sean Barrett 2006-11-18
 3428: //    simple implementation
 3429: //      - all input must be provided in an upfront buffer
 3430: //      - all output is written to a single output buffer (can malloc/realloc)
 3431: //    performance
 3432: //      - fast huffman
 3433  
 3434  #ifndef STBI_NO_ZLIB
 3435  
 3436: // fast-way is faster to check than jpeg huffman, but slow way is slower
 3437: #define STBI__ZFAST_BITS  9 // accelerate all cases in default tables
 3438  #define STBI__ZFAST_MASK  ((1 << STBI__ZFAST_BITS) - 1)
 3439  
 3440: // zlib-style huffman encoding
 3441: // (jpegs packs from left, zlib from right, so can't share code)
 3442  typedef struct
 3443  {
 ....
 3462  {
 3463     STBI_ASSERT(bits <= 16);
 3464:    // to bit reverse n bits, reverse 16 and shift
 3465:    // e.g. 11 bits, bit reverse and shift away 5
 3466     return stbi__bitreverse16(v) >> (16-bits);
 3467  }
 ....
 3472     int code, next_code[16], sizes[17];
 3473  
 3474:    // DEFLATE spec for generating codes
 3475     memset(sizes, 0, sizeof(sizes));
 3476     memset(z->fast, 0, sizeof(z->fast));
 ....
 3489        if (sizes[i])
 3490           if (code-1 >= (1 << i)) return stbi__err("bad codelengths","Corrupt PNG");
 3491:       z->maxcode[i] = code << (16-i); // preshift for inner loop
 3492        code <<= 1;
 3493        k += sizes[i];
 3494     }
 3495:    z->maxcode[16] = 0x10000; // sentinel
 3496     for (i=0; i < num; ++i) {
 3497        int s = sizelist[i];
 ....
 3514  }
 3515  
 3516: // zlib-from-memory implementation for PNG reading
 3517: //    because PNG allows splitting the zlib stream arbitrarily,
 3518: //    and it's annoying structurally to have PNG call ZLIB call PNG,
 3519: //    we require PNG read all the IDATs and combine them into a single
 3520: //    memory buffer
 3521  
 3522  typedef struct
 ....
 3562  {
 3563     int b,s,k;
 3564:    // not resolved by fast table, so compute it the slow way
 3565:    // use jpeg approach, which requires MSbits at top
 3566     k = stbi__bit_reverse(a->code_buffer, 16);
 3567     for (s=STBI__ZFAST_BITS+1; ; ++s)
 3568        if (k < z->maxcode[s])
 3569           break;
 3570:    if (s == 16) return -1; // invalid code!
 3571:    // code size is s, so:
 3572     b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];
 3573     STBI_ASSERT(z->size[b] == s);
 ....
 3591  }
 3592  
 3593: static int stbi__zexpand(stbi__zbuf *z, char *zout, int n)  // need to make room for n bytes
 3594  {
 3595     char *q;
 ....
 3629        int z = stbi__zhuffman_decode(a, &a->z_length);
 3630        if (z < 256) {
 3631:          if (z < 0) return stbi__err("bad huffman code","Corrupt PNG"); // error in huffman codes
 3632           if (zout >= a->zout_end) {
 3633              if (!stbi__zexpand(a, zout, 1)) return 0;
 ....
 3655           }
 3656           p = (stbi_uc *) (zout - dist);
 3657:          if (dist == 1) { // run of one byte; common in images.
 3658              stbi_uc v = *p;
 3659              if (len) { do *zout++ = v; while (--len); }
 ....
 3669     static stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
 3670     stbi__zhuffman z_codelength;
 3671:    stbi_uc lencodes[286+32+137];//padding for maximum single op
 3672     stbi_uc codelength_sizes[19];
 3673     int i,n;
 ....
 3716     int len,nlen,k;
 3717     if (a->num_bits & 7)
 3718:       stbi__zreceive(a, a->num_bits & 7); // discard
 3719:    // drain the bit-packed data into header
 3720     k = 0;
 3721     while (a->num_bits > 0) {
 3722:       header[k++] = (stbi_uc) (a->code_buffer & 255); // suppress MSVC run-time check
 3723        a->code_buffer >>= 8;
 3724        a->num_bits -= 8;
 3725     }
 3726     STBI_ASSERT(a->num_bits == 0);
 3727:    // now fill header the normal way
 3728     while (k < 4)
 3729        header[k++] = stbi__zget8(a);
 ....
 3744     int cmf   = stbi__zget8(a);
 3745     int cm    = cmf & 15;
 3746:    /* int cinfo = cmf >> 4; */
 3747     int flg   = stbi__zget8(a);
 3748:    if ((cmf*256+flg) % 31 != 0) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec
 3749:    if (flg & 32) return stbi__err("no preset dict","Corrupt PNG"); // preset dictionary not allowed in png
 3750:    if (cm != 8) return stbi__err("bad compression","Corrupt PNG"); // DEFLATE required for png
 3751:    // window = 1 << (8 + cinfo)... but who cares, we fully buffer output
 3752     return 1;
 3753  }
 3754  
 3755: // @TODO: should statically initialize these for optimal thread safety
 3756  static stbi_uc stbi__zdefault_length[288], stbi__zdefault_distance[32];
 3757  static void stbi__init_zdefaults(void)
 3758  {
 3759:    int i;   // use <= to match clearly with spec
 3760     for (i=0; i <= 143; ++i)     stbi__zdefault_length[i]   = 8;
 3761     for (   ; i <= 255; ++i)     stbi__zdefault_length[i]   = 9;
 ....
 3782        } else {
 3783           if (type == 1) {
 3784:             // use fixed code lengths
 3785              if (!stbi__zdefault_distance[31]) stbi__init_zdefaults();
 3786              if (!stbi__zbuild_huffman(&a->z_length  , stbi__zdefault_length  , 288)) return 0;
 ....
 3881  #endif
 3882  
 3883: // public domain "baseline" PNG decoder   v0.10  Sean Barrett 2006-11-18
 3884: //    simple implementation
 3885: //      - only 8-bit samples
 3886: //      - no CRC checking
 3887: //      - allocates lots of intermediate memory
 3888: //        - avoids problem of streaming data between subsystems
 3889: //        - avoids explicit window management
 3890: //    performance
 3891: //      - uses stb_zlib, a PD zlib implementation with fast huffman decoding
 3892  
 3893  #ifndef STBI_NO_PNG
 ....
 3928     STBI__F_avg=3,
 3929     STBI__F_paeth=4,
 3930:    // synthetic filters used for first scanline to avoid needing a dummy row of 0s
 3931     STBI__F_avg_first,
 3932     STBI__F_paeth_first
 ....
 3955  static stbi_uc stbi__depth_scale_table[9] = { 0, 0xff, 0x55, 0, 0x11, 0,0,0, 0x01 };
 3956  
 3957: // create the png data from post-deflated data
 3958  static int stbi__create_png_image_raw(stbi__png *a, stbi_uc *raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)
 3959  {
 ....
 3962     stbi__uint32 img_len, img_width_bytes;
 3963     int k;
 3964:    int img_n = s->img_n; // copy it into a local for later
 3965  
 3966     STBI_ASSERT(out_n == s->img_n || out_n == s->img_n+1);
 3967:    a->out = (stbi_uc *) stbi__malloc(x * y * out_n); // extra bytes to write off the end into
 3968     if (!a->out) return stbi__err("outofmem", "Out of memory");
 3969  
 ....
 3972     if (s->img_x == x && s->img_y == y) {
 3973        if (raw_len != img_len) return stbi__err("not enough pixels","Corrupt PNG");
 3974:    } else { // interlaced:
 3975        if (raw_len < img_len) return stbi__err("not enough pixels","Corrupt PNG");
 3976     }
 ....
 3987        if (depth < 8) {
 3988           STBI_ASSERT(img_width_bytes <= x);
 3989:          cur += x*out_n - img_width_bytes; // store output to the rightmost img_len bytes, so we can decode in place
 3990           filter_bytes = 1;
 3991           width = img_width_bytes;
 3992        }
 3993  
 3994:       // if first row, use special filter that doesn't sample previous row
 3995        if (j == 0) filter = first_row_filter[filter];
 3996  
 3997:       // handle first byte explicitly
 3998        for (k=0; k < filter_bytes; ++k) {
 3999           switch (filter) {
 ....
 4010        if (depth == 8) {
 4011           if (img_n != out_n)
 4012:             cur[img_n] = 255; // first pixel
 4013           raw += img_n;
 4014           cur += out_n;
 ....
 4020        }
 4021  
 4022:       // this is a little gross, so that we don't switch per-pixel or per-component
 4023        if (depth < 8 || img_n == out_n) {
 4024           int nk = (width - 1)*img_n;
 ....
 4027                  for (k=0; k < nk; ++k)
 4028           switch (filter) {
 4029:             // "none" filter turns into a memcpy here; make that explicit.
 4030              case STBI__F_none:         memcpy(cur, raw, nk); break;
 4031              CASE(STBI__F_sub)          cur[k] = STBI__BYTECAST(raw[k] + cur[k-filter_bytes]); break;
 ....
 4057     }
 4058  
 4059:    // we make a separate pass to expand bits to pixels; for performance,
 4060:    // this could run two scanlines behind the above code, so it won't
 4061:    // intefere with filtering but will still be in the cache.
 4062     if (depth < 8) {
 4063        for (j=0; j < y; ++j) {
 4064           stbi_uc *cur = a->out + stride*j;
 4065           stbi_uc *in  = a->out + stride*j + x*out_n - img_width_bytes;
 4066:          // unpack 1/2/4-bit into a 8-bit buffer. allows us to keep the common 8-bit path optimal at minimal cost for 1/2/4-bit
 4067:          // png guarante byte alignment, if width is not multiple of 8/4/2 we'll decode dummy trailing data that will be skipped in the later loop
 4068:          stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range
 4069  
 4070:          // note that the final byte might overshoot and write more data than desired.
 4071:          // we can allocate enough data that this never writes out of memory, but it
 4072:          // could also overwrite the next scanline. can it overwrite non-empty data
 4073:          // on the next scanline? yes, consider 1-pixel-wide scanlines with 1-bit-per-pixel.
 4074:          // so we need to explicitly clamp the final ones
 4075  
 4076           if (depth == 4) {
 ....
 4110           }
 4111           if (img_n != out_n) {
 4112:             // insert alpha = 255
 4113              stbi_uc *cur = a->out + stride*j;
 4114              int i;
 ....
 4141        return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);
 4142  
 4143:    // de-interlacing
 4144     final = (stbi_uc *) stbi__malloc(a->s->img_x * a->s->img_y * out_n);
 4145     for (p=0; p < 7; ++p) {
 ....
 4149        int yspc[]  = { 8,8,8,4,4,2,2 };
 4150        int i,j,x,y;
 4151:       // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
 4152        x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];
 4153        y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];
 ....
 4182     stbi_uc *p = z->out;
 4183  
 4184:    // compute color-based transparency, assuming we've
 4185:    // already got 255 as the alpha value in the output
 4186     STBI_ASSERT(out_n == 2 || out_n == 4);
 4187  
 ....
 4209     if (p == NULL) return stbi__err("outofmem", "Out of memory");
 4210  
 4211:    // between here and free(out) below, exitting would leak
 4212     temp_out = p;
 4213  
 ....
 4257     stbi_uc *p = z->out;
 4258  
 4259:    if (s->img_out_n == 3) {  // convert bgr to rgb
 4260        for (i=0; i < pixel_count; ++i) {
 4261           stbi_uc t = p[0];
 ....
 4267        STBI_ASSERT(s->img_out_n == 4);
 4268        if (stbi__unpremultiply_on_load) {
 4269:          // convert bgr to rgb and unpremultiply
 4270           for (i=0; i < pixel_count; ++i) {
 4271              stbi_uc a = p[3];
 ....
 4282           }
 4283        } else {
 4284:          // convert bgr to rgb
 4285           for (i=0; i < pixel_count; ++i) {
 4286              stbi_uc t = p[0];
 ....
 4337                 if (scan == STBI__SCAN_header) return 1;
 4338              } else {
 4339:                // if paletted, then pal_n is our final components, and
 4340:                // img_n is # components to decompress/filter.
 4341                 s->img_n = 1;
 4342                 if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err("too large","Corrupt PNG");
 4343:                // if SCAN_header, have to scan to see if we have a tRNS
 4344              }
 4345              break;
 ....
 4375                 has_trans = 1;
 4376                 for (k=0; k < s->img_n; ++k)
 4377:                   tc[k] = (stbi_uc) (stbi__get16be(s) & 255) * stbi__depth_scale_table[depth]; // non 8-bit images will be larger
 4378              }
 4379              break;
 ....
 4403              if (scan != STBI__SCAN_load) return 1;
 4404              if (z->idata == NULL) return stbi__err("no IDAT","Corrupt PNG");
 4405:             // initial guess for decoded data size to avoid unnecessary reallocs
 4406:             bpl = (s->img_x * depth + 7) / 8; // bytes per line, per component
 4407:             raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;
 4408              z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);
 4409:             if (z->expanded == NULL) return 0; // zlib should set error
 4410              STBI_FREE(z->idata); z->idata = NULL;
 4411              if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)
 ....
 4419                 stbi__de_iphone(z);
 4420              if (pal_img_n) {
 4421:                // pal_img_n == 3 or 4
 4422:                s->img_n = pal_img_n; // record the actual colors we had
 4423                 s->img_out_n = pal_img_n;
 4424                 if (req_comp >= 3) s->img_out_n = req_comp;
 ....
 4431  
 4432           default:
 4433:             // if critical, fail
 4434              if (first) return stbi__err("first not IHDR", "Corrupt PNG");
 4435              if ((c.type & (1 << 29)) == 0) {
 4436                 #ifndef STBI_NO_FAILURE_STRINGS
 4437:                // not threadsafe
 4438                 static char invalid_chunk[] = "XXXX PNG chunk not known";
 4439                 invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);
 ....
 4447              break;
 4448        }
 4449:       // end of PNG chunk, read and skip CRC
 4450        stbi__get32be(s);
 4451     }
 ....
 4510  #endif
 4511  
 4512: // Microsoft/Windows BMP image
 4513  
 4514  #ifndef STBI_NO_BMP
 ....
 4519     if (stbi__get8(s) != 'B') return 0;
 4520     if (stbi__get8(s) != 'M') return 0;
 4521:    stbi__get32le(s); // discard filesize
 4522:    stbi__get16le(s); // discard reserved
 4523:    stbi__get16le(s); // discard reserved
 4524:    stbi__get32le(s); // discard data offset
 4525     sz = stbi__get32le(s);
 4526     r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);
 ....
 4536  
 4537  
 4538: // returns 0..31 for the highest set bit
 4539  static int stbi__high_bit(unsigned int z)
 4540  {
 ....
 4551  static int stbi__bitcount(unsigned int a)
 4552  {
 4553:    a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2
 4554:    a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4
 4555:    a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits
 4556:    a = (a + (a >> 8)); // max 16 per 8 bits
 4557:    a = (a + (a >> 16)); // max 32 per 8 bits
 4558     return a & 0xff;
 4559  }
 ....
 4584     int bpp, flip_vertically, pad, target, offset, hsz;
 4585     if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc("not BMP", "Corrupt BMP");
 4586:    stbi__get32le(s); // discard filesize
 4587:    stbi__get16le(s); // discard reserved
 4588:    stbi__get16le(s); // discard reserved
 4589     offset = stbi__get32le(s);
 4590     hsz = stbi__get32le(s);
 ....
 4608        compress = stbi__get32le(s);
 4609        if (compress == 1 || compress == 2) return stbi__errpuc("BMP RLE", "BMP type not supported: RLE");
 4610:       stbi__get32le(s); // discard sizeof
 4611:       stbi__get32le(s); // discard hres
 4612:       stbi__get32le(s); // discard vres
 4613:       stbi__get32le(s); // discard colorsused
 4614:       stbi__get32le(s); // discard max important
 4615        if (hsz == 40 || hsz == 56) {
 4616           if (hsz == 56) {
 ....
 4628                    mb = 0xffu <<  0;
 4629                    ma = 0xffu << 24;
 4630:                   fake_a = 1; // @TODO: check for cases like alpha value is all 0 and switch it to 255
 4631                    STBI_NOTUSED(fake_a);
 4632                 } else {
 ....
 4639                 mg = stbi__get32le(s);
 4640                 mb = stbi__get32le(s);
 4641:                // not documented, but generated by photoshop and handled by mspaint
 4642                 if (mr == mg && mg == mb) {
 4643:                   // ?!?!?
 4644                    return stbi__errpuc("bad BMP", "bad BMP");
 4645                 }
 ....
 4653           mb = stbi__get32le(s);
 4654           ma = stbi__get32le(s);
 4655:          stbi__get32le(s); // discard color space
 4656           for (i=0; i < 12; ++i)
 4657:             stbi__get32le(s); // discard color space parameters
 4658           if (hsz == 124) {
 4659:             stbi__get32le(s); // discard rendering intent
 4660:             stbi__get32le(s); // discard offset of profile data
 4661:             stbi__get32le(s); // discard size of profile data
 4662:             stbi__get32le(s); // discard reserved
 4663           }
 4664        }
 ....
 4667     }
 4668     s->img_n = ma ? 4 : 3;
 4669:    if (req_comp && req_comp >= 3) // we can directly decode 3 or 4
 4670        target = req_comp;
 4671     else
 4672:       target = s->img_n; // if they want monochrome, we'll post-convert
 4673     out = (stbi_uc *) stbi__malloc(target * s->img_x * s->img_y);
 4674     if (!out) return stbi__errpuc("outofmem", "Out of memory");
 ....
 4715        if (bpp == 24) width = 3 * s->img_x;
 4716        else if (bpp == 16) width = 2*s->img_x;
 4717:       else /* bpp = 32 and pad = 0 */ width=0;
 4718        pad = (-width) & 3;
 4719        if (bpp == 24) {
 ....
 4725        if (!easy) {
 4726           if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }
 4727:          // right shift amt to put high bit in position #7
 4728           rshift = stbi__high_bit(mr)-7; rcount = stbi__bitcount(mr);
 4729           gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);
 ....
 4769     if (req_comp && req_comp != target) {
 4770        out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);
 4771:       if (out == NULL) return out; // stbi__convert_format frees input on failure
 4772     }
 4773  
 ....
 4779  #endif
 4780  
 4781: // Targa Truevision - TGA
 4782: // by Jonathan Dummer
 4783  #ifndef STBI_NO_TGA
 4784  static int stbi__tga_info(stbi__context *s, int *x, int *y, int *comp)
 ....
 4786      int tga_w, tga_h, tga_comp;
 4787      int sz;
 4788:     stbi__get8(s);                   // discard Offset
 4789:     sz = stbi__get8(s);              // color type
 4790      if( sz > 1 ) {
 4791          stbi__rewind(s);
 4792:         return 0;      // only RGB or indexed allowed
 4793      }
 4794:     sz = stbi__get8(s);              // image type
 4795:     // only RGB or grey allowed, +/- RLE
 4796      if ((sz != 1) && (sz != 2) && (sz != 3) && (sz != 9) && (sz != 10) && (sz != 11)) return 0;
 4797      stbi__skip(s,9);
 ....
 4799      if( tga_w < 1 ) {
 4800          stbi__rewind(s);
 4801:         return 0;   // test width
 4802      }
 4803      tga_h = stbi__get16le(s);
 4804      if( tga_h < 1 ) {
 4805          stbi__rewind(s);
 4806:         return 0;   // test height
 4807      }
 4808:     sz = stbi__get8(s);               // bits per pixel
 4809:     // only RGB or RGBA or grey allowed
 4810      if ((sz != 8) && (sz != 16) && (sz != 24) && (sz != 32)) {
 4811          stbi__rewind(s);
 ....
 4816      if (y) *y = tga_h;
 4817      if (comp) *comp = tga_comp / 8;
 4818:     return 1;                   // seems to have passed everything
 4819  }
 4820  
 ....
 4823     int res;
 4824     int sz;
 4825:    stbi__get8(s);      //   discard Offset
 4826:    sz = stbi__get8(s);   //   color type
 4827:    if ( sz > 1 ) return 0;   //   only RGB or indexed allowed
 4828:    sz = stbi__get8(s);   //   image type
 4829:    if ( (sz != 1) && (sz != 2) && (sz != 3) && (sz != 9) && (sz != 10) && (sz != 11) ) return 0;   //   only RGB or grey allowed, +/- RLE
 4830:    stbi__get16be(s);      //   discard palette start
 4831:    stbi__get16be(s);      //   discard palette length
 4832:    stbi__get8(s);         //   discard bits per palette color entry
 4833:    stbi__get16be(s);      //   discard x origin
 4834:    stbi__get16be(s);      //   discard y origin
 4835:    if ( stbi__get16be(s) < 1 ) return 0;      //   test width
 4836:    if ( stbi__get16be(s) < 1 ) return 0;      //   test height
 4837:    sz = stbi__get8(s);   //   bits per pixel
 4838     if ( (sz != 8) && (sz != 16) && (sz != 24) && (sz != 32) )
 4839        res = 0;
 ....
 4846  static stbi_uc *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp)
 4847  {
 4848:    //   read in the TGA header stuff
 4849     int tga_offset = stbi__get8(s);
 4850     int tga_indexed = stbi__get8(s);
 ....
 4861     int tga_comp = tga_bits_per_pixel / 8;
 4862     int tga_inverted = stbi__get8(s);
 4863:    //   image data
 4864     unsigned char *tga_data;
 4865     unsigned char *tga_palette = NULL;
 ....
 4870     int read_next_pixel = 1;
 4871  
 4872:    //   do a tiny bit of precessing
 4873     if ( tga_image_type >= 8 )
 4874     {
 ....
 4876        tga_is_RLE = 1;
 4877     }
 4878:    /* int tga_alpha_bits = tga_inverted & 15; */
 4879     tga_inverted = 1 - ((tga_inverted >> 5) & 1);
 4880  
 4881:    //   error check
 4882:    if ( //(tga_indexed) ||
 4883        (tga_width < 1) || (tga_height < 1) ||
 4884        (tga_image_type < 1) || (tga_image_type > 3) ||
 ....
 4887        )
 4888     {
 4889:       return NULL; // we don't report this as a bad TGA because we don't even know if it's TGA
 4890     }
 4891  
 4892:    //   If I'm paletted, then I'll use the number of bits from the palette
 4893     if ( tga_indexed )
 4894     {
 ....
 4896     }
 4897  
 4898:    //   tga info
 4899     *x = tga_width;
 4900     *y = tga_height;
 ....
 4904     if (!tga_data) return stbi__errpuc("outofmem", "Out of memory");
 4905  
 4906:    // skip to the data's starting position (offset usually = 0)
 4907     stbi__skip(s, tga_offset );
 4908  
 ....
 4914        }
 4915     } else  {
 4916:       //   do I need to load a palette?
 4917        if ( tga_indexed)
 4918        {
 4919:          //   any data to skip? (offset usually = 0)
 4920           stbi__skip(s, tga_palette_start );
 4921:          //   load the palette
 4922           tga_palette = (unsigned char*)stbi__malloc( tga_palette_len * tga_palette_bits / 8 );
 4923           if (!tga_palette) {
 ....
 4931           }
 4932        }
 4933:       //   load the data
 4934        for (i=0; i < tga_width * tga_height; ++i)
 4935        {
 4936:          //   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?
 4937           if ( tga_is_RLE )
 4938           {
 4939              if ( RLE_count == 0 )
 4940              {
 4941:                //   yep, get the next byte as a RLE command
 4942                 int RLE_cmd = stbi__get8(s);
 4943                 RLE_count = 1 + (RLE_cmd & 127);
 ....
 4952              read_next_pixel = 1;
 4953           }
 4954:          //   OK, if I need to read a pixel, do it now
 4955           if ( read_next_pixel )
 4956           {
 4957:             //   load however much data we did have
 4958              if ( tga_indexed )
 4959              {
 4960:                //   read in 1 byte, then perform the lookup
 4961                 int pal_idx = stbi__get8(s);
 4962                 if ( pal_idx >= tga_palette_len )
 4963                 {
 4964:                   //   invalid index
 4965                    pal_idx = 0;
 4966                 }
 ....
 4972              } else
 4973              {
 4974:                //   read in the data raw
 4975                 for (j = 0; j*8 < tga_bits_per_pixel; ++j)
 4976                 {
 ....
 4978                 }
 4979              }
 4980:             //   clear the reading flag for the next pixel
 4981              read_next_pixel = 0;
 4982:          } // end of reading a pixel
 4983  
 4984:          // copy data
 4985           for (j = 0; j < tga_comp; ++j)
 4986             tga_data[i*tga_comp+j] = raw_data[j];
 4987  
 4988:          //   in case we're in RLE mode, keep counting down
 4989           --RLE_count;
 4990        }
 4991:       //   do I need to invert the image?
 4992        if ( tga_inverted )
 4993        {
 ....
 5006           }
 5007        }
 5008:       //   clear my palette, if I had one
 5009        if ( tga_palette != NULL )
 5010        {
 ....
 5013     }
 5014  
 5015:    // swap RGB
 5016     if (tga_comp >= 3)
 5017     {
 ....
 5026     }
 5027  
 5028:    // convert to target component count
 5029     if (req_comp && req_comp != tga_comp)
 5030        tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);
 5031  
 5032:    //   the things I do to get rid of an error message, and yet keep
 5033:    //   Microsoft's C compilers happy... [8^(
 5034     tga_palette_start = tga_palette_len = tga_palette_bits =
 5035           tga_x_origin = tga_y_origin = 0;
 5036:    //   OK, done
 5037     return tga_data;
 5038  }
 5039  #endif
 5040  
 5041: // *************************************************************************************************
 5042: // Photoshop PSD loader -- PD by Thatcher Ulrich, integration by Nicolas Schulz, tweaked by STB
 5043  
 5044  #ifndef STBI_NO_PSD
 ....
 5058     stbi_uc *out;
 5059  
 5060:    // Check identifier
 5061:    if (stbi__get32be(s) != 0x38425053)   // "8BPS"
 5062        return stbi__errpuc("not PSD", "Corrupt PSD image");
 5063  
 5064:    // Check file type version.
 5065     if (stbi__get16be(s) != 1)
 5066        return stbi__errpuc("wrong version", "Unsupported version of PSD image");
 5067  
 5068:    // Skip 6 reserved bytes.
 5069     stbi__skip(s, 6 );
 5070  
 5071:    // Read the number of channels (R, G, B, A, etc).
 5072     channelCount = stbi__get16be(s);
 5073     if (channelCount < 0 || channelCount > 16)
 5074        return stbi__errpuc("wrong channel count", "Unsupported number of channels in PSD image");
 5075  
 5076:    // Read the rows and columns of the image.
 5077     h = stbi__get32be(s);
 5078     w = stbi__get32be(s);
 5079  
 5080:    // Make sure the depth is 8 bits.
 5081     if (stbi__get16be(s) != 8)
 5082        return stbi__errpuc("unsupported bit depth", "PSD bit depth is not 8 bit");
 5083  
 5084:    // Make sure the color mode is RGB.
 5085:    // Valid options are:
 5086:    //   0: Bitmap
 5087:    //   1: Grayscale
 5088:    //   2: Indexed color
 5089:    //   3: RGB color
 5090:    //   4: CMYK color
 5091:    //   7: Multichannel
 5092:    //   8: Duotone
 5093:    //   9: Lab color
 5094     if (stbi__get16be(s) != 3)
 5095        return stbi__errpuc("wrong color format", "PSD is not in RGB color format");
 5096  
 5097:    // Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)
 5098     stbi__skip(s,stbi__get32be(s) );
 5099  
 5100:    // Skip the image resources.  (resolution, pen tool paths, etc)
 5101     stbi__skip(s, stbi__get32be(s) );
 5102  
 5103:    // Skip the reserved data.
 5104     stbi__skip(s, stbi__get32be(s) );
 5105  
 5106:    // Find out if the data is compressed.
 5107:    // Known values:
 5108:    //   0: no compression
 5109:    //   1: RLE compressed
 5110     compression = stbi__get16be(s);
 5111     if (compression > 1)
 5112        return stbi__errpuc("bad compression", "PSD has an unknown compression format");
 5113  
 5114:    // Create the destination image.
 5115     out = (stbi_uc *) stbi__malloc(4 * w*h);
 5116     if (!out) return stbi__errpuc("outofmem", "Out of memory");
 5117     pixelCount = w*h;
 5118  
 5119:    // Initialize the data to zero.
 5120:    //memset( out, 0, pixelCount * 4 );
 5121  
 5122:    // Finally, the image data.
 5123     if (compression) {
 5124:       // RLE as used by .PSD and .TIFF
 5125:       // Loop until you get the number of unpacked bytes you are expecting:
 5126:       //     Read the next source byte into n.
 5127:       //     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.
 5128:       //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.
 5129:       //     Else if n is 128, noop.
 5130:       // Endloop
 5131  
 5132:       // The RLE-compressed data is preceeded by a 2-byte data count for each row in the data,
 5133:       // which we're going to just skip.
 5134        stbi__skip(s, h * channelCount * 2 );
 5135  
 5136:       // Read the RLE data by channel.
 5137        for (channel = 0; channel < 4; channel++) {
 5138           stbi_uc *p;
 ....
 5140           p = out+channel;
 5141           if (channel >= channelCount) {
 5142:             // Fill this channel with default data.
 5143              for (i = 0; i < pixelCount; i++, p += 4)
 5144                 *p = (channel == 3 ? 255 : 0);
 5145           } else {
 5146:             // Read the RLE data.
 5147              count = 0;
 5148              while (count < pixelCount) {
 5149                 len = stbi__get8(s);
 5150                 if (len == 128) {
 5151:                   // No-op.
 5152                 } else if (len < 128) {
 5153:                   // Copy next len+1 bytes literally.
 5154                    len++;
 5155                    count += len;
 ....
 5161                 } else if (len > 128) {
 5162                    stbi_uc   val;
 5163:                   // Next -len+1 bytes in the dest are replicated from next source byte.
 5164:                   // (Interpret len as a negative 8-bit int.)
 5165                    len ^= 0x0FF;
 5166                    len += 2;
 ....
 5178  
 5179     } else {
 5180:       // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)
 5181:       // where each channel consists of an 8-bit value for each pixel in the image.
 5182  
 5183:       // Read the data by channel.
 5184        for (channel = 0; channel < 4; channel++) {
 5185           stbi_uc *p;
 ....
 5187           p = out + channel;
 5188           if (channel > channelCount) {
 5189:             // Fill this channel with default data.
 5190              for (i = 0; i < pixelCount; i++, p += 4)
 5191                 *p = channel == 3 ? 255 : 0;
 5192           } else {
 5193:             // Read the data.
 5194              for (i = 0; i < pixelCount; i++, p += 4)
 5195                 *p = stbi__get8(s);
 ....
 5200     if (req_comp && req_comp != 4) {
 5201        out = stbi__convert_format(out, 4, req_comp, w, h);
 5202:       if (out == NULL) return out; // stbi__convert_format frees input on failure
 5203     }
 5204  
 ....
 5211  #endif
 5212  
 5213: // *************************************************************************************************
 5214: // Softimage PIC loader
 5215: // by Tom Seddon
 5216: //
 5217: // See http://softimage.wiki.softimage.com/index.php/INFO:_PIC_file_format
 5218: // See http://ozviz.wasp.uwa.edu.au/~pbourke/dataformats/softimagepic/
 5219  
 5220  #ifndef STBI_NO_PIC
 ....
 5278     stbi__pic_packet packets[10];
 5279  
 5280:    // this will (should...) cater for even some bizarre stuff like having data
 5281:     // for the same channel in multiple packets.
 5282     do {
 5283        stbi__pic_packet *packet;
 ....
 5299     } while (chained);
 5300  
 5301:    *comp = (act_comp & 0x10 ? 4 : 3); // has alpha channel?
 5302  
 5303     for(y=0; y<height; ++y) {
 ....
 5312                 return stbi__errpuc("bad format","packet has bad compression type");
 5313  
 5314:             case 0: {//uncompressed
 5315                 int x;
 5316  
 ....
 5321              }
 5322  
 5323:             case 1://Pure RLE
 5324                 {
 5325                    int left=width, i;
 ....
 5343                 break;
 5344  
 5345:             case 2: {//Mixed RLE
 5346                 int left=width;
 5347                 while (left>0) {
 ....
 5349                    if (stbi__at_eof(s))  return stbi__errpuc("bad file","file too short (mixed read count)");
 5350  
 5351:                   if (count >= 128) { // Repeated
 5352                       stbi_uc value[4];
 5353                       int i;
 ....
 5365                       for(i=0;i<count;++i, dest += 4)
 5366                          stbi__copyval(packet->channel,dest,value);
 5367:                   } else { // Raw
 5368                       ++count;
 5369                       if (count>left) return stbi__errpuc("bad file","scanline overrun");
 ....
 5397     if ((1 << 28) / x < y) return stbi__errpuc("too large", "Image too large to decode");
 5398  
 5399:    stbi__get32be(s); //skip `ratio'
 5400:    stbi__get16be(s); //skip `fields'
 5401:    stbi__get16be(s); //skip `pad'
 5402  
 5403:    // intermediate buffer is RGBA
 5404     result = (stbi_uc *) stbi__malloc(x*y*4);
 5405     memset(result, 0xff, x*y*4);
 ....
 5425  #endif
 5426  
 5427: // *************************************************************************************************
 5428: // GIF loader -- public domain by Jean-Marc Lienher -- simplified/shrunk by stb
 5429  
 5430  #ifndef STBI_NO_GIF
 ....
 5439  {
 5440     int w,h;
 5441:    stbi_uc *out;                 // output buffer (always 4 components)
 5442     int flags, bgindex, ratio, transparent, eflags;
 5443     stbi_uc  pal[256][4];
 ....
 5499     g->transparent = -1;
 5500  
 5501:    if (comp != 0) *comp = 4;  // can't actually tell whether it's 3 or 4 until we parse the comments
 5502  
 5503     if (is_info) return 1;
 ....
 5525     stbi_uc *p, *c;
 5526  
 5527:    // recurse to decode the prefixes, since the linked-list is backwards,
 5528:    // and working backwards through an interleaved image would be nasty
 5529     if (g->codes[code].prefix >= 0)
 5530        stbi__out_gif_code(g, g->codes[code].prefix);
 ....
 5577     }
 5578  
 5579:    // support no starting clear code
 5580     avail = clear+2;
 5581     oldcode = -1;
 ....
 5585        if (valid_bits < codesize) {
 5586           if (len == 0) {
 5587:             len = stbi__get8(s); // start new block
 5588              if (len == 0)
 5589                 return g->out;
 ....
 5596           bits >>= codesize;
 5597           valid_bits -= codesize;
 5598:          // @OPTIMIZE: is there some way we can accelerate the non-clear path?
 5599:          if (code == clear) {  // clear code
 5600              codesize = lzw_cs + 1;
 5601              codemask = (1 << codesize) - 1;
 ....
 5603              oldcode = -1;
 5604              first = 0;
 5605:          } else if (code == clear + 1) { // end of stream code
 5606              stbi__skip(s, len);
 5607              while ((len = stbi__get8(s)) > 0)
 ....
 5639     int i;
 5640     stbi_uc *c = g->pal[g->bgindex];
 5641:    // @OPTIMIZE: write a dword at a time
 5642     for (i = 0; i < g->w * g->h * 4; i += 4) {
 5643        stbi_uc *p  = &g->out[i];
 ....
 5649  }
 5650  
 5651: // this function is designed to support animated gifs, although stb_image doesn't support it
 5652  static stbi_uc *stbi__gif_load_next(stbi__context *s, stbi__gif *g, int *comp, int req_comp)
 5653  {
 ....
 5656  
 5657     if (g->out == 0) {
 5658:       if (!stbi__gif_header(s, g, comp,0))     return 0; // stbi__g_failure_reason set by stbi__gif_header
 5659        g->out = (stbi_uc *) stbi__malloc(4 * g->w * g->h);
 5660        if (g->out == 0)                      return stbi__errpuc("outofmem", "Out of memory");
 5661        stbi__fill_gif_background(g);
 5662     } else {
 5663:       // animated-gif-only path
 5664        if (((g->eflags & 0x1C) >> 2) == 3) {
 5665           old_out = g->out;
 ....
 5672     for (;;) {
 5673        switch (stbi__get8(s)) {
 5674:          case 0x2C: /* Image Descriptor */
 5675           {
 5676              stbi__int32 x, y, w, h;
 ....
 5695  
 5696              if (g->lflags & 0x40) {
 5697:                g->step = 8 * g->line_size; // first interlaced spacing
 5698                 g->parse = 3;
 5699              } else {
 ....
 5706                 g->color_table = (stbi_uc *) g->lpal;
 5707              } else if (g->flags & 0x80) {
 5708:                for (i=0; i < 256; ++i)  // @OPTIMIZE: stbi__jpeg_reset only the previous transparent
 5709                    g->pal[i][3] = 255;
 5710                 if (g->transparent >= 0 && (g->eflags & 0x01))
 ....
 5722           }
 5723  
 5724:          case 0x21: // Comment Extension.
 5725           {
 5726              int len;
 5727:             if (stbi__get8(s) == 0xF9) { // Graphic Control Extension.
 5728                 len = stbi__get8(s);
 5729                 if (len == 4) {
 5730                    g->eflags = stbi__get8(s);
 5731:                   stbi__get16le(s); // delay
 5732                    g->transparent = stbi__get8(s);
 5733                 } else {
 ....
 5741           }
 5742  
 5743:          case 0x3B: // gif stream termination code
 5744:             return (stbi_uc *) s; // using '1' causes warning on some compilers
 5745  
 5746           default:
 ....
 5757  
 5758     u = stbi__gif_load_next(s, &g, comp, req_comp);
 5759:    if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker
 5760     if (u) {
 5761        *x = g.w;
 ....
 5772  #endif
 5773  
 5774: // *************************************************************************************************
 5775: // Radiance RGBE HDR loader
 5776: // originally by Nicolas Schulz
 5777  #ifndef STBI_NO_HDR
 5778  static int stbi__hdr_test_core(stbi__context *s)
 ....
 5804        buffer[len++] = c;
 5805        if (len == STBI__HDR_BUFLEN-1) {
 5806:          // flush to end of line
 5807           while (!stbi__at_eof(z) && stbi__get8(z) != '\n')
 5808              ;
 ....
 5820     if ( input[3] != 0 ) {
 5821        float f1;
 5822:       // Exponent
 5823        f1 = (float) ldexp(1.0f, input[3] - (int)(128 + 8));
 5824        if (req_comp <= 2)
 ....
 5833     } else {
 5834        switch (req_comp) {
 5835:          case 4: output[3] = 1; /* fallthrough */
 5836           case 3: output[0] = output[1] = output[2] = 0;
 5837                   break;
 5838:          case 2: output[1] = 1; /* fallthrough */
 5839           case 1: output[0] = 0;
 5840                   break;
 ....
 5856  
 5857  
 5858:    // Check identifier
 5859     if (strcmp(stbi__hdr_gettoken(s,buffer), "#?RADIANCE") != 0)
 5860        return stbi__errpf("not HDR", "Corrupt HDR image");
 5861  
 5862:    // Parse header
 5863     for(;;) {
 5864        token = stbi__hdr_gettoken(s,buffer);
 ....
 5869     if (!valid)    return stbi__errpf("unsupported format", "Unsupported HDR format");
 5870  
 5871:    // Parse width and height
 5872:    // can't use sscanf() if we're not using stdio!
 5873     token = stbi__hdr_gettoken(s,buffer);
 5874     if (strncmp(token, "-Y ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");
 ....
 5886     if (req_comp == 0) req_comp = 3;
 5887  
 5888:    // Read data
 5889     hdr_data = (float *) stbi__malloc(height * width * req_comp * sizeof(float));
 5890  
 5891:    // Load image data
 5892:    // image data is stored as some number of sca
 5893     if ( width < 8 || width >= 32768) {
 5894:       // Read flat data
 5895        for (j=0; j < height; ++j) {
 5896           for (i=0; i < width; ++i) {
 ....
 5902        }
 5903     } else {
 5904:       // Read RLE-encoded data
 5905        scanline = NULL;
 5906  
 ....
 5910           len = stbi__get8(s);
 5911           if (c1 != 2 || c2 != 2 || (len & 0x80)) {
 5912:             // not run-length encoded, so we have to actually use THIS data as a decoded
 5913:             // pixel (note this can't be a valid pixel--one of RGB must be >= 128)
 5914              stbi_uc rgbe[4];
 5915              rgbe[0] = (stbi_uc) c1;
 ....
 5921              j = 0;
 5922              STBI_FREE(scanline);
 5923:             goto main_decode_loop; // yes, this makes no sense
 5924           }
 5925           len <<= 8;
 ....
 5933                 count = stbi__get8(s);
 5934                 if (count > 128) {
 5935:                   // Run
 5936                    value = stbi__get8(s);
 5937                    count -= 128;
 ....
 5939                       scanline[i++ * 4 + k] = value;
 5940                 } else {
 5941:                   // Dump
 5942                    for (z = 0; z < count; ++z)
 5943                       scanline[i++ * 4 + k] = stbi__get8(s);
 ....
 5992     return 1;
 5993  }
 5994: #endif // STBI_NO_HDR
 5995  
 5996  #ifndef STBI_NO_BMP
 ....
 6104  #endif
 6105  
 6106: // *************************************************************************************************
 6107: // Portable Gray Map and Portable Pixel Map loader
 6108: // by Ken Miller
 6109: //
 6110: // PGM: http://netpbm.sourceforge.net/doc/pgm.html
 6111: // PPM: http://netpbm.sourceforge.net/doc/ppm.html
 6112: //
 6113: // Known limitations:
 6114: //    Does not support comments in the header section
 6115: //    Does not support ASCII image data (formats P2 and P3)
 6116: //    Does not support 16-bit-per-channel
 6117  
 6118  #ifndef STBI_NO_PNM
 ....
 6145     if (req_comp && req_comp != s->img_n) {
 6146        out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);
 6147:       if (out == NULL) return out; // stbi__convert_format frees input on failure
 6148     }
 6149     return out;
 ....
 6185     stbi__rewind( s );
 6186  
 6187:    // Get identifier
 6188     p = (char) stbi__get8(s);
 6189     t = (char) stbi__get8(s);
 ....
 6193     }
 6194  
 6195:    *comp = (t == '6') ? 3 : 1;  // '5' is 1-component .pgm; '6' is 3-component .ppm
 6196  
 6197     c = (char) stbi__get8(s);
 6198     stbi__pnm_skip_whitespace(s, &c);
 6199  
 6200:    *x = stbi__pnm_getinteger(s, &c); // read width
 6201     stbi__pnm_skip_whitespace(s, &c);
 6202  
 6203:    *y = stbi__pnm_getinteger(s, &c); // read height
 6204     stbi__pnm_skip_whitespace(s, &c);
 6205  
 6206:    maxv = stbi__pnm_getinteger(s, &c);  // read max value
 6207  
 6208     if (maxv > 255)
 ....
 6247     #endif
 6248  
 6249:    // test tga last because it's a crappy test!
 6250     #ifndef STBI_NO_TGA
 6251     if (stbi__tga_info(s, x, y, comp))
 ....
 6276     return r;
 6277  }
 6278: #endif // !STBI_NO_STDIO
 6279  
 6280  STBIDEF int stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp)
 ....
 6292  }
 6293  
 6294: #endif // STB_IMAGE_IMPLEMENTATION
 6295  
 6296: /*
 6297:    revision history:
 6298:       2.06  (2015-04-19) fix bug where PSD returns wrong '*comp' value
 6299:       2.05  (2015-04-19) fix bug in progressive JPEG handling, fix warning
 6300:       2.04  (2015-04-15) try to re-enable SIMD on MinGW 64-bit
 6301:       2.03  (2015-04-12) extra corruption checking (mmozeiko)
 6302:                          stbi_set_flip_vertically_on_load (nguillemot)
 6303:                          fix NEON support; fix mingw support
 6304:       2.02  (2015-01-19) fix incorrect assert, fix warning
 6305:       2.01  (2015-01-17) fix various warnings; suppress SIMD on gcc 32-bit without -msse2
 6306:       2.00b (2014-12-25) fix STBI_MALLOC in progressive JPEG
 6307:       2.00  (2014-12-25) optimize JPG, including x86 SSE2 & NEON SIMD (ryg)
 6308:                          progressive JPEG (stb)
 6309:                          PGM/PPM support (Ken Miller)
 6310:                          STBI_MALLOC,STBI_REALLOC,STBI_FREE
 6311:                          GIF bugfix -- seemingly never worked
 6312:                          STBI_NO_*, STBI_ONLY_*
 6313:       1.48  (2014-12-14) fix incorrectly-named assert()
 6314:       1.47  (2014-12-14) 1/2/4-bit PNG support, both direct and paletted (Omar Cornut & stb)
 6315:                          optimize PNG (ryg)
 6316:                          fix bug in interlaced PNG with user-specified channel count (stb)
 6317:       1.46  (2014-08-26)
 6318:               fix broken tRNS chunk (colorkey-style transparency) in non-paletted PNG
 6319:       1.45  (2014-08-16)
 6320:               fix MSVC-ARM internal compiler error by wrapping malloc
 6321:       1.44  (2014-08-07)
 6322:               various warning fixes from Ronny Chevalier
 6323:       1.43  (2014-07-15)
 6324:               fix MSVC-only compiler problem in code changed in 1.42
 6325:       1.42  (2014-07-09)
 6326:               don't define _CRT_SECURE_NO_WARNINGS (affects user code)
 6327:               fixes to stbi__cleanup_jpeg path
 6328:               added STBI_ASSERT to avoid requiring assert.h
 6329:       1.41  (2014-06-25)
 6330:               fix search&replace from 1.36 that messed up comments/error messages
 6331:       1.40  (2014-06-22)
 6332:               fix gcc struct-initialization warning
 6333:       1.39  (2014-06-15)
 6334:               fix to TGA optimization when req_comp != number of components in TGA;
 6335:               fix to GIF loading because BMP wasn't rewinding (whoops, no GIFs in my test suite)
 6336:               add support for BMP version 5 (more ignored fields)
 6337:       1.38  (2014-06-06)
 6338:               suppress MSVC warnings on integer casts truncating values
 6339:               fix accidental rename of 'skip' field of I/O
 6340:       1.37  (2014-06-04)
 6341:               remove duplicate typedef
 6342:       1.36  (2014-06-03)
 6343:               convert to header file single-file library
 6344:               if de-iphone isn't set, load iphone images color-swapped instead of returning NULL
 6345:       1.35  (2014-05-27)
 6346:               various warnings
 6347:               fix broken STBI_SIMD path
 6348:               fix bug where stbi_load_from_file no longer left file pointer in correct place
 6349:               fix broken non-easy path for 32-bit BMP (possibly never used)
 6350:               TGA optimization by Arseny Kapoulkine
 6351:       1.34  (unknown)
 6352:               use STBI_NOTUSED in stbi__resample_row_generic(), fix one more leak in tga failure case
 6353:       1.33  (2011-07-14)
 6354:               make stbi_is_hdr work in STBI_NO_HDR (as specified), minor compiler-friendly improvements
 6355:       1.32  (2011-07-13)
 6356:               support for "info" function for all supported filetypes (SpartanJ)
 6357:       1.31  (2011-06-20)
 6358:               a few more leak fixes, bug in PNG handling (SpartanJ)
 6359:       1.30  (2011-06-11)
 6360:               added ability to load files via callbacks to accomidate custom input streams (Ben Wenger)
 6361:               removed deprecated format-specific test/load functions
 6362:               removed support for installable file formats (stbi_loader) -- would have been broken for IO callbacks anyway
 6363:               error cases in bmp and tga give messages and don't leak (Raymond Barbiero, grisha)
 6364:               fix inefficiency in decoding 32-bit BMP (David Woo)
 6365:       1.29  (2010-08-16)
 6366:               various warning fixes from Aurelien Pocheville
 6367:       1.28  (2010-08-01)
 6368:               fix bug in GIF palette transparency (SpartanJ)
 6369:       1.27  (2010-08-01)
 6370:               cast-to-stbi_uc to fix warnings
 6371:       1.26  (2010-07-24)
 6372:               fix bug in file buffering for PNG reported by SpartanJ
 6373:       1.25  (2010-07-17)
 6374:               refix trans_data warning (Won Chun)
 6375:       1.24  (2010-07-12)
 6376:               perf improvements reading from files on platforms with lock-heavy fgetc()
 6377:               minor perf improvements for jpeg
 6378:               deprecated type-specific functions so we'll get feedback if they're needed
 6379:               attempt to fix trans_data warning (Won Chun)
 6380:       1.23    fixed bug in iPhone support
 6381:       1.22  (2010-07-10)
 6382:               removed image *writing* support
 6383:               stbi_info support from Jetro Lauha
 6384:               GIF support from Jean-Marc Lienher
 6385:               iPhone PNG-extensions from James Brown
 6386:               warning-fixes from Nicolas Schulz and Janez Zemva (i.stbi__err. Janez (U+017D)emva)
 6387:       1.21    fix use of 'stbi_uc' in header (reported by jon blow)
 6388:       1.20    added support for Softimage PIC, by Tom Seddon
 6389:       1.19    bug in interlaced PNG corruption check (found by ryg)
 6390:       1.18  (2008-08-02)
 6391:               fix a threading bug (local mutable static)
 6392:       1.17    support interlaced PNG
 6393:       1.16    major bugfix - stbi__convert_format converted one too many pixels
 6394:       1.15    initialize some fields for thread safety
 6395:       1.14    fix threadsafe conversion bug
 6396:               header-file-only version (#define STBI_HEADER_FILE_ONLY before including)
 6397:       1.13    threadsafe
 6398:       1.12    const qualifiers in the API
 6399:       1.11    Support installable IDCT, colorspace conversion routines
 6400:       1.10    Fixes for 64-bit (don't use "unsigned long")
 6401:               optimized upsampling by Fabian "ryg" Giesen
 6402:       1.09    Fix format-conversion for PSD code (bad global variables!)
 6403:       1.08    Thatcher Ulrich's PSD code integrated by Nicolas Schulz
 6404:       1.07    attempt to fix C++ warning/errors again
 6405:       1.06    attempt to fix C++ warning/errors again
 6406:       1.05    fix TGA loading to return correct *comp and use good luminance calc
 6407:       1.04    default float alpha is 1, not 255; use 'void *' for stbi_image_free
 6408:       1.03    bugfixes to STBI_NO_STDIO, STBI_NO_HDR
 6409:       1.02    support for (subset of) HDR files, float interface for preferred access to them
 6410:       1.01    fix bug: possible bug in handling right-side up bmps... not sure
 6411:               fix bug: the stbi__bmp_load() and stbi__tga_load() functions didn't work at all
 6412:       1.00    interface to zlib that skips zlib header
 6413:       0.99    correct handling of alpha in palette
 6414:       0.98    TGA loader by lonesock; dynamically add loaders (untested)
 6415:       0.97    jpeg errors on too large a file; also catch another malloc failure
 6416:       0.96    fix detection of invalid v value - particleman@mollyrocket forum
 6417:       0.95    during header scan, seek to markers in case of padding
 6418:       0.94    STBI_NO_STDIO to disable stdio usage; rename all #defines the same
 6419:       0.93    handle jpegtran output; verbose errors
 6420:       0.92    read 4,8,16,24,32-bit BMP files of several formats
 6421:       0.91    output 24-bit Windows 3.0 BMP files
 6422:       0.90    fix a few more warnings; bump version number to approach 1.0
 6423:       0.61    bugfixes due to Marc LeBlanc, Christopher Lloyd
 6424:       0.60    fix compiling as c++
 6425:       0.59    fix warnings: merge Dave Moore's -Wall fixes
 6426:       0.58    fix bug: zlib uncompressed mode len/nlen was wrong endian
 6427:       0.57    fix bug: jpg last huffman symbol before marker was >9 bits but less than 16 available
 6428:       0.56    fix bug: zlib uncompressed mode len vs. nlen
 6429:       0.55    fix bug: restart_interval not initialized to 0
 6430:       0.54    allow NULL for 'int *comp'
 6431:       0.53    fix bug in png 3->4; speedup png decoding
 6432:       0.52    png handles req_comp=3,4 directly; minor cleanup; jpeg comments
 6433:       0.51    obey req_comp requests, 1-component jpegs return as 1-component,
 6434:               on 'test' only check type, not whether we support this variant
 6435:       0.50  (2006-11-19)
 6436:               first released version
 6437: */
 6438  

/Users/anthonybudd/Development/darknet/src/stb_image_write.h:
    1: /* stb_image_write - v0.98 - public domain - http://nothings.org/stb/stb_image_write.h
    2:    writes out PNG/BMP/TGA images to C stdio - Sean Barrett 2010
    3:                             no warranty implied; use at your own risk
    4: 
    5: 
    6:    Before #including,
    7: 
    8:        #define STB_IMAGE_WRITE_IMPLEMENTATION
    9: 
   10:    in the file that you want to have the implementation.
   11: 
   12:    Will probably not work correctly with strict-aliasing optimizations.
   13: 
   14: ABOUT:
   15: 
   16:    This header file is a library for writing images to C stdio. It could be
   17:    adapted to write to memory or a general streaming interface; let me know.
   18: 
   19:    The PNG output is not optimal; it is 20-50% larger than the file
   20:    written by a decent optimizing implementation. This library is designed
   21:    for source code compactness and simplicitly, not optimal image file size
   22:    or run-time performance.
   23: 
   24: BUILDING:
   25: 
   26:    You can #define STBIW_ASSERT(x) before the #include to avoid using assert.h.
   27:    You can #define STBIW_MALLOC(), STBIW_REALLOC(), and STBIW_FREE() to replace
   28:    malloc,realloc,free.
   29:    You can define STBIW_MEMMOVE() to replace memmove()
   30: 
   31: USAGE:
   32: 
   33:    There are four functions, one for each image file format:
   34: 
   35:      int stbi_write_png(char const *filename, int w, int h, int comp, const void *data, int stride_in_bytes);
   36:      int stbi_write_bmp(char const *filename, int w, int h, int comp, const void *data);
   37:      int stbi_write_tga(char const *filename, int w, int h, int comp, const void *data);
   38:      int stbi_write_hdr(char const *filename, int w, int h, int comp, const void *data);
   39: 
   40:    Each function returns 0 on failure and non-0 on success.
   41: 
   42:    The functions create an image file defined by the parameters. The image
   43:    is a rectangle of pixels stored from left-to-right, top-to-bottom.
   44:    Each pixel contains 'comp' channels of data stored interleaved with 8-bits
   45:    per channel, in the following order: 1=Y, 2=YA, 3=RGB, 4=RGBA. (Y is
   46:    monochrome color.) The rectangle is 'w' pixels wide and 'h' pixels tall.
   47:    The *data pointer points to the first byte of the top-left-most pixel.
   48:    For PNG, "stride_in_bytes" is the distance in bytes from the first byte of
   49:    a row of pixels to the first byte of the next row of pixels.
   50: 
   51:    PNG creates output files with the same number of components as the input.
   52:    The BMP format expands Y to RGB in the file format and does not
   53:    output alpha.
   54: 
   55:    PNG supports writing rectangles of data even when the bytes storing rows of
   56:    data are not consecutive in memory (e.g. sub-rectangles of a larger image),
   57:    by supplying the stride between the beginning of adjacent rows. The other
   58:    formats do not. (Thus you cannot write a native-format BMP through the BMP
   59:    writer, both because it is in BGR order and because it may have padding
   60:    at the end of the line.)
   61: 
   62:    HDR expects linear float data. Since the format is always 32-bit rgb(e)
   63:    data, alpha (if provided) is discarded, and for monochrome data it is
   64:    replicated across all three channels.
   65: 
   66: CREDITS:
   67: 
   68:    PNG/BMP/TGA
   69:       Sean Barrett
   70:    HDR
   71:       Baldur Karlsson
   72:    TGA monochrome:
   73:       Jean-Sebastien Guay
   74:    misc enhancements:
   75:       Tim Kelsey
   76:    bugfixes:
   77:       github:Chribba
   78: */
   79  
   80  #ifndef INCLUDE_STB_IMAGE_WRITE_H
   ..
   94  #endif
   95  
   96: #endif//INCLUDE_STB_IMAGE_WRITE_H
   97  
   98  #ifdef STB_IMAGE_WRITE_IMPLEMENTATION
   ..
  105  
  106  #if defined(STBIW_MALLOC) && defined(STBIW_FREE) && defined(STBIW_REALLOC)
  107: // ok
  108  #elif !defined(STBIW_MALLOC) && !defined(STBIW_FREE) && !defined(STBIW_REALLOC)
  109: // ok
  110  #else
  111  #error "Must define all or none of STBIW_MALLOC, STBIW_FREE, and STBIW_REALLOC."
  ...
  180                      break;
  181              case 2: if (expand_mono)
  182:                        write3(f, d[0],d[0],d[0]); // monochrome bmp
  183                      else
  184:                        fwrite(d, 1, 1, f);  // monochrome TGA
  185                      break;
  186              case 4:
  187                 if (!write_alpha) {
  188:                   // composite against pink background
  189                    for (k=0; k < 3; ++k)
  190                       px[k] = bg[k] + ((d[k] - bg[k]) * d[3])/255;
  ...
  192                    break;
  193                 }
  194:                /* FALLTHROUGH */
  195              case 3:
  196                 write3(f, d[1-rgb_dir],d[1],d[1+rgb_dir]);
  ...
  225     return outfile(filename,-1,-1,x,y,comp,1,(void *) data,0,pad,
  226             "11 4 22 4" "4 44 22 444444",
  227:            'B', 'M', 14+40+(x*3+pad)*y, 0,0, 14+40,  // file header
  228:             40, x,y, 1,24, 0,0,0,0,0,0);             // bitmap header
  229  }
  230  
  ...
  233     int has_alpha = (comp == 2 || comp == 4);
  234     int colorbytes = has_alpha ? comp-1 : comp;
  235:    int format = colorbytes < 2 ? 3 : 2; // 3 color channels (RGB/RGBA) = 2, 1 color channel (Y/YA) = 3
  236     return outfile(filename, -1,-1, x, y, comp, 0, (void *) data, has_alpha, 0,
  237                    "111 221 2222 11", 0,0,format, 0,0,0, 0,0,x,y, (colorbytes+has_alpha)*8, has_alpha*8);
  238  }
  239  
  240: // *************************************************************************************************
  241: // Radiance RGBE HDR writer
  242: // by Baldur Karlsson
  243  #define stbiw__max(a, b)  ((a) > (b) ? (a) : (b))
  244  
  ...
  271  {
  272     unsigned char lengthbyte = (unsigned char )(length & 0xff);
  273:    STBIW_ASSERT(length <= 128); // inconsistent with spec but consistent with official code
  274     fwrite(&lengthbyte, 1, 1, f);
  275     fwrite(data, length, 1, f);
  ...
  286     scanlineheader[3] = (width&0x00ff);
  287  
  288:    /* skip RLE for images too small or large */
  289     if (width < 8 || width >= 32768) {
  290        for (x=0; x < width; x++) {
  291           switch (comp) {
  292:             case 4: /* fallthrough */
  293              case 3: linear[2] = scanline[x*comp + 2];
  294                      linear[1] = scanline[x*comp + 1];
  295                      linear[0] = scanline[x*comp + 0];
  296                      break;
  297:             case 2: /* fallthrough */
  298              case 1: linear[0] = linear[1] = linear[2] = scanline[x*comp + 0];
  299                      break;
  ...
  304     } else {
  305        int c,r;
  306:       /* encode into scratch buffer */
  307        for (x=0; x < width; x++) {
  308           switch(comp) {
  309:             case 4: /* fallthrough */
  310              case 3: linear[2] = scanline[x*comp + 2];
  311                      linear[1] = scanline[x*comp + 1];
  312                      linear[0] = scanline[x*comp + 0];
  313                      break;
  314:             case 2: /* fallthrough */
  315              case 1: linear[0] = linear[1] = linear[2] = scanline[x*comp + 0];
  316                      break;
  ...
  325        fwrite(scanlineheader, 4, 1, f);
  326  
  327:       /* RLE each component separately */
  328        for (c=0; c < 4; c++) {
  329           unsigned char *comp = &scratch[width*c];
  ...
  331           x = 0;
  332           while (x < width) {
  333:             // find first run
  334              r = x;
  335              while (r+2 < width) {
  ...
  340              if (r+2 >= width)
  341                 r = width;
  342:             // dump up to first run
  343              while (x < r) {
  344                 int len = r-x;
  ...
  347                 x += len;
  348              }
  349:             // if there's a run, output it
  350:             if (r+2 < width) { // same test as what we break out of in search loop, so only true if we break'd
  351:                // find next byte after run
  352                 while (r < width && comp[r] == comp[x])
  353                    ++r;
  354:                // output run up to r
  355                 while (x < r) {
  356                    int len = r-x;
  ...
  372     f = fopen(filename, "wb");
  373     if (f) {
  374:       /* Each component is stored separately. Allocate scratch space for full output scanline. */
  375        unsigned char *scratch = (unsigned char *) STBIW_MALLOC(x*4);
  376        fprintf(f, "#?RADIANCE\n# Written by stb_image_write.h\nFORMAT=32-bit_rle_rgbe\n"      );
  ...
  384  }
  385  
  386: /////////////////////////////////////////////////////////
  387: // PNG
  388  
  389: // stretchy buffer; stbiw__sbpush() == vector<>::push_back() -- stbiw__sbcount() == vector<>::size()
  390  #define stbiw__sbraw(a) ((int *) (a) - 2)
  391  #define stbiw__sbm(a)   stbiw__sbraw(a)[0]
  ...
  457        (bitbuf |= (code) << bitcount, bitcount += (codebits), stbiw__zlib_flush())
  458  #define stbiw__zlib_huffa(b,c)  stbiw__zlib_add(stbiw__zlib_bitrev(b,c),c)
  459: // default huffman tables
  460  #define stbiw__zlib_huff1(n)  stbiw__zlib_huffa(0x30 + (n), 8)
  461  #define stbiw__zlib_huff2(n)  stbiw__zlib_huffa(0x190 + (n)-144, 9)
  ...
  476     int i,j, bitcount=0;
  477     unsigned char *out = NULL;
  478:    unsigned char **hash_table[stbiw__ZHASH]; // 64KB on the stack!
  479     if (quality < 5) quality = 5;
  480  
  481:    stbiw__sbpush(out, 0x78);   // DEFLATE 32K window
  482:    stbiw__sbpush(out, 0x5e);   // FLEVEL = 1
  483:    stbiw__zlib_add(1,1);  // BFINAL = 1
  484:    stbiw__zlib_add(1,2);  // BTYPE = 1 -- fixed huffman
  485  
  486     for (i=0; i < stbiw__ZHASH; ++i)
  ...
  489     i=0;
  490     while (i < data_len-3) {
  491:       // hash next 3 bytes of data to be compressed
  492        int h = stbiw__zhash(data+i)&(stbiw__ZHASH-1), best=3;
  493        unsigned char *bestloc = 0;
  ...
  495        int n = stbiw__sbcount(hlist);
  496        for (j=0; j < n; ++j) {
  497:          if (hlist[j]-data > i-32768) { // if entry lies within window
  498              int d = stbiw__zlib_countm(hlist[j], data+i, data_len-i);
  499              if (d >= best) best=d,bestloc=hlist[j];
  500           }
  501        }
  502:       // when hash table entry is too long, delete half the entries
  503        if (hash_table[h] && stbiw__sbn(hash_table[h]) == 2*quality) {
  504           STBIW_MEMMOVE(hash_table[h], hash_table[h]+quality, sizeof(hash_table[h][0])*quality);
  ...
  508  
  509        if (bestloc) {
  510:          // "lazy matching" - check match at *next* byte, and if it's better, do cur byte as literal
  511           h = stbiw__zhash(data+i+1)&(stbiw__ZHASH-1);
  512           hlist = hash_table[h];
  ...
  515              if (hlist[j]-data > i-32767) {
  516                 int e = stbiw__zlib_countm(hlist[j], data+i+1, data_len-i-1);
  517:                if (e > best) { // if next match is better, bail on current match
  518                    bestloc = NULL;
  519                    break;
  ...
  524  
  525        if (bestloc) {
  526:          int d = (int) (data+i - bestloc); // distance back
  527           STBIW_ASSERT(d <= 32767 && best <= 258);
  528           for (j=0; best > lengthc[j+1]-1; ++j);
  ...
  538        }
  539     }
  540:    // write out final bytes
  541     for (;i < data_len; ++i)
  542        stbiw__zlib_huffb(data[i]);
  543:    stbiw__zlib_huff(256); // end of block
  544:    // pad with 0 bits to byte boundary
  545     while (bitcount)
  546        stbiw__zlib_add(0,1);
  ...
  550  
  551     {
  552:       // compute adler32 on input
  553        unsigned int i=0, s1=1, s2=0, blocklen = data_len % 5552;
  554        int j=0;
  ...
  565     }
  566     *out_len = stbiw__sbn(out);
  567:    // make returned pointer freeable
  568     STBIW_MEMMOVE(stbiw__sbraw(out), out, *out_len);
  569     return (unsigned char *) stbiw__sbraw(out);
  ...
  651           }
  652        }
  653:       // when we get here, best contains the filter type, and line_buffer contains the data
  654        filt[j*(x*n+1)] = (unsigned char) best;
  655        STBIW_MEMMOVE(filt+j*(x*n+1)+1, line_buffer, x*n);
  656     }
  657     STBIW_FREE(line_buffer);
  658:    zlib = stbi_zlib_compress(filt, y*( x*n+1), &zlen, 8); // increase 8 to get smaller but use more memory
  659     STBIW_FREE(filt);
  660     if (!zlib) return 0;
  661  
  662:    // each tag requires 12 bytes of overhead
  663     out = (unsigned char *) STBIW_MALLOC(8 + 12+13 + 12+zlen + 12);
  664     if (!out) return 0;
  ...
  667     o=out;
  668     STBIW_MEMMOVE(o,sig,8); o+= 8;
  669:    stbiw__wp32(o, 13); // header length
  670     stbiw__wptag(o, "IHDR");
  671     stbiw__wp32(o, x);
  ...
  707     return 1;
  708  }
  709: #endif // STB_IMAGE_WRITE_IMPLEMENTATION
  710  
  711: /* Revision history
  712:       0.98 (2015-04-08)
  713:              added STBIW_MALLOC, STBIW_ASSERT etc
  714:       0.97 (2015-01-18)
  715:              fixed HDR asserts, rewrote HDR rle logic
  716:       0.96 (2015-01-17)
  717:              add HDR output
  718:              fix monochrome BMP
  719:       0.95 (2014-08-17)
  720: 		       add monochrome TGA output
  721:       0.94 (2014-05-31)
  722:              rename private functions to avoid conflicts with stb_image.h
  723:       0.93 (2014-05-27)
  724:              warning fixes
  725:       0.92 (2010-08-01)
  726:              casts to unsigned char to fix warnings
  727:       0.91 (2010-07-17)
  728:              first public release
  729:       0.90   first internal release
  730: */
  731  

/Users/anthonybudd/Development/darknet/src/super.c:
   27  
   28      list *plist = get_paths(train_images);
   29:     //int N = plist->size;
   30      char **paths = (char **)list_to_array(plist);
   31  
   ..
   42      pthread_t load_thread = load_data_in_thread(args);
   43      clock_t time;
   44:     //while(i*imgs < N*120){
   45      while(get_current_batch(net) < net.max_batches){
   46          i += 1;
   ..
  126      if(0==strcmp(argv[2], "train")) train_super(cfg, weights);
  127      else if(0==strcmp(argv[2], "test")) test_super(cfg, weights, filename);
  128:     /*
  129:     else if(0==strcmp(argv[2], "valid")) validate_super(cfg, weights);
  130:     */
  131  }
  132  

/Users/anthonybudd/Development/darknet/src/swag.c:
   34  
   35      list *plist = get_paths(train_images);
   36:     //int N = plist->size;
   37      char **paths = (char **)list_to_array(plist);
   38  
   ..
   51      pthread_t load_thread = load_data_in_thread(args);
   52      clock_t time;
   53:     //while(i*imgs < N*120){
   54      while(get_current_batch(net) < net.max_batches){
   55          i += 1;

/Users/anthonybudd/Development/darknet/src/tree.c:
  133      tree *tree_ptr = calloc(1, sizeof(tree));
  134      *tree_ptr = t;
  135:     //error(0);
  136      return tree_ptr;
  137  }

/Users/anthonybudd/Development/darknet/src/utils.c:
  157  
  158      sprintf(buffer, "%s", str);
  159:     if(!(p = strstr(buffer, orig))){  // Is 'orig' even in 'str'?
  160          sprintf(output, "%s", str);
  161          return;
  ...
  391              field[count] = strtod(p, &end);
  392              if(p == c) field[count] = nan("");
  393:             if(end != c && (end != c-1 || *end != '\r')) field[count] = nan(""); //DOS file formats!
  394              p = c+1;
  395              ++count;
  ...
  550  }
  551  
  552: // From http://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform
  553  float rand_normal()
  554  {
  ...
  572  }
  573  
  574: /*
  575:    float rand_normal()
  576:    {
  577:    int n = 12;
  578:    int i;
  579:    float sum= 0;
  580:    for(i = 0; i < n; ++i) sum += (float)rand()/RAND_MAX;
  581:    return sum-n/2.;
  582:    }
  583:  */
  584  
  585  size_t rand_size_t()

/Users/anthonybudd/Development/darknet/src/voxel.c:
   64  
   65      list *plist = get_paths(train_images);
   66:     //int N = plist->size;
   67      char **paths = (char **)list_to_array(plist);
   68  
   ..
   79      pthread_t load_thread = load_data_in_thread(args);
   80      clock_t time;
   81:     //while(i*imgs < N*120){
   82      while(get_current_batch(net) < net.max_batches){
   83          i += 1;
   ..
  164      else if(0==strcmp(argv[2], "test")) test_voxel(cfg, weights, filename);
  165      else if(0==strcmp(argv[2], "extract")) extract_voxel(argv[3], argv[4], argv[5]);
  166:     /*
  167:        else if(0==strcmp(argv[2], "valid")) validate_voxel(cfg, weights);
  168:      */
  169  }
  170  

/Users/anthonybudd/Development/darknet/src/writing.c:
   52          float loss = train_network(net, train);
   53  
   54:         /*
   55:            image pred = float_to_image(64, 64, 1, out);
   56:            print_image(pred);
   57:          */
   58  
   59:         /*
   60:            image im = float_to_image(256, 256, 3, train.X.vals[0]);
   61:            image lab = float_to_image(64, 64, 1, train.y.vals[0]);
   62:            image pred = float_to_image(64, 64, 1, out);
   63:            show_image(im, "image");
   64:            show_image(lab, "label");
   65:            print_image(lab);
   66:            show_image(pred, "pred");
   67:            cvWaitKey(0);
   68:          */
   69  
   70          if(avg_loss == -1) avg_loss = loss;

/Users/anthonybudd/Development/darknet/src/yolo.c:
   38  
   39      list *plist = get_paths(train_images);
   40:     //int N = plist->size;
   41      char **paths = (char **)list_to_array(plist);
   42  
   ..
   60      pthread_t load_thread = load_data_in_thread(args);
   61      clock_t time;
   62:     //while(i*imgs < N*120){
   63      while(get_current_batch(net) < net.max_batches){
   64          i += 1;
   ..
  120  
  121      char *base = "results/comp4_det_test_";
  122:     //list *plist = get_paths("data/voc.2007.test");
  123      list *plist = get_paths("/home/pjreddie/data/voc/2007_test.txt");
  124:     //list *plist = get_paths("data/voc.2012.test");
  125      char **paths = (char **)list_to_array(plist);
  126  
  ...
  319          get_detection_boxes(l, 1, 1, thresh, probs, boxes, 0);
  320          if (nms) do_nms_sort(boxes, probs, l.side*l.side*l.n, l.classes, nms);
  321:         //draw_detections(im, l.side*l.side*l.n, thresh, boxes, probs, voc_names, alphabet, 20);
  322          draw_detections(im, l.side*l.side*l.n, thresh, boxes, probs, voc_names, alphabet, 20);
  323          save_image(im, "predictions");

1200 matches across 45 files
